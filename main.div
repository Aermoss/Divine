/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divio", "divwin", "divfile", "divstd", "divllvm", "lexer.div", "parser.div", "compiler.div" : *;

class Timer {
    priv frequency: LARGE_INTEGER,
    priv counter: LARGE_INTEGER
} impl {
    Timer(this: Timer&) {
        QueryPerformanceFrequency(&this.frequency);
    }

    ~Timer(this: Timer&) {}

    pub Get(this: Timer&) -> f64 {
        QueryPerformanceCounter(&this.counter);
        ret (this.counter as f64) / (this.frequency as f64);
    }
};

func Execute(command: i8*, output: bool) -> DWORD {
    let startup_info: mut STARTUPINFOA;
    memset(&startup_info as void*, 0i32, sizeof(startup_info));
    startup_info.cb = sizeof(startup_info) as DWORD;
    let process_info: PROCESS_INFORMATION;

    if output != true {
        (startup_info.hStdOutput, startup_info.hStdError, startup_info.hStdInput) = (null, null, null);
        startup_info.dwFlags |= STARTF_USESTDHANDLES;
    }

    if CreateProcessA(null, command, null, null, 0i32, 0u32, null, null, &startup_info, &process_info) == 0i32 {
        printf("Failed to create process: %lu.\n", GetLastError());
        exit(1i32);
    }

    let exit_code: DWORD;
    WaitForSingleObject(process_info.hProcess, INFINITE);

    if GetExitCodeProcess(process_info.hProcess, &exit_code) == 0i32 {
        printf("Failed to get process exit code: %lu.\n", GetLastError());
    }

    CloseHandle(process_info.hProcess);
    CloseHandle(process_info.hThread);
    ret exit_code;
}

func GetWindowsSDKPath() -> String {
    let search_path[MAX_PATH]: i8;
    let path: mut String = "C:\\Program Files (x86)\\Windows Kits\\10\\Lib";
    sprintf(search_path, "%s\\*", path.Data());

    let find_data: WIN32_FIND_DATAA;
    let find_handle: HANDLE = FindFirstFileA(search_path, &find_data);

    if find_handle == INVALID_HANDLE_VALUE {
        printf("Failed to find Windows SDK path.\n");
        exit(1i32);
    }

    let highest_version_string: mut String = "";
    let (mut highest_v1: u64, mut highest_v2: u64) = (0u64, 0u64);
    let (mut highest_v3: u64, mut highest_v4: u64) = (0u64, 0u64);

    loop {
        if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0u32 {
            if strcmp(find_data.cFileName, ".") != 0i32 && strcmp(find_data.cFileName, "..") != 0i32 && strcmp(find_data.cFileName, "wdf") != 0i32 {
                let (current_v1: u64, current_v2: u64, current_v3: u64, current_v4: u64) = (0u64, 0u64, 0u64, 0u64);
                sscanf(find_data.cFileName, "%llu.%llu.%llu.%llu", &current_v1, &current_v2, &current_v3, &current_v4);

                if current_v1 > highest_v1 || (current_v1 == highest_v1 && current_v2 > highest_v2) || (current_v1 == highest_v1 && current_v2 == highest_v2 && current_v3 > highest_v3) || (current_v1 == highest_v1 && current_v2 == highest_v2 && current_v3 == highest_v3 && current_v4 > highest_v4) {
                    (highest_version_string, highest_v1, highest_v2, highest_v3, highest_v4) = (find_data.cFileName, current_v1, current_v2, current_v3, current_v4);
                }
            }
        }

        if FindNextFileA(find_handle, &find_data) == 0i32 {
            break;
        }
    }

    if highest_version_string != "" {
        path += "\\";
        path += highest_version_string;
    } else {
        printf("Failed to find a valid Windows SDK version.\n");
        exit(1i32);
    }

    FindClose(find_handle);
    ret path;
}

func GetVisualStudioPath() -> String {
    let search_path[MAX_PATH]: i8;
    let path: mut String = "C:\\Program Files\\Microsoft Visual Studio";
    sprintf(search_path, "%s\\*", path.Data());

    let find_data: WIN32_FIND_DATAA;
    let find_handle: HANDLE = FindFirstFileA(search_path, &find_data);

    if find_handle == INVALID_HANDLE_VALUE {
        printf("Failed to find Visual Studio path.\n");
        exit(1i32);
    }

    let highest_year_string: mut String = "";
    let mut highest_year: u64 = 0u64;

    loop {
        if (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0u32 {
            if strcmp(find_data.cFileName, ".") != 0i32 && strcmp(find_data.cFileName, "..") != 0i32 {
                let current_year: u64 = 0u64;
                sscanf(find_data.cFileName, "%llu", &current_year);

                if current_year > highest_year {
                    (highest_year_string, highest_year) = (find_data.cFileName, current_year);
                }
            }
        }

        if FindNextFileA(find_handle, &find_data) == 0i32 {
            break;
        }
    }

    if highest_year_string != "" {
        path += "\\";
        path += highest_year_string;
    } else {
        printf("Failed to find a valid Visual Studio year.\n");
        exit(1i32);
    }

    FindClose(find_handle);
    let search_path2[MAX_PATH]: i8;
    sprintf(search_path2, "%s\\*", path.Data());

    let find_data2: WIN32_FIND_DATAA;
    let find_handle2: HANDLE = FindFirstFileA(search_path2, &find_data2);

    if find_handle2 == INVALID_HANDLE_VALUE {
        printf("Failed to find Visual Studio path.\n");
        exit(1i32);
    }

    loop {
        if (find_data2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0u32 {
            if strcmp(find_data2.cFileName, ".") != 0i32 && strcmp(find_data2.cFileName, "..") != 0i32 {
                path += "\\";
                path += find_data2.cFileName;
                path += "\\VC\\Tools\\MSVC";
                break;
            }
        }

        if FindNextFileA(find_handle2, &find_data2) == 0i32 {
            break;
        }
    }

    FindClose(find_handle2);
    let search_path3[MAX_PATH]: i8;
    sprintf(search_path3, "%s\\*", path.Data());

    let find_data3: WIN32_FIND_DATAA;
    let find_handle3: HANDLE = FindFirstFileA(search_path3, &find_data3);

    if find_handle3 == INVALID_HANDLE_VALUE {
        printf("Failed to find Visual Studio path.\n");
        exit(1i32);
    }

    let highest_version_string: mut String = "";
    let (mut highest_v1: u64, mut highest_v2: u64) = (0u64, 0u64);
    let (mut highest_v3: u64, mut highest_v4: u64) = (0u64, 0u64);

    loop {
        if (find_data3.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0u32 {
            if strcmp(find_data3.cFileName, ".") != 0i32 && strcmp(find_data3.cFileName, "..") != 0i32 {
                let (mut current_v1: u64, mut current_v2: u64, mut current_v3: u64) = (0u64, 0u64, 0u64);
                sscanf(find_data3.cFileName, "%llu.%llu.%llu", &current_v1, &current_v2, &current_v3);

                if current_v1 > highest_v1 || (current_v1 == highest_v1 && current_v2 > highest_v2) || (current_v1 == highest_v1 && current_v2 == highest_v2 && current_v3 > highest_v3) {
                    (highest_version_string, highest_v1, highest_v2, highest_v3) = (find_data3.cFileName, current_v1, current_v2, current_v3);
                }
            }
        }

        if FindNextFileA(find_handle3, &find_data3) == 0i32 {
            break;
        }
    }

    if highest_version_string != "" {
        path += "\\";
        path += highest_version_string;
    } else {
        printf("Failed to find a valid Visual Studio version.\n");
        exit(1i32);
    }

    FindClose(find_handle3);
    ret path;
}

func ErrorHandler(reason: i8*) {
    printf("LLVM fatal error: %s\n", reason);
    exit(1i32);
}

func main(argc: i32, argv[]: i8*) -> i32 {
    let timer: Timer;
    let start: f64 = timer.Get();

    LLVMEnablePrettyStackTrace();
    LLVMInstallFatalErrorHandler(ErrorHandler);

    if argc < 2i32 {
        printf("Usage: .\\parser.exe <source_file>\n");
        ret 1i32;
    }

    let lexer: mut Lexer;
    let source: String = ReadFile(argv[1u64]);
    let tokens: Vector<Token> = lexer.Lex(source);

    let parser: mut Parser;
    parser.include_paths.PushBack(String("."));
    parser.include_paths.PushBack(String("include"));
    let ast: RootNode* = parser.Parse(tokens, String(argv[1u64]));

    let compiler: mut Compiler;
    let module: LLVMModuleRef = compiler.Compile(ast, String(argv[1u64]));

    let name: String = SplitName(String(argv[1u64]));
    let string: i8* = LLVMPrintModuleToString(module);
    WriteFile((name + ".ll").Data(), string);
    LLVMDisposeMessage(string);
    let err: i8* = null;

    if LLVMTargetMachineEmitToFile(compiler.target_machine, module, (name + ".obj").Data(), LLVMCodeGenFileType::LLVMObjectFile, &err) != 0i32 {
        printf("Failed to emit object to file: %s.\n", err);
        LLVMDisposeMessage(err);
        ret 1i32;
    }

    LLVMDisposeMessage(err);
    printf("Program compiled in %f seconds.\n", timer.Get() - start);

    let (sdk_path: String, vs_path: String) = (GetWindowsSDKPath(), GetVisualStudioPath());
    let command: String = String("\"") + vs_path + "\\bin\\Hostx64\\x64\\link.exe\" /NOLOGO /DEBUG " + name + ".obj /OUT:" + name + ".exe /LIBPATH:lib \"/LIBPATH:" + vs_path + "\\lib\\x64\" \"/LIBPATH:" + sdk_path + "\\um\\x64\" \"/LIBPATH:" + sdk_path + "\\ucrt\\x64\" legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib LLVM-C.lib raylibdll.lib";
    Execute(command.Data(), true);

    let mut i: i32 = 2i32;
    let command2: mut String = name + ".exe";

    while argc > i {
        command2 += " ";
        command2 += argv[i as u64];
        i += 1i32;
    }

    printf("Program finished with exit code: %d.\n", Execute(command2.Data(), true));
    ret 0i32;
}