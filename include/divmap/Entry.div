include "divvec", "divpair" : *;

class Map<K, V> {
    priv vector: mut Vector<Pair<K, V>>
} impl {
    Map(this: mut Map<K, V>&) {}

    Map(this: mut Map<K, V>&, other: Map<K, V>&) {
        this.vector = other.vector;
    }

    ~Map(this: mut Map<K, V>&) {}

    pub Data(this: Map<K, V>&) -> Pair<K, V>* { ret this.vector.Data(); }
    pub Size(this: Map<K, V>&) -> u64 { ret this.vector.Size(); }

    pub Keys(this: Map<K, V>&) -> Vector<K> {
        let keys: mut Vector<K>;
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            keys.PushBack(this.vector[i].left);
            i += 1u64;
        } ret keys;
    }

    pub Values(this: Map<K, V>&) -> Vector<V> {
        let values: mut Vector<V>;
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            values.PushBack(this.vector[i].right);
            i += 1u64;
        } ret values;
    }

    pub Has(this: Map<K, V>&, key: K) -> bool {
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            let pair: Pair<K, V>& = this.vector[i];
            if pair.left == key { ret true; }
            i += 1u64;
        } ret false;
    }

    pub op=(this: mut Map<K, V>&, other: Map<K, V>&) -> Map<K, V>& {
        this.vector = other.vector;
        ret this;
    }

    pub op[](this: mut Map<K, V>&, key: K) -> mut V& {
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            let pair: Pair<K, V>& = this.vector[i];
            if pair.left == key { ret pair.right; }
            i += 1u64;
        }

        this.vector.PushBack(Pair<K, V>(key));
        ret this.vector[i].right;
    }

    pub op[](this: Map<K, V>&, index: u64) -> Pair<K, V>& {
        ret this.vector[index];
    }
};