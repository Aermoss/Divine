include "divio", "divstr", "divvec", "divpair", "divptr", "divllvm", "lexer.div", "parser.div" : *;

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right { ret true; }
    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMElementTypeOf(value: LLVMValueRef) -> LLVMTypeRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMAlloca {
        ret LLVMGetAllocatedType(value);
    } else {
        ret LLVMGetElementType(LLVMTypeOf(value));
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

class QualifiedType {
    priv value: LLVMTypeRef,
    priv mutable: bool, priv signed: bool,
    priv pointee: QualifiedType* = null
} impl {
    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, signed: bool, pointee: QualifiedType*) {
        (this.value, this.mutable, this.signed, this.pointee) = (value, mutable, signed, pointee);
    }

    ~QualifiedType(this: QualifiedType&) {}

    pub Value(this: QualifiedType&) -> LLVMTypeRef {
        if this.value == null {
            printf("Null type value!\n");
            exit(1i32);
        }

        ret this.value;
    }

    pub IsMutable(this: QualifiedType&) -> bool { ret this.mutable; }
    pub IsSigned(this: QualifiedType&) -> bool { ret this.signed; }
    pub IsPointer(this: QualifiedType&) -> bool { ret this.pointee != null; }

    pub Pointee(this: QualifiedType&) -> QualifiedType& {
        if this.pointee == null {
            printf("Null pointee!\n");
            exit(1i32);
        }

        ret this.pointee;
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        if this.pointee != null && other.pointee != null {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && (*this.pointee) == (*other.pointee);
        } else {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && this.pointee == other.pointee;
        }
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }
};

class TypeManager {
    priv types: Vector<QualifiedType*>
} impl {
    TypeManager(this: TypeManager&) {}

    ~TypeManager(mut this: TypeManager&) {
        printf("Disposing %llu types...\n", this.types.Size());
        let mut i: u64 = 0u64;

        while i < this.types.Size() {
            del this.types[i];
            i += 1u64;
        }

        this.types.Clear();
    }

    pub New(mut this: TypeManager&, value: LLVMTypeRef, mutable: bool, signed: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, mutable, signed, null);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Pointer(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, pointee->IsSigned(), pointee);
        this.types.PushBack(_type);
        ret _type;
    }
};

class QualifiedValue {
    priv value: LLVMValueRef,
    priv _type: QualifiedType*
} impl {
    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*) {
        (this.value, this._type) = (value, _type);
    }

    ~QualifiedValue(this: QualifiedValue&) {}

    pub Value(this: QualifiedValue&) -> LLVMValueRef {
        if this._type == null {
            printf("Null value!\n");
            exit(1i32);
        }

        ret this.value;
    }

    pub Type(this: QualifiedValue&) -> QualifiedType& {
        if this._type == null {
            printf("Null type!\n");
            exit(1i32);
        }

        ret this._type;
    }

    pub op==(this: QualifiedValue&, other: QualifiedValue&) -> bool {
        ret this.value == other.value && this._type == other._type;
    }

    pub op!=(this: QualifiedValue&, other: QualifiedValue&) -> bool {
        ret !this.op==(other);
    }
};

enum SymbolKind {
    Variable, Function, Parameter
};

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: QualifiedValue
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub name: String
} impl {
    Scope(mut this: Scope&, parent: Scope*, name: String, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(this: Scope&, name: String) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(mut this: Scope&, name: String, kind: SymbolKind, value: QualifiedValue) {
        if this.Has(name) {
            this.Error("Symbol already exists.");
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value);
            this.symbols.PushBack(symbol);
        }
    }

    pub Get(this: Scope&, name: String) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(this: Scope&, string: i8*) {
        printf("Scope error: %s\n", string);
        exit(1i32);
    }
};

class ScopeManager {
    pub scopes: Vector<Scope*>,
    pub current: Scope* = null
} impl {
    ScopeManager(mut this: ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(mut this: ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(mut this: ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(mut this: ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub Has(this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret true; }
            scope = scope->parent;
        } ret false;
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, value: QualifiedValue) {
        this.current->Set(name, kind, value);
    }

    pub Get(this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret scope->Get(name); }
            scope = scope->parent;
        } ret null;
    }

    priv Error(this: ScopeManager&, string: i8*) {
        printf("Scope manager error: %s\n", string);
        exit(1i32);
    }
};

class Compiler {
    priv type_manager: TypeManager,
    priv scope_manager: ScopeManager,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv function: LLVMValueRef = null,
    priv number: u64
} impl {
    Compiler(mut this: Compiler&) {
        this.context = LLVMContextCreate();
    }

    ~Compiler(mut this: Compiler&) {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        if this.context != null {
            LLVMContextDispose(this.context);
            this.context = null;
        }
    }

    pub GetUniqueName(mut this: Compiler&) -> String {
        let buffer[256]: i8;
        sprintf(buffer, "%llu", this.number);
        this.number += 1u64;
        ret String(".") + buffer;
    }

    pub Forget(mut this: Compiler&) {
        this.module = null;
    }

    pub Compile(mut this: Compiler&, ast: RootNode*) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        LLVMSetSourceFileName(this.module, "hello.div", 9u64);
        LLVMSetTarget(this.module, LLVMGetDefaultTargetTriple());
        this.builder = LLVMCreateBuilderInContext(this.context);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        ret this.module;
    }

    priv CompileDeclaration(mut this: Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else {
            this.Error((String("Unknown declaration: ") + ASTNodeTypeToString(decl->node_type) + ".").Data());
        }
    }

    priv CompileExtern(mut this: Compiler&, extern_block: ExternBlockNode*) {
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }
    }

    priv CompileFunction(mut this: Compiler&, func_decl: FunctionDeclNode*) {
        this.number = 0u64;
        let func_name: i8* = func_decl->name.Data();
        let mut param_types: Vector<LLVMTypeRef>;
        let mut i: u64 = 0u64;

        while i < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[i];
            param_types.PushBack(this.CompileType(param->param_type).Value());
            i += 1u64;
        }

        let return_type: LLVMTypeRef = this.CompileType(func_decl->return_type).Value();
        let func_type: LLVMTypeRef = LLVMFunctionType(return_type, param_types.Data(), param_types.Size() as u32, func_decl->var_arg ? 1i32 : 0i32);
        this.function = LLVMAddFunction(this.module, func_name, func_type);
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, QualifiedValue(this.function, this.type_manager.New(func_type, false, false)));
        let mut j: u64 = 0u64;

        while j < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[j];
            let name: String = this.GetUniqueName().Data();
            LLVMSetValueName2(LLVMGetParam(this.function, j as u32), name.Data(), name.Size() - 1u64);
            j += 1u64;
        }

        if func_decl->body != null {
            this.scope_manager.PushScope(func_decl->name, false);
            let mut k: u64 = 0u64;

            while k < func_decl->parameters.Size() {
                let param: ParameterNode* = func_decl->parameters[k];
                this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(LLVMGetParam(this.function, k as u32), this.type_manager.New(param_types[k], false, false)));
                k += 1u64;
            }

            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            LLVMPositionBuilderAtEnd(this.builder, entry);
            this.CompileBlock(func_decl->body);
            this.scope_manager.PopScope();
        } this.function = null;
    }

    priv CompileBlock(mut this: Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(mut this: Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            let ret_stmt: ReturnStmtNode* = stmt as ReturnStmtNode*;
            LLVMBuildRet(this.builder, this.CompileExpression(ret_stmt->value).Value());
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement: ") + ASTNodeTypeToString(stmt->node_type) + ".").Data());
        }
    }

    priv CompileIf(mut this: Compiler&, if_stmt: IfStmtNode*) {
        if this.function == null {
            this.Error("If statement outside of function.");
            ret;
        }

        let mut current: IfStmtNode* = if_stmt;
        let mut end_block: LLVMBasicBlockRef = null;

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement: ") + ASTNodeTypeToString(else_stmt->node_type) + ".").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;
            let mut else_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } then_block = end_block;
            }

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } else_block = end_block;
            }

            let condition: QualifiedValue = this.CompileExpression(current->condition);
            LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(mut this: Compiler&, while_stmt: WhileStmtNode*) {
        if this.function == null {
            this.Error("While statement outside of function.");
            ret;
        }

        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));

        LLVMBuildBr(this.builder, compare_block);
        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: QualifiedValue = this.CompileExpression(while_stmt->condition);
        LLVMBuildCondBr(this.builder, condition.Value(), loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->body as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(mut this: Compiler&, variable: VariableDeclNode*) {
        let initializer: QualifiedValue = this.CompileExpression(variable->initializer);
        let _type: QualifiedType& = this.CompileType(variable->var_type);

        if initializer.Type() != _type {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
            ret;
        }

        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
        let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, _type.Value(), this.GetUniqueName().Data());

        LLVMPositionBuilderAtEnd(this.builder, current);
        this.scope_manager.Set(variable->name, SymbolKind::Variable, QualifiedValue(pointer, this.type_manager.Pointer(initializer.Type(), variable->is_mutable)));
        LLVMBuildStore(this.builder, initializer.Value(), pointer);
    }

    priv CompileAssignment(mut this: Compiler&, assignment: AssignmentNode*) -> QualifiedValue {
        let pointer: QualifiedValue = this.CompilePointerExpression(assignment->left);
        let value: QualifiedValue = this.CompileExpression(assignment->right);

        if !pointer.Type().IsMutable() {
            this.Error("Cannot assign to immutable variable.");
            ret QualifiedValue(null, null);
        }

        let mut value_ref: LLVMValueRef = pointer.Value();

        if value.Type() != pointer.Type().Pointee() {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(pointer.Type().Pointee().Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        /* if value.Type() != pointer.Type() {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(pointer.Type().Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        if LLVMIsAInstruction(pointer.Value()) != null && LLVMGetInstructionOpcode(pointer.Value()) == LLVMOpcode::LLVMLoad {
            value_ref = LLVMGetOperand(pointer.Value(), 0u32);
            LLVMInstructionEraseFromParent(pointer.Value());
        } else {
            this.Error("Expected a pointer type.");
            ret QualifiedValue(null, null);
        } */

        LLVMBuildStore(this.builder, value.Value(), value_ref);
        ret value;
    }

    priv CompilePointerExpression(mut this: Compiler&, expr: ASTNode*) -> QualifiedValue {
        if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret QualifiedValue(null, null);
            }

            ret this.scope_manager.Get(identifier->name)->value;
        } else if expr->node_type == ASTNodeType::CAST {
            let value: QualifiedValue = this.CompileCast(expr as CastNode*);

            if value.Type().IsPointer() {
                ret value;
            } else {
                this.Error("Expected a pointer type.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompilePointerUnaryOperation(expr as UnaryOpNode*);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            ret this.CompilePointerBinaryOperation(expr as BinaryOpNode*);
        } else {
            this.Error((String("Unknown pointer expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompilePointerUnaryOperation(mut this: Compiler&, unary_op: UnaryOpNode*) -> QualifiedValue {
        let value: QualifiedValue = this.CompilePointerExpression(unary_op->operand);

        if unary_op->operator == TokenType::BITWISE_AND {
            ret value;
        } else if unary_op->operator == TokenType::MUL {
            if value.Type().IsPointer() {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), this.GetUniqueName().Data()), value.Type().Pointee());
            } else {
                this.Error((String("Cannot dereference non-pointer type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid pointer unary operation '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompilePointerBinaryOperation(mut this: Compiler&, binary_op: BinaryOpNode*) -> QualifiedValue {
        let (left: QualifiedValue, right: QualifiedValue) = (this.CompileExpression(binary_op->left), this.CompileExpression(binary_op->right));
        let (left_kind: LLVMTypeKind, right_kind: LLVMTypeKind) = (LLVMGetTypeKind(left.Type().Value()), LLVMGetTypeKind(right.Type().Value()));

        if left.Type().IsPointer() && right.Type().IsPointer() {
            if binary_op->operator == TokenType::MINUS {
                let left_int: LLVMValueRef = LLVMBuildPtrToInt(this.builder, left.Value(), LLVMInt64TypeInContext(this.context), this.GetUniqueName().Data());
                let right_int: LLVMValueRef = LLVMBuildPtrToInt(this.builder, right.Value(), LLVMInt64TypeInContext(this.context), this.GetUniqueName().Data());
                ret QualifiedValue(LLVMBuildSub(this.builder, left_int, right_int, this.GetUniqueName().Data()), this.type_manager.New(LLVMInt64TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else {
                this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left.Type().IsPointer() && right_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right.Type().IsPointer()) {
            let ptr: QualifiedValue = left.Type().IsPointer() ? left : right;
            let index: QualifiedValue = left.Type().IsPointer() ? right : left;
            let width: u32 = LLVMGetIntTypeWidth(index.Value());

            if width == 64u32 {
                if binary_op->operator == TokenType::PLUS {
                    let indices[]: LLVMValueRef = { index.Value() };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, this.GetUniqueName().Data()), ptr.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), this.GetUniqueName().Data()) };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, this.GetUniqueName().Data()), ptr.Type());
                } else {
                    this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for pointer binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileExpression(mut this: Compiler&, expr: ASTNode*) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            ret this.CompileLiteral(expr as LiteralNode*);
        } else if expr->node_type == ASTNodeType::CALL {
            ret this.CompileCall(expr as CallNode*);
        } else if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret QualifiedValue(null, null);
            }

            let symbol: Symbol* = this.scope_manager.Get(identifier->name);

            if symbol->kind == SymbolKind::Variable {
                let _type: QualifiedType& = symbol->value.Type().Pointee();
                ret QualifiedValue(LLVMBuildLoad2(this.builder, _type.Value(), symbol->value.Value(), this.GetUniqueName().Data()), _type);
            } else if symbol->kind == SymbolKind::Function || symbol->kind == SymbolKind::Parameter {
                ret symbol->value;
            } else {
                this.Error("Unknown symbol kind.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CAST {
            ret this.CompileCast(expr as CastNode*);
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompileUnaryOperation(expr as UnaryOpNode*);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            ret this.CompileBinaryOperation(expr as BinaryOpNode*);
        } else {
            this.Error((String("Unknown expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileLiteral(mut this: Compiler&, literal: LiteralNode*) -> QualifiedValue {
        if literal->literal_type == TokenType::INTEGER {
            let (mut state: bool, mut i: u64) = (false, 0u64);
            let (mut signed: bool, mut width: u64) = (true, 32u64);
            let (mut value: String, mut size: String);

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == 'u' {
                        (signed, state) = (false, true);
                    } else if literal->value[i] == 'i' {
                        (signed, state) = (true, true);
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 128u64 {
                _type = LLVMInt128TypeInContext(this.context);
            } else if width == 64u64 {
                _type = LLVMInt64TypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMInt32TypeInContext(this.context);
            } else if width == 16u64 {
                _type = LLVMInt16TypeInContext(this.context);
            } else if width == 8u64 {
                _type = LLVMInt8TypeInContext(this.context);
            } else {
                this.Error("Invalid integer size.");
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstInt(_type, value.ToInteger() as u64, 1i32), this.type_manager.New(_type, false, signed));
        } else if literal->literal_type == TokenType::FLOAT {
            let (mut state: bool, mut i: u64) = (false, 0u64);
            let (mut value: String, mut size: String);
            let mut width: u64 = 32u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == 'f' {
                        state = true;
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 64u64 {
                _type = LLVMDoubleTypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMFloatTypeInContext(this.context);
            } else {
                this.Error("Invalid float size.");
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstReal(_type, value.ToFloat()), this.type_manager.New(_type, false, false));
        } else if literal->literal_type == TokenType::STRING {
            let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "fmt");
            ret QualifiedValue(value, this.type_manager.New(LLVMTypeOf(value), false, false));
        } else {
            this.Error((String("Unknown literal type: ") + TokenTypeToString(literal->literal_type) + ".").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileCall(mut this: Compiler&, call: CallNode*) -> QualifiedValue {
        let mut args: Vector<LLVMValueRef>;
        let mut i: u64 = 0u64;

        while i < call->arguments.Size() {
            let arg: ASTNode* = call->arguments[i];
            args.PushBack(this.CompileExpression(arg).Value());
            i += 1u64;
        }

        let _func: QualifiedValue = this.CompileExpression(call->function);
        let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.Type().Value(), _func.Value(), args.Data(), args.Size() as u32, this.GetUniqueName().Data());
        ret QualifiedValue(value, this.type_manager.New(LLVMGetReturnType(_func.Type().Value()), false, false));
    }

    priv CompileCast(mut this: Compiler&, cast: CastNode*) -> QualifiedValue {
        let value: QualifiedValue = this.CompileExpression(cast->expression);
        let value_kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());
        let target: QualifiedType& = this.CompileType(cast->target_type);
        let target_kind: LLVMTypeKind = LLVMGetTypeKind(target.Value());

        if value.Type() == target {
            this.Error((String("Redundant cast. ('") + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "')").Data());
            ret QualifiedValue(null, null);
        }

        if value.Type().IsPointer() && target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            ret QualifiedValue(LLVMBuildPtrToInt(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
        } else if value_kind == LLVMTypeKind::LLVMFloatTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                ret QualifiedValue(LLVMBuildFPExt(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMDoubleTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                }
            }
            
            if target_kind == LLVMTypeKind::LLVMFloatTypeKind {
                ret QualifiedValue(LLVMBuildFPTrunc(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if target.IsPointer() {
                ret QualifiedValue(LLVMBuildIntToPtr(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
            }

            if target_kind == LLVMTypeKind::LLVMFloatTypeKind || target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if value.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSIToFP(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                } else {
                    ret QualifiedValue(LLVMBuildUIToFP(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                let value_width: u32 = LLVMGetIntTypeWidth(value.Type().Value());
                let target_width: u32 = LLVMGetIntTypeWidth(target.Value());

                if target_width > value_width {
                    if value.Type().IsSigned() {
                        ret QualifiedValue(LLVMBuildSExt(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                    } else {
                        ret QualifiedValue(LLVMBuildZExt(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                    }
                } else if target_width < value_width {
                    ret QualifiedValue(LLVMBuildTrunc(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
                } else {
                    ret QualifiedValue(value.Value(), target);
                }
            }
        }

        if value.Type().IsPointer() && target.IsPointer() {
            ret QualifiedValue(LLVMBuildBitCast(this.builder, value.Value(), target.Value(), this.GetUniqueName().Data()), target);
        } else {
            this.Error(String("Cannot cast '" + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileUnaryOperation(mut this: Compiler&, unary_op: UnaryOpNode*) -> QualifiedValue {
        if unary_op->operator == TokenType::BITWISE_AND {
            ret this.CompilePointerExpression(unary_op->operand);
        } else {
            let value: QualifiedValue = this.CompileExpression(unary_op->operand);
            let kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

            if unary_op->operator == TokenType::MUL {
                if value.Type().IsPointer() {
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), this.GetUniqueName().Data()), value.Type().Pointee());
                } else {
                    this.Error((String("Cannot dereference non-pointer type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::MINUS {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type().IsSigned() {
                        ret QualifiedValue(LLVMBuildNeg(this.builder, value.Value(), this.GetUniqueName().Data()), value.Type());
                    } else {
                        this.Error((String("Cannot negate unsigned type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                    ret QualifiedValue(LLVMBuildFNeg(this.builder, value.Value(), this.GetUniqueName().Data()), value.Type());
                } else {
                    this.Error((String("Cannot negate type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::NOT {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    ret QualifiedValue(LLVMBuildNot(this.builder, value.Value(), this.GetUniqueName().Data()), value.Type());
                } else {
                    this.Error((String("Cannot invert type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid unary operation '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }
    }

    priv CompileBinaryOperation(mut this: Compiler&, binary_op: BinaryOpNode*) -> QualifiedValue {
        let left: QualifiedValue = this.CompileExpression(binary_op->left);
        let right: QualifiedValue = this.CompileExpression(binary_op->right);
        let kind: LLVMTypeKind = LLVMGetTypeKind(left.Type().Value());

        if left.Type() != right.Type() {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        if kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildAdd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildSub(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildMul(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSDiv(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildUDiv(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                }
            } else if binary_op->operator == TokenType::MOD {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSRem(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildURem(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                }
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGT : LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGE : LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLT : LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLE : LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::AND || binary_op->operator == TokenType::BITWISE_AND {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::AND {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildAnd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                }
            } else if binary_op->operator == TokenType::OR || binary_op->operator == TokenType::BITWISE_OR {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::OR {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildOr(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                }
            } else if binary_op->operator == TokenType::BITWISE_XOR {
                ret QualifiedValue(LLVMBuildXor(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::LSHIFT {
                ret QualifiedValue(LLVMBuildShl(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::RSHIFT {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildAShr(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildLShr(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                }
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildFAdd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildFSub(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildFMul(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                ret QualifiedValue(LLVMBuildFDiv(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::MOD {
                ret QualifiedValue(LLVMBuildFRem(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.Value(), right.Value(), this.GetUniqueName().Data()), this.type_manager.New(LLVMInt1TypeInContext(this.context), false, false));
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileType(mut this: Compiler&, type_node: ASTNode*) -> QualifiedType& {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->type_name == "i8" || primitive_type->type_name == "u8" {
                ret this.type_manager.New(LLVMInt8TypeInContext(this.context), primitive_type->mutable, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i16" || primitive_type->type_name == "u16" {
                ret this.type_manager.New(LLVMInt16TypeInContext(this.context), primitive_type->mutable, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i32" || primitive_type->type_name == "u32" || primitive_type->type_name == "char" {
                ret this.type_manager.New(LLVMInt32TypeInContext(this.context), primitive_type->mutable, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i64" || primitive_type->type_name == "u64" {
                ret this.type_manager.New(LLVMInt64TypeInContext(this.context), primitive_type->mutable, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i128" || primitive_type->type_name == "u128" {
                ret this.type_manager.New(LLVMInt128TypeInContext(this.context), primitive_type->mutable, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "f32" {
                ret this.type_manager.New(LLVMFloatTypeInContext(this.context), primitive_type->mutable, false);
            } else if primitive_type->type_name == "f64" {
                ret this.type_manager.New(LLVMDoubleTypeInContext(this.context), primitive_type->mutable, false);
            } else if primitive_type->type_name == "void" {
                ret this.type_manager.New(LLVMVoidTypeInContext(this.context), primitive_type->mutable, false);
            } else {
                this.Error("Unknown primitive type.");
                ret null;
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(pointer_type->base_type), pointer_type->mutable);
        } else {
            this.Error("Unknown type.");
            ret null;
        }
    }

    priv Error(this: Compiler&, string: i8*) {
        printf("Compiler error: %s\n", string);
        exit(1i32);
    }
};