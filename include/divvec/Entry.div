/*
 * Copyright 2025 Yusuf Ren√ßber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divmem" : *;

class Vector<T> {
    priv data: mut T* = null,
    priv capacity: u64 = 0u64,
    priv size: u64 = 0u64
} impl {
    Vector(this: mut Vector<T>&) {}

    Vector(this: mut Vector<T>&, other: Vector<T>&) {
        if other.data == null { ret; }
        this.Allocate(other.capacity);

        while this.size < other.size {
            this.data[this.size] = other.data[this.size];
            this.size += 1u64;
        }
    }

    ~Vector(this: mut Vector<T>&) {
        this.Release();
    }

    pub Data(this: Vector<T>&) -> T* { ret this.data; }
    pub Size(this: Vector<T>&) -> u64 { ret this.size; }

    priv Allocate(this: mut Vector<T>&, capacity: u64) {
        (this.data, this.capacity) = (new T[capacity], capacity);
    }

    priv Release(this: mut Vector<T>&) {
        if this.data != null { del[] this.data; }
        (this.data, this.capacity, this.size) = (null, 0u64, 0u64);
    }

    pub PushBack(this: mut Vector<T>&, value: T) {
        if this.capacity < this.size + 1u64 {
            let temp: T* = this.data;
            this.Allocate(this.capacity != 0u64 ? this.capacity * 2u64 : 1u64);

            if temp != null {
                let mut i: u64 = 0u64;

                while i < this.size {
                    this.data[i] = temp[i];
                    i += 1u64;
                }

                del[] temp;
            }
        }

        this.data[this.size] = value;
        this.size += 1u64;
    }

    pub PopBack(this: mut Vector<T>&) -> T {
        this.size -= 1u64;
        ret this.data[this.size];
    }

    pub Pop(this: mut Vector<T>&, index: u64) -> T {
        let mut i: u64 = index + 1u64;

        while i < this.size {
            this.data[i - 1u64] = this.data[i];
            i += 1u64;
        }

        this.size -= 1u64;
        ret this.data[index];
    }

    pub Clear(this: mut Vector<T>&) {
        this.Release();
    }

    pub Remove(this: mut Vector<T>&, value: T) {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this.data[i] == value {
                this.Pop(i);
                i -= 1u64;
            } i += 1u64;
        }
    }

    pub Index(this: Vector<T>&, value: T) -> i64 {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this.data[i] == value {
                ret i as i64;
            } i += 1u64;
        } ret -1i64;
    }

    pub op=(this: mut Vector<T>&, other: Vector<T>&) -> Vector<T>& {
        this.Release();
        if other.data == null { ret this; }
        this.Allocate(other.capacity);

        while this.size < other.size {
            this.data[this.size] = other.data[this.size];
            this.size += 1u64;
        } ret this;
    }

    pub op[](this: Vector<T>&, index: u64) -> mut T& {
        ret this.data[index];
    }
};