include "divmem" : *;

class Vector<T> {
    priv data: T* = null,
    priv size: i64 = 0i64
} impl {
    Vector(mut this: Vector<T>&) {}

    Vector(mut this: Vector<T>&, other: Vector<T>&) {
        if other.Data() == null { ret; }
        this.Allocate(other.Size());
        let mut i: i64 = 0i64;

        while i < this.size {
            this.data[i] = other.data[i];
            i += 1i64;
        }
    }

    ~Vector(mut this: Vector<T>&) {
        this.Release();
    }

    pub Data(this: Vector<T>&) -> T* { ret this.data; }
    pub Size(this: Vector<T>&) -> i64 { ret this.size; }

    pub Allocate(mut this: Vector<T>&, newSize: i64) {
        (this.data, this.size) = (new T[newSize], newSize);
    }

    pub Release(mut this: Vector<T>&) {
        if this.data != null { del[] this.data; }
        (this.data, this.size) = (null, 0i64);
    }

    pub PushBack(mut this: Vector<T>&, value: T) {
        let temp: T* = this.data;
        this.Allocate(this.size + 1i64);

        if temp != null {
            let mut i: i64 = 0i64;

            while i < this.size - 1i64 {
                this.data[i] = temp[i];
                i += 1i64;
            }

            del[] temp;
        }

        this.data[this.size - 1i64] = value;
    }

    pub PopBack(mut this: Vector<T>&) -> T {
        let temp: T* = this.data;
        this.Allocate(this.size - 1i64);
        let value: T = temp[this.size];

        if temp != null {
            let mut i: i64 = 0i64;

            while i < this.size {
                this.data[i] = temp[i];
                i += 1i64;
            }

            del[] temp;
        }

        ret value;
    }

    pub Pop(mut this: Vector<T>&, index: i64) -> T {
        let temp: T* = this.data;
        this.Allocate(this.size - 1i64);
        let value: T = temp[index];

        if temp != null {
            let mut i: i64 = 0i64;

            while i < index {
                this.data[i] = temp[i];
                i += 1i64;
            }

            i += 1i64;

            while i < this.size + 1i64 {
                this.data[i - 1i64] = temp[i];
                i += 1i64;
            }

            del[] temp;
        }

        ret value;
    }

    pub op=(mut this: Vector<T>&, other: Vector<T>&) -> Vector<T>& {
        this.Release();
        if other.data == null { ret *this; }
        this.Allocate(other.size);
        let mut i: i64 = 0i64;

        while i < this.size {
            this.data[i] = other.data[i];
            i += 1i64;
        }

        ret *this;
    }

    pub op[](this: Vector<T>&, index: i64) -> T& {
        ret this.data[index];
    }
};