/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divmem" : *;

extern "C" {
    func strlen(str: *const i8) -> u64;
    func strcmp(str1: *const i8, str2: *const i8) -> i32;

    func strtof(str: *const i8, endptr: *const *const i8) -> f32;
    func strtod(str: *const i8, endptr: *const *const i8) -> f64;

    func strtol(str: *const i8, endptr: *const *const i8, base: i32) -> i32;
    func strtoul(str: *const i8, endptr: *const *const i8, base: i32) -> u32;

    func strtoll(str: *const i8, endptr: *const *const i8, base: i32) -> i64;
    func strtoull(str: *const i8, endptr: *const *const i8, base: i32) -> u64;
}

class String {
    priv data: *mut i8 = null,
    priv size: u64 = 0u64
} impl {
    String(this: &mut String) {
        this.Allocate(1u64);
        this.data[0u64] = '\0';
    }

    String(this: &mut String, other: &String) {
        this.String(other.data);
    }

    String(this: &mut String, string: *const i8) {
        if string == null { ret; }
        this.Allocate(strlen(string) + 1u64);
        memcpy(this.data, string, this.size);
    }

    ~String(this: &mut String) {
        this.Release();
    }

    pub Data(this: &String) -> *mut i8 { ret this.data; }
    pub Size(this: &String) -> u64 { ret this.size; }

    priv Allocate(this: &mut String, newSize: u64) {
        (this.data, this.size) = (malloc(newSize) as *mut i8, newSize);
    }

    priv Release(this: &mut String) {
        if this.data != null { free(this.data); }
        (this.data, this.size) = (null, 0u64);
    }

    pub ToInteger(this: &String) -> i64 { ret strtoll(this.data, null, 10i32); }
    pub ToInteger(this: &String, base: i32) -> i64 { ret strtoll(this.data, null, base); }
    pub ToFloat(this: &String) -> f64 { ret strtod(this.data, null); }

    pub Escape(this: &String) -> String {
        let mut result: String;
        let mut i: u64 = 0u64;

        while i < this.size - 1u64 {
            if this.data[i] == '\n' {
                result += "\\n";
            } else if this.data[i] == '\t' {
                result += "\\t";
            } else if this.data[i] == '\r' {
                result += "\\r";
            } else if this.data[i] == '\a' {
                result += "\\a";
            } else if this.data[i] == '\b' {
                result += "\\b";
            } else if this.data[i] == '\f' {
                result += "\\f";
            } else if this.data[i] == '\v' {
                result += "\\v";
            } else if this.data[i] == '\\' {
                result += "\\\\";
            } else if this.data[i] == '\"' {
                result += "\\\"";
            } else if this.data[i] == '\'' {
                result += "\\\'";
            } else {
                result += this.data[i];
            } i += 1u64;
        } ret result;
    }

    pub Replace(this: &String, from: &String, to: &String) -> String {
        ret this.Replace(from.data, to.data);
    }

    pub Replace(this: &String, from: *const i8, to: *const i8) -> String {
        let mut result: String;
        let size: u64 = strlen(from);
        let mut i: u64 = 0u64;

        if size == 0u64 {
            result = this;
            ret result;
        }

        while i < this.size - 1u64 {
            let mut match: bool = true;
            let mut j: u64 = 0u64;

            while j < size {
                if i + j >= this.size - 1u64 || this.data[i + j] != from[j] {
                    match = false;
                    break;
                } else {
                    j += 1u64;
                }
            }

            if match {
                result += to;
                i += size;
            } else {
                result += this.data[i];
                i += 1u64;
            }
        } ret result;
    }

    pub op=(this: &mut String, other: &String) -> &String {
        ret this.op=(other.data);
    }

    pub op=(this: &mut String, string: *const i8) -> &String {
        if string == null { ret this; }
        if this.data != null { free(this.data); }
        this.Allocate(strlen(string) + 1u64);
        memcpy(this.data, string, this.size);
        ret this;
    }

    pub op=(this: &mut String, character: i8) -> &String {
        if this.data != null { free(this.data); }
        this.Allocate(2u64);
        this.data[0u64] = character;
        this.data[1u64] = '\0';
        ret this;
    }

    pub op+=(this: &mut String, other: &String) -> &String {
        ret this.op+=(other.data);
    }

    pub op+=(this: &mut String, string: *const i8) -> &String {
        if string == null { ret this; }
        let (oldData: *const i8, oldSize: u64) = (this.data, strlen(this.data));
        this.Allocate(oldSize + strlen(string) + 1u64);

        if oldData != null {
            memcpy(this.data, oldData, oldSize);
            free(oldData);
        }

        memcpy((this.data + oldSize), string, strlen(string) + 1u64);
        ret this;
    }

    pub op+=(this: &mut String, character: i8) -> &String {
        let (oldData: *const i8, oldSize: u64) = (this.data, strlen(this.data));
        this.Allocate(oldSize + 2u64);

        if oldData != null {
            memcpy(this.data, oldData, oldSize);
            free(oldData);
        }

        this.data[oldSize] = character;
        this.data[oldSize + 1u64] = '\0';
        ret this;
    }

    pub op+(this: &String, other: &String) -> String {
        ret this.op+(other.data);
    }

    pub op+(this: &String, string: *const i8) -> String {
        let mut result: String = this.data;
        result += string;
        ret result;
    }

    pub op+(this: &String, character: i8) -> String {
        let mut result: String = this.data;
        result += character;
        ret result;
    }

    pub op*=(this: &mut String, count: u64) -> &String {
        if count <= 0u64 {
            this.Release();
            this.Allocate(1u64);
            this.data[0u64] = '\0';
            ret this;
        } else {
            let temp: String = this.data;
            let mut i: u64 = 0u64;

            while i < count - 1u64 {
                this.op+=(temp.data);
                i += 1u64;
            } ret this;
        }
    }

    pub op*(this: &String, count: u64) -> String {
        let mut result: String = this.data;
        result *= count;
        ret result;
    }

    pub op==(this: &String, other: &String) -> bool {
        ret this.op==(other.data);
    }

    pub op==(this: &String, string: *const i8) -> bool {
        if this.size - 1u64 != strlen(string) { ret false; }
        if this.data == null || string == null { ret false; }
        ret strcmp(this.data, string) == 0i32;
    }

    pub op==(this: &String, character: i8) -> bool {
        if this.size - 1u64 != 1u64 { ret false; }
        if this.data == null { ret false; }
        ret this.data[0u64] == character;
    }

    pub op!=(this: &String, other: &String) -> bool {
        ret !this.op==(other.data);
    }

    pub op!=(this: &String, string: *const i8) -> bool {
        ret !this.op==(string);
    }

    pub op!=(this: &String, character: i8) -> bool {
        ret !this.op==(character);
    }

    pub op[](this: &String, index: u64) -> &mut i8 {
        ret this.data[index];
    }
};