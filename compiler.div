include "divio", "divstr", "divvec", "divmap", "divpair", "divptr", "divwin", "divfile", "divllvm", "lexer.div", "parser.div" : *;

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right { ret true; }
    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMElementTypeOf(value: LLVMValueRef) -> LLVMTypeRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMAlloca {
        ret LLVMGetAllocatedType(value);
    } else {
        ret LLVMGetElementType(LLVMTypeOf(value));
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

func LLVMAddressOf(value: LLVMValueRef) -> LLVMValueRef {
    if LLVMIsAInstruction(value) != null && LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMLoad {
        let operand: LLVMValueRef = LLVMGetOperand(value, 0u32);
        LLVMInstructionEraseFromParent(value);
        ret operand;
    } else {
        printf("Failed to get address of.\n");
        exit(1i32);
        ret null;
    }
}

class QualifiedType {
    priv pointee: QualifiedType* = null, priv reference: bool = false,
    priv value: LLVMTypeRef, priv mutable: bool = false, priv signed: bool = false,
    priv fields: Map<String, QualifiedType*>, priv _class: bool = false,
    pub sret: QualifiedType* = null, pub byref: QualifiedType* = null,
    priv return: QualifiedType* = null, priv _function: bool = false,
    pub params: Vector<QualifiedType*>
} impl {
    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, signed: bool) {
        (this.value, this.signed) = (value, signed);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) {
        (this.value, this.params, this.return, this._function) = (value, params, return, true);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, fields: Map<String, QualifiedType*>) {
        (this.value, this.mutable, this.fields, this._class) = (value, mutable, fields, true);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, reference: bool, pointee: QualifiedType*) {
        (this.value, this.mutable, this.reference, this.pointee) = (value, mutable, reference, pointee);
    }

    ~QualifiedType(this: QualifiedType&) {}

    pub IsMutable(this: QualifiedType&) -> bool { ret this.mutable; }
    pub IsSigned(this: QualifiedType&) -> bool { ret this.signed; }
    pub IsPointer(this: QualifiedType&) -> bool { ret this.pointee != null; }
    pub IsReference(this: QualifiedType&) -> bool { ret this.reference; }
    pub IsPrimitive(this: QualifiedType&) -> bool { ret !this.IsPointer() && !this.IsClass(); }
    pub IsFunction(this: QualifiedType&) -> bool { ret this._function; }
    pub IsClass(this: QualifiedType&) -> bool { ret this._class; }

    pub Value(this: QualifiedType&) -> LLVMTypeRef {
        if this.value != null {
            ret this.value;
        } else {
            printf("Null type!\n");
            exit(1i32);
            ret null;
        }
    }

    pub Pointee(this: QualifiedType&) -> QualifiedType& {
        if this.pointee != null {
            ret this.pointee;
        } else {
            printf("Null pointee!\n");
            exit(1i32);
            ret null;
        }
    }

    pub Parameters(this: QualifiedType&) -> Vector<QualifiedType*> {
        if !this._function {
            printf("Not a function!\n");
            exit(1i32);
        } ret this.params;
    }

    pub Return(this: QualifiedType&) -> QualifiedType* {
        if this._function {
            ret this.return;
        } else {
            printf("Not a function!\n");
            exit(1i32);
            ret null;
        }
    }

    pub Fields(this: QualifiedType&) -> Map<String, QualifiedType*> {
        if !this._class {
            printf("Not a class!\n");
            exit(1i32);
        } ret this.fields;
    }

    pub Index(this: QualifiedType&, name: String) -> i64 {
        let mut i: u64 = 0u64;

        while i < this.fields.Size() {
            if this.fields.Data()[i].left == name {
                ret i as i64;
            } i += 1u64;
        } ret -1i64;
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        if this.pointee != null && other.pointee != null {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && (*this.pointee) == (*other.pointee);
        } else {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && this.pointee == other.pointee;
        }
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }

    priv Error(this: QualifiedType&, string: i8*) {
        printf("Qualified type error: %s\n", string);
        exit(1i32);
    }
};

class TypeManager {
    priv types: Vector<QualifiedType*>
} impl {
    TypeManager(this: TypeManager&) {}

    ~TypeManager(mut this: TypeManager&) {
        printf("Disposing %llu types...\n", this.types.Size());
        let mut i: u64 = 0u64;

        while i < this.types.Size() {
            del this.types[i];
            i += 1u64;
        }

        this.types.Clear();
    }

    pub Primitive(mut this: TypeManager&, value: LLVMTypeRef, signed: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, signed);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Function(mut this: TypeManager&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, params, return);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Class(mut this: TypeManager&, value: LLVMTypeRef, fields: Map<String, QualifiedType*>) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, false, fields);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Pointer(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, false, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Reference(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, true, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Copy(mut this: TypeManager&, _type: QualifiedType*, mutable: bool) -> QualifiedType* {
        if mutable != _type->IsMutable() {
            let mut copy: QualifiedType* = null;

            if _type->IsClass() {
                copy = new QualifiedType(_type->Value(), mutable, _type->Fields());
            } else if _type->IsPointer() {
                copy = new QualifiedType(_type->Value(), mutable, _type->IsReference(), _type->Pointee());
            } else {
                this.Error("Cannot copy primitive or function type.");
            }

            this.types.PushBack(copy);
            ret copy;
        } else {
            ret _type;
        }
    }

    priv Error(this: TypeManager&, string: i8*) {
        printf("Type manager error: %s\n", string);
        exit(1i32);
    }
};

class QualifiedValue {
    priv value: LLVMValueRef,
    priv _type: QualifiedType*
} impl {
    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*) {
        (this.value, this._type) = (value, _type);
    }

    ~QualifiedValue(this: QualifiedValue&) {}

    pub Value(this: QualifiedValue&) -> LLVMValueRef {
        if this.value != null {
            ret this.value;
        } else {
            this.Error("Null value!");
            ret null;
        }
    }

    pub Type(this: QualifiedValue&) -> QualifiedType& {
        if this._type != null {
            ret this._type;
        } else {
            this.Error("Null type!");
            ret null;
        }
    }

    priv Error(this: QualifiedValue&, string: i8*) {
        printf("Qualified value error: %s\n", string);
        exit(1i32);
    }
};

enum SymbolKind {
    Variable, Constant, Function, Parameter, Type
};

func SymbolKindToString(kind: SymbolKind) -> String {
    if kind == SymbolKind::Variable { ret { "Variable" } as String; }
    else if kind == SymbolKind::Constant { ret { "Constant" } as String; }
    else if kind == SymbolKind::Function { ret { "Function" } as String; }
    else if kind == SymbolKind::Parameter { ret { "Parameter" } as String; }
    else if kind == SymbolKind::Type { ret { "Type" } as String; }
    else { ret { "Unknown" } as String; }
}

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: QualifiedValue
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub name: String
} impl {
    Scope(mut this: Scope&, parent: Scope*, name: String, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(this: Scope&, name: String) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(mut this: Scope&, name: String, kind: SymbolKind, value: QualifiedValue) {
        if this.Has(name) {
            this.Error((String("Symbol '") + name + "' already exists.").Data());
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value);
            this.symbols.PushBack(symbol);
        }
    }

    pub Get(this: Scope&, name: String) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(this: Scope&, string: i8*) {
        printf("Scope error: %s\n", string);
        exit(1i32);
    }
};

class ScopeManager {
    pub scopes: Vector<Scope*>,
    pub current: Scope* = null
} impl {
    ScopeManager(mut this: ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(mut this: ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(mut this: ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(mut this: ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub Has(this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret true; }
            scope = scope->parent;
        } ret false;
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, value: QualifiedValue) {
        this.current->Set(name, kind, value);
    }

    pub Get(this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret scope->Get(name); }
            scope = scope->parent;
        } ret null;
    }

    pub ResolveChild(this: ScopeManager&, scope: Scope*, identifier: IdentifierNode*) -> Scope* {
        let mut i: u64 = 0u64;

        while i < scope->children.Size() {
            if scope->children[i]->name == identifier->name {
                ret scope->children[i];
            } else {
                i += 1u64;
            }
        }

        this.Error((String("Scope '") + identifier->name + "' not found.").Data());
        ret null;
    }

    pub ResolveScopeHalf(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        let mut scope: Scope* = this.current;

        while !scope->global {
            scope = scope->parent;
        }

        if resolution->scope != null {
            if resolution->scope->node_type == ASTNodeType::SCOPE_RESOLUTION {
                scope = this.ResolveScopeFull(resolution->scope as ScopeResolutionNode*);
            } else {
                scope = this.ResolveChild(scope, resolution->scope as IdentifierNode*);
            }
        } else {
            while scope->parent != null {
                scope = scope->parent;
            }
        } ret scope;
    }

    pub ResolveScopeFull(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        ret this.ResolveChild(this.ResolveScopeHalf(resolution), resolution->name as IdentifierNode*);
    }

    pub Resolve(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Symbol* {
        let identifier: IdentifierNode* = resolution->name as IdentifierNode*;
        let scope: Scope* = this.ResolveScopeHalf(resolution);

        if scope->Has(identifier->name) {
            ret scope->Get(identifier->name);
        } else {
            this.Error((String("Symbol '") + identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, identifier: IdentifierNode*) -> Symbol* {
        if this.Has(identifier->name) {
            ret this.Get(identifier->name);
        } else {
            this.Error((String("Symbol '") + identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, node: ASTNode*) -> Symbol* {
        if node->node_type == ASTNodeType::SCOPE_RESOLUTION {
            ret this.Resolve(node as ScopeResolutionNode*);
        } else if node->node_type == ASTNodeType::IDENTIFIER {
            ret this.Resolve(node as IdentifierNode*);
        } else {
            this.Error((String("Unknown resolution '") + ASTNodeTypeToString(node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: ScopeManager&, string: i8*) {
        printf("Scope manager error: %s\n", string);
        exit(1i32);
    }
};

class Compiler {
    priv type_manager: TypeManager,
    priv scope_manager: ScopeManager,
    pub include_paths: Vector<String>,
    priv included_paths: Vector<String>,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv forwards: Vector<Pair<FunctionDeclNode*, LLVMValueRef>>,
    pub target_machine: LLVMTargetMachineRef = null,
    priv layout: LLVMTargetDataRef = null,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv target: LLVMTargetRef = null,
    priv triple: i8* = null
} impl {
    Compiler(mut this: Compiler&) {
        LLVMInitializeNativeTarget();
        LLVMInitializeNativeAsmPrinter();
        // LLVMInitializeNativeAsmParser();
        // LLVMInitializeNativeDisassembler();
        this.triple = LLVMGetDefaultTargetTriple();
        this.context = LLVMContextCreate();
        let err: i8* = null;

        if LLVMGetTargetFromTriple(this.triple, &this.target, &err) != 0i32 {
            printf("Failed to get target from triple: %s.\n", err);
            LLVMDisposeMessage(err);
            ret;
        }

        LLVMDisposeMessage(err);
        this.target_machine = LLVMCreateTargetMachine(this.target, this.triple, "generic", "", LLVMCodeGenOptLevel::LLVMCodeGenLevelDefault, LLVMRelocMode::LLVMRelocDefault, LLVMCodeModel::LLVMCodeModelDefault);
        this.layout = LLVMCreateTargetDataLayout(this.target_machine);
    }

    ~Compiler(mut this: Compiler&) {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        LLVMDisposeTargetMachine(this.target_machine);
        LLVMContextDispose(this.context);
    }

    pub Forget(mut this: Compiler&) {
        this.module = null;
    }

    pub Compile(mut this: Compiler&, ast: RootNode*, file_name: String&) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        this.builder = LLVMCreateBuilderInContext(this.context);
        LLVMSetSourceFileName(this.module, file_name.Data(), file_name.Size() - 1u64);
        LLVMSetTarget(this.module, this.triple);
        let layout: i8* = LLVMCopyStringRepOfTargetData(this.layout);
        LLVMSetDataLayout(this.module, layout);
        LLVMDisposeMessage(layout);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        this.CompileForwardDeclarations();
        let err: i8* = null;

        if LLVMVerifyModule(this.module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0i32 {
            printf("Module verification failed: %s.\n", err);
            LLVMDisposeMessage(err);
            ret null;
        }

        LLVMDisposeMessage(err);
        ret this.module;
    }

    priv CompileForwardDeclarations(mut this: Compiler&) {
        let mut i: u64 = 0u64;

        while i < this.forwards.Size() {
            let func_decl: FunctionDeclNode* = this.forwards[i].left;
            let mut param_types: Vector<QualifiedType*>;
            let mut j: u64 = 0u64;

            while j < func_decl->_type->parameters.Size() {
                let param: ParameterNode* = func_decl->_type->parameters[j];
                param_types.PushBack(this.ProcessType(this.CompileType(param->param_type)));
                j += 1u64;
            }

            this.scope_manager.PushScope(func_decl->name, false);
            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.forwards[i].right, "");
            LLVMPositionBuilderAtEnd(this.builder, entry);
            let mut k: u64 = 0u64;

            while k < func_decl->_type->parameters.Size() {
                let param: ParameterNode* = func_decl->_type->parameters[k];

                if param->is_mutable {
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, param_types[k]->Value(), "");

                    LLVMPositionBuilderAtEnd(this.builder, current);
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(pointer, this.type_manager.Pointer(param_types[k], param->is_mutable)));
                    LLVMBuildStore(this.builder, LLVMGetParam(this.forwards[i].right, k as u32), pointer);
                } else {
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(LLVMGetParam(this.forwards[i].right, k as u32), param_types[k]));
                } k += 1u64;
            }

            this.CompileBlock(func_decl->body);
            this.scope_manager.PopScope();
            i += 1u64;
        }
    }

    priv CompileDeclaration(mut this: Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::INCLUDE_STMT {
            this.CompileInclude(decl as IncludeStmtNode*);
        } else if decl->node_type == ASTNodeType::CONSTANT_DECL {
            this.CompileConstant(decl as ConstantDeclNode*);
        } else if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::CLASS_DECL {
            this.CompileClass(decl as ClassDeclNode*);
        } else if decl->node_type == ASTNodeType::ENUM_DECL {
            this.CompileEnum(decl as EnumDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else if decl->node_type == ASTNodeType::TYPE_DECL {
            let type_decl: TypeDeclNode* = decl as TypeDeclNode*;
            this.scope_manager.Set(type_decl->name, SymbolKind::Type, QualifiedValue(null, this.CompileType(type_decl->_type)));
        } else {
            this.Error((String("Unknown declaration '") + ASTNodeTypeToString(decl->node_type) + "'.").Data());
        }
    }

    priv CompileInclude(mut this: Compiler&, include_stmt: IncludeStmtNode*) {
        let mut i: u64 = 0u64;

        while i < include_stmt->modules.Size() {
            let (mut found: bool, mut j: u64) = (false, 0u64);
            let module: String = include_stmt->modules[i];

            while j < this.include_paths.Size() {
                let mut path: String = this.include_paths[j] + "\\" + include_stmt->modules[i];
                let attr: DWORD = GetFileAttributesA(path.Data());
                j += 1u64;

                if attr == INVALID_FILE_ATTRIBUTES {
                    continue;
                }

                if (attr & FILE_ATTRIBUTE_DIRECTORY) != 0u32{
                    path += "\\Entry.div";

                    if GetFileAttributesA(path.Data()) == INVALID_FILE_ATTRIBUTES {
                        this.Error("Module entry point not found.");
                        ret;
                    }
                }

                if this.included_paths.Index(path) != -1i64 {
                    found = true;
                    break;
                }

                let (mut lexer: Lexer, mut parser: Parser);
                let ast: RootNode* = parser.Parse(lexer.Lex(ReadFile(path.Data())));
                let mut k: u64 = 0u64;

                while k < ast->declarations.Size() {
                    let decl: ASTNode* = ast->declarations[k];
                    this.CompileDeclaration(decl);
                    k += 1u64;
                }

                found = true;
                this.included_paths.PushBack(path);
                break;
            }

            if !found {
                this.Error("Module not found.");
                ret;
            } else {
                i += 1u64;
            }
        }
    }

    priv CompileConstant(mut this: Compiler&, constant_decl: ConstantDeclNode*) {
        let _type: QualifiedType& = this.CompileType(constant_decl->var_type);
        let mut initializer: QualifiedValue;

        if constant_decl->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
            initializer = this.CompileConstantExpression(constant_decl->initializer);
        } else {
            let mut values: Vector<LLVMValueRef>;
            let initializer_list: InitializerListNode* = constant_decl->initializer as InitializerListNode*;
            let mut i: u64 = 0u64;

            while i < initializer_list->expressions.Size() {
                values.PushBack(this.CompileConstantExpression(initializer_list->expressions[i]).Value());
                i += 1u64;
            }

            initializer = QualifiedValue(LLVMConstNamedStruct(_type.Value(), values.Data(), values.Size() as u32), _type);
        }

        if initializer.Type() != _type {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
            ret;
        }

        let global: LLVMValueRef = LLVMAddGlobal(this.module, _type.Value(), constant_decl->name.Data());
        this.scope_manager.Set(constant_decl->name, SymbolKind::Variable, QualifiedValue(global, this.type_manager.Pointer(_type, false)));
        LLVMSetLinkage(global, LLVMLinkage::LLVMPrivateLinkage);
        LLVMSetInitializer(global, initializer.Value());
        LLVMSetGlobalConstant(global, 1i32);
    }

    priv ProcessType(mut this: Compiler&, _type: QualifiedType*) -> QualifiedType* {
        if LLVMGetTypeKind(_type->Value()) != LLVMTypeKind::LLVMStructTypeKind {
            ret _type;
        } else {
            let size: u64 = LLVMABISizeOfType(this.layout, _type->Value());

            if size > 8u64 {
                ret this.type_manager.Pointer(_type, _type->IsMutable());
            } else {
                if size > 4u64 {
                    ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), true);
                } else if size > 2u64 {
                    ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), true);
                } else if size > 1u64 {
                    ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), true);
                } else {
                    ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true);
                }
            }
        }
    }

    priv CompileFunction(mut this: Compiler&, func_decl: FunctionDeclNode*) {
        let (mut params: Vector<QualifiedType*>, mut param_types: Vector<LLVMTypeRef>);
        let mut return_type: QualifiedType* = this.CompileType(func_decl->_type->return_type);
        let mut attributes: Vector<LLVMTypeRef>;
        let mut sret: bool = false;

        if LLVMGetTypeKind(return_type->Value()) == LLVMTypeKind::LLVMStructTypeKind {
            let mut processed_type: QualifiedType& = this.ProcessType(return_type);

            if LLVMGetTypeKind(processed_type.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                return_type = processed_type;
            } else {
                params.PushBack(processed_type);
                param_types.PushBack(processed_type.Value());
                attributes.PushBack(return_type->Value());
                return_type = this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
                (processed_type.sret, sret) = (return_type, true);
            }
        }

        let mut i: u64 = 0u64;

        while i < func_decl->_type->parameters.Size() {
            let param: ParameterNode* = func_decl->_type->parameters[i];
            let real_type: QualifiedType& = this.CompileType(param->param_type);
            let mut processed_type: QualifiedType& = this.ProcessType(real_type);
            param_types.PushBack(processed_type.Value());
            params.PushBack(processed_type);

            if real_type != processed_type {
                attributes.PushBack(LLVMGetTypeKind(processed_type.Value()) == LLVMTypeKind::LLVMPointerTypeKind ? real_type.Value() : null);
                processed_type.byref = real_type;
            } else {
                attributes.PushBack(null);
            } i += 1u64;
        }

        let func_type: LLVMTypeRef = LLVMFunctionType(return_type->Value(), param_types.Data(), param_types.Size() as u32, func_decl->_type->var_arg ? 1i32 : 0i32);
        let function: LLVMValueRef = LLVMAddFunction(this.module, func_decl->name.Data(), func_type);
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, QualifiedValue(function, this.type_manager.Pointer(this.type_manager.Function(func_type, params, return_type), false)));
        let mut j: u64 = 0u64;

        while j < attributes.Size() {
            if attributes[j] != null {
                let attribute_kind: u32 = sret && j == 0u64 ? LLVMGetEnumAttributeKindForName("sret", 4u64) : LLVMGetEnumAttributeKindForName("byref", 5u64);
                LLVMAddAttributeAtIndex(function, (j + 1u64) as u32, LLVMCreateTypeAttribute(this.context, attribute_kind, attributes[j]));
            } j += 1u64;
        }

        if func_decl->body != null {
            this.forwards.PushBack(Pair<FunctionDeclNode*, LLVMValueRef>(func_decl, function));
        }
    }

    priv CompileClass(mut this: Compiler&, class_decl: ClassDeclNode*) {
        let mut field_types: Vector<LLVMTypeRef>;
        let mut fields: Map<String, QualifiedType*>;
        let mut i: u64 = 0u64;

        while i < class_decl->fields.Size() {
            let field: FieldNode* = class_decl->fields[i];
            fields[field->name] = this.CompileType(field->field_type);
            field_types.PushBack(fields[field->name]->Value());
            i += 1u64;
        }

        let struct_type: LLVMTypeRef = LLVMStructCreateNamed(this.context, class_decl->name.Data());
        this.scope_manager.Set(class_decl->name, SymbolKind::Type, QualifiedValue(null, this.type_manager.Class(struct_type, fields)));
        LLVMStructSetBody(struct_type, field_types.Data(), field_types.Size() as u32, 0i32);
    }

    priv CompileEnum(mut this: Compiler&, enum_decl: EnumDeclNode*) {
        let underlying_type: QualifiedType& = this.CompileType(enum_decl->underlying_type);

        if LLVMGetTypeKind(underlying_type.Value()) != LLVMTypeKind::LLVMIntegerTypeKind {
            this.Error("Expected an integer type.");
            ret;
        }

        this.scope_manager.Set(enum_decl->name, SymbolKind::Type, QualifiedValue(null, underlying_type));
        let mut value: LLVMValueRef = LLVMConstInt(underlying_type.Value(), 0u64, underlying_type.IsSigned() ? 1i32 : 0i32);
        this.scope_manager.PushScope(enum_decl->name, true);
        let mut i: u64 = 0u64;

        while i < enum_decl->values.Size() {
            if enum_decl->values[i].right != null {
                let _value: QualifiedValue = this.CompileConstantExpression(enum_decl->values[i].right);

                if _value.Type() != underlying_type {
                    this.Error((String("Incompatible types. ('") + LLVMTypeToString(_value.Type().Value()) + "' != '" + LLVMTypeToString(underlying_type.Value()) + "').").Data());
                    ret;
                }

                value = _value.Value();
            } else {
                value = LLVMConstAdd(value, LLVMConstInt(underlying_type.Value(), 1u64, underlying_type.IsSigned() ? 1i32 : 0i32));
            }

            this.scope_manager.Set(enum_decl->values[i].left, SymbolKind::Constant, QualifiedValue(value, underlying_type));
            i += 1u64;
        }

        this.scope_manager.PopScope();
    }

    priv CompileExtern(mut this: Compiler&, extern_block: ExternBlockNode*) {
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }
    }

    priv CompileBlock(mut this: Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(mut this: Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            let ret_stmt: ReturnStmtNode* = stmt as ReturnStmtNode*;
            LLVMBuildRet(this.builder, this.CompileExpression(ret_stmt->value, false).Value());
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression, false);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement '") + ASTNodeTypeToString(stmt->node_type) + "'.").Data());
        }
    }

    priv CompileIf(mut this: Compiler&, if_stmt: IfStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let (mut current: IfStmtNode*, mut end_block: LLVMBasicBlockRef) = (if_stmt, null);

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement '") + ASTNodeTypeToString(else_stmt->node_type) + "'.").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } then_block = end_block;
            }

            let mut else_block: LLVMBasicBlockRef;

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } else_block = end_block;
            }

            let condition: QualifiedValue = this.CompileExpression(current->condition, false);
            LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(mut this: Compiler&, while_stmt: WhileStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));

        LLVMBuildBr(this.builder, compare_block);
        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: QualifiedValue = this.CompileExpression(while_stmt->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->body as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(mut this: Compiler&, variable: VariableDeclNode*) {
        let _type: QualifiedType& = this.CompileType(variable->var_type);
        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
        let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, _type.Value(), "");
        this.scope_manager.Set(variable->name, SymbolKind::Variable, QualifiedValue(pointer, this.type_manager.Pointer(_type, variable->is_mutable)));
        LLVMPositionBuilderAtEnd(this.builder, current);

        if variable->initializer != null {
            let initializer: QualifiedValue = this.CompileExpression(variable->initializer, _type.IsReference());

            if initializer.Type() != _type {
                this.Error((String("Incompatible types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
                ret;
            }

            LLVMBuildStore(this.builder, initializer.Value(), pointer);
        }
    }

    priv CompileAssignment(mut this: Compiler&, assignment: AssignmentNode*) -> QualifiedValue {
        let mut pointer: QualifiedValue = this.CompileExpression(assignment->left, true);
        let value: QualifiedValue = this.CompileExpression(assignment->right, false);

        if pointer.Type().Pointee().IsReference() {
            pointer = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
        }

        if !pointer.Type().IsMutable() {
            this.Error("Cannot assign to immutable variable.");
            ret QualifiedValue(null, null);
        }

        if value.Type() != pointer.Type().Pointee() {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(pointer.Type().Pointee().Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        LLVMBuildStore(this.builder, value.Value(), pointer.Value());
        ret value;
    }

    priv CompileConstantExpression(mut this: Compiler&, expr: ASTNode*) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            ret this.CompileLiteral(expr as LiteralNode*);
        } else if expr->node_type == ASTNodeType::IDENTIFIER || expr->node_type == ASTNodeType::SCOPE_RESOLUTION {
            let symbol: Symbol* = this.scope_manager.Resolve(expr);

            if symbol->kind == SymbolKind::Constant {
                ret symbol->value;
            } else {
                this.Error((String("Invalid symbol kind '") + SymbolKindToString(symbol->kind) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompileConstantUnaryOperation(expr as UnaryOpNode*);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            ret this.CompileConstantBinaryOperation(expr as BinaryOpNode*);
        } else {
            this.Error((String("Unknown constant expression '") + ASTNodeTypeToString(expr->node_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileConstantUnaryOperation(mut this: Compiler&, unary_op: UnaryOpNode*) -> QualifiedValue {
        let value: QualifiedValue = this.CompileConstantExpression(unary_op->operand);
        let kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

        if unary_op->operator == TokenType::MINUS {
            if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if value.Type().IsSigned() {
                    ret QualifiedValue(LLVMConstNeg(value.Value()), value.Type());
                } else {
                    this.Error((String("Cannot negate unsigned type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                ret QualifiedValue(LLVMConstNeg(value.Value()), value.Type());
            } else {
                this.Error((String("Cannot negate type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if unary_op->operator == TokenType::NOT {
            if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                ret QualifiedValue(LLVMConstNot(value.Value()), value.Type());
            } else {
                this.Error((String("Cannot invert type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid constant unary operation '") + TokenTypeToString(unary_op->operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileConstantBinaryOperation(mut this: Compiler&, binary_op: BinaryOpNode*) -> QualifiedValue {
        let (left: QualifiedValue, right: QualifiedValue) = (this.CompileConstantExpression(binary_op->left), this.CompileConstantExpression(binary_op->right));
        let (left_kind: LLVMTypeKind, right_kind: LLVMTypeKind) = (LLVMGetTypeKind(left.Type().Value()), LLVMGetTypeKind(right.Type().Value()));

        if left.Type().IsPointer() && right.Type().IsPointer() {
            if binary_op->operator == TokenType::MINUS {
                let left_int: LLVMValueRef = LLVMConstPtrToInt(left.Value(), LLVMInt64TypeInContext(this.context));
                let right_int: LLVMValueRef = LLVMConstPtrToInt(right.Value(), LLVMInt64TypeInContext(this.context));
                ret QualifiedValue(LLVMConstSub(left_int, right_int), this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid constant pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left.Type().IsPointer() && right_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right.Type().IsPointer()) {
            let ptr: QualifiedValue = left.Type().IsPointer() ? left : right;
            let index: QualifiedValue = left.Type().IsPointer() ? right : left;
            let width: u32 = LLVMGetIntTypeWidth(index.Value());

            if width == 64u32 {
                if binary_op->operator == TokenType::PLUS {
                    let indices[]: LLVMValueRef = { index.Value() };
                    ret QualifiedValue(LLVMConstGEP2(ptr.Type().Value(), ptr.Value(), indices, 1u32), ptr.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    let indices[]: LLVMValueRef = { LLVMConstNeg(index.Value()) };
                    ret QualifiedValue(LLVMConstGEP2(ptr.Type().Value(), ptr.Value(), indices, 1u32), ptr.Type());
                } else {
                    this.Error((String("Invalid constant pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMConstAdd(left.Value(), right.Value()), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMConstSub(left.Value(), right.Value()), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMConstMul(left.Value(), right.Value()), left.Type());
            } else if binary_op->operator == TokenType::BITWISE_XOR {
                ret QualifiedValue(LLVMConstXor(left.Value(), right.Value()), left.Type());
            } else {
                this.Error((String("Invalid constant binary operation '") + TokenTypeToString(binary_op->operator) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }
    }

    priv CompileExpression(mut this: Compiler&, expr: ASTNode*, pointer: bool) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            if !pointer {
                ret this.CompileLiteral(expr as LiteralNode*);
            } else {
                this.Error("Invalid pointer expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CALL {
            if !pointer {
                ret this.CompileCall(expr as CallNode*);
            } else {
                this.Error("Invalid pointer expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::TERNARY {
            ret this.CompileTernary(expr as TernaryNode*, pointer);
        } else if expr->node_type == ASTNodeType::IDENTIFIER || expr->node_type == ASTNodeType::SCOPE_RESOLUTION {
            let symbol: Symbol* = this.scope_manager.Resolve(expr);

            if (symbol->kind == SymbolKind::Variable || symbol->kind == SymbolKind::Constant || symbol->kind == SymbolKind::Parameter) && !pointer {
                if symbol->kind == SymbolKind::Constant || (symbol->kind == SymbolKind::Parameter && !symbol->value.Type().IsMutable()) {
                    ret symbol->value;
                } else {
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, symbol->value.Type().Pointee().Value(), symbol->value.Value(), ""), symbol->value.Type().Pointee());
                }
            } else if symbol->kind == SymbolKind::Function || pointer {
                ret symbol->value;
            } else {
                this.Error((String("Invalid symbol kind '") + SymbolKindToString(symbol->kind) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CAST {
            if !pointer {
                ret this.CompileCast(expr as CastNode*);
            } else {
                this.Error("Invalid pointer expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::MEMBER_ACCESS {
            ret this.CompileMemberAccess(expr as MemberAccessNode*, pointer);
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompileUnaryOperation(expr as UnaryOpNode*, pointer);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            if !pointer {
                ret this.CompileBinaryOperation(expr as BinaryOpNode*);
            } else {
                this.Error("Invalid pointer expression.");
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Unknown expression '") + ASTNodeTypeToString(expr->node_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileLiteral(mut this: Compiler&, literal: LiteralNode*) -> QualifiedValue {
        if literal->literal_type == TokenType::INTEGER {
            let (mut state: bool, mut base: i32) = (false, 10i32);
            let (mut signed: bool, mut width: u64) = (true, 32u64);
            let (mut value: String, mut size: String);
            let mut i: u64 = 0u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == '0' && (literal->value[i + 1u64] == 'x' || literal->value[i + 1u64] == 'o' || literal->value[i + 1u64] == 'b') {
                        if i != 0u64 || base != 10i32 {
                            this.Error((String("Invalid integer '") + literal->value + "'.").Data());
                            ret QualifiedValue(null, null);
                        } else {
                            base = literal->value[i + 1u64] == 'x' ? 16i32 : (literal->value[i + 1u64] == 'o' ? 8i32 : 2i32);
                        } i += 1u64;
                    } else if literal->value[i] == 'u' {
                        (signed, state) = (false, true);
                    } else if literal->value[i] == 'i' {
                        (signed, state) = (true, true);
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 128u64 {
                _type = LLVMInt128TypeInContext(this.context);
            } else if width == 64u64 {
                _type = LLVMInt64TypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMInt32TypeInContext(this.context);
            } else if width == 16u64 {
                _type = LLVMInt16TypeInContext(this.context);
            } else if width == 8u64 {
                _type = LLVMInt8TypeInContext(this.context);
            } else {
                this.Error((String("Invalid integer size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstInt(_type, value.ToInteger(base) as u64, signed ? 1i32 : 0i32), this.type_manager.Primitive(_type, signed));
        } else if literal->literal_type == TokenType::FLOAT {
            let (mut state: bool, mut i: u64) = (false, 0u64);
            let (mut value: String, mut size: String);
            let mut width: u64 = 32u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == 'f' {
                        state = true;
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 64u64 {
                _type = LLVMDoubleTypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMFloatTypeInContext(this.context);
            } else {
                this.Error((String("Invalid float size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstReal(_type, value.ToFloat()), this.type_manager.Primitive(_type, false));
        } else if literal->literal_type == TokenType::TRUE || literal->literal_type == TokenType::FALSE {
            let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            ret QualifiedValue(LLVMConstInt(_type.Value(), literal->literal_type == TokenType::TRUE ? 1u64 : 0u64, 0i32), _type);
        } else if literal->literal_type == TokenType::STRING {
            let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "str");
            ret QualifiedValue(value, this.type_manager.Primitive(LLVMTypeOf(value), false));
        } else if literal->literal_type == TokenType::NULL {
            let _type: QualifiedType& = this.type_manager.Pointer(this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false), false);
            ret QualifiedValue(LLVMConstNull(_type.Value()), _type);
        } else {
            this.Error((String("Unknown literal type '") + TokenTypeToString(literal->literal_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileCall(mut this: Compiler&, call: CallNode*) -> QualifiedValue {
        let _func: QualifiedValue = this.CompileExpression(call->function, true);
        let params: Vector<QualifiedType*> = _func.Type().Pointee().Parameters();
        let mut args: Vector<LLVMValueRef>;
        let mut i: u64 = 0u64;

        while i < call->arguments.Size() {
            let arg: ASTNode* = call->arguments[i];

            if i < params.Size() {
                if params[i]->byref != null {
                    let mut value: QualifiedValue = this.CompileExpression(arg, true);
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, value.Type().Pointee().Value(), "");
                    LLVMPositionBuilderAtEnd(this.builder, current);
                    LLVMBuildStore(this.builder, LLVMBuildLoad2(this.builder, value.Type().Value(), value.Value(), ""), pointer);
                    value = QualifiedValue(pointer, value.Type());

                    if LLVMGetTypeKind(params[i]->Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                        args.PushBack(LLVMBuildLoad2(this.builder, params[i]->Value(), value.Value(), ""));
                    } else {
                        args.PushBack(value.Value());
                    }
                } else {
                    args.PushBack(this.CompileExpression(arg, false).Value());
                }
            } else {
                args.PushBack(this.CompileExpression(arg, false).Value());
            } i += 1u64;
        }

        let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.Type().Pointee().Value(), _func.Value(), args.Data(), args.Size() as u32, "");
        ret QualifiedValue(value, this.type_manager.Primitive(LLVMGetReturnType(_func.Type().Pointee().Value()), false));
    }

    priv CompileTernary(mut this: Compiler&, ternary: TernaryNode*, pointer: bool) -> QualifiedValue {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let then_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let else_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let merge_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

        let condition: QualifiedValue = this.CompileExpression(ternary->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

        LLVMPositionBuilderAtEnd(this.builder, then_block);
        let then_value: QualifiedValue = this.CompileExpression(ternary->then_expr, pointer);
        LLVMBuildBr(this.builder, merge_block);

        LLVMPositionBuilderAtEnd(this.builder, else_block);
        let else_value: QualifiedValue = this.CompileExpression(ternary->else_expr, pointer);
        LLVMBuildBr(this.builder, merge_block);

        if then_value.Type() != else_value.Type() {
            this.Error((String("Incompatible types. ('") + LLVMTypeToString(then_value.Type().Value()) + "' != '" + LLVMTypeToString(else_value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        LLVMPositionBuilderAtEnd(this.builder, merge_block);
        let value: LLVMValueRef = LLVMBuildPhi(this.builder, then_value.Type().Value(), "");

        let blocks[]: LLVMBasicBlockRef = { then_block, else_block };
        let values[]: LLVMValueRef = { then_value.Value(), else_value.Value() };
        LLVMAddIncoming(value, values, blocks, 2u32);

        ret QualifiedValue(value, then_value.Type());
    }

    priv CompileMemberAccess(mut this: Compiler&, member_access: MemberAccessNode*, pointer: bool) -> QualifiedValue {
        let mut object: QualifiedValue = this.CompileExpression(member_access->object, true);

        if member_access->arrow {
            object = QualifiedValue(LLVMBuildLoad2(this.builder, object.Type().Pointee().Value(), object.Value(), ""), object.Type().Pointee());

            if !object.Type().IsPointer() {
                this.Error("Expected a pointer.");
                ret QualifiedValue(null, null);
            }
        }

        if !object.Type().Pointee().IsClass() {
            this.Error("Cannot access member of non-class type.");
            ret QualifiedValue(null, null);
        }

        let index: i64 = object.Type().Pointee().Index(member_access->member);

        if index == -1i64 {
            this.Error((String("Class does not have member '") + member_access->member + "'.").Data());
            ret QualifiedValue(null, null);
        }

        let member_pointer: LLVMValueRef = LLVMBuildStructGEP2(this.builder, object.Type().Pointee().Value(), object.Value(), index as u32, "");
        let member_type: QualifiedType& = object.Type().Pointee().Fields()[member_access->member];

        if !pointer {
            ret QualifiedValue(LLVMBuildLoad2(this.builder, member_type.Value(), member_pointer, ""), member_type);
        } else {
            ret QualifiedValue(member_pointer, this.type_manager.Pointer(member_type, object.Type().Pointee().IsMutable()));
        }
    }

    priv CompileCast(mut this: Compiler&, cast: CastNode*) -> QualifiedValue {
        let value: QualifiedValue = this.CompileExpression(cast->expression, false);
        let value_kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());
        let target: QualifiedType& = this.CompileType(cast->target_type);
        let target_kind: LLVMTypeKind = LLVMGetTypeKind(target.Value());

        if value.Type() == target {
            this.Error((String("Redundant cast. ('") + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "')").Data());
            ret QualifiedValue(null, null);
        }

        if value.Type().IsPointer() && target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            ret QualifiedValue(LLVMBuildPtrToInt(this.builder, value.Value(), target.Value(), ""), target);
        } else if value_kind == LLVMTypeKind::LLVMFloatTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                ret QualifiedValue(LLVMBuildFPExt(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMDoubleTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }
            
            if target_kind == LLVMTypeKind::LLVMFloatTypeKind {
                ret QualifiedValue(LLVMBuildFPTrunc(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if target.IsPointer() {
                ret QualifiedValue(LLVMBuildIntToPtr(this.builder, value.Value(), target.Value(), ""), target);
            }

            if target_kind == LLVMTypeKind::LLVMFloatTypeKind || target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if value.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSIToFP(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildUIToFP(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                let value_width: u32 = LLVMGetIntTypeWidth(value.Type().Value());
                let target_width: u32 = LLVMGetIntTypeWidth(target.Value());

                if target_width > value_width {
                    if value.Type().IsSigned() {
                        ret QualifiedValue(LLVMBuildSExt(this.builder, value.Value(), target.Value(), ""), target);
                    } else {
                        ret QualifiedValue(LLVMBuildZExt(this.builder, value.Value(), target.Value(), ""), target);
                    }
                } else if target_width < value_width {
                    ret QualifiedValue(LLVMBuildTrunc(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(value.Value(), target);
                }
            }
        }

        if value.Type().IsPointer() && target.IsPointer() {
            ret QualifiedValue(LLVMBuildBitCast(this.builder, value.Value(), target.Value(), ""), target);
        } else {
            this.Error(String("Cannot cast '" + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileUnaryOperation(mut this: Compiler&, unary_op: UnaryOpNode*, pointer: bool) -> QualifiedValue {
        if unary_op->operator == TokenType::BITWISE_AND {
            if !pointer {
                ret this.CompileExpression(unary_op->operand, true);
            } else {
                this.Error("Invalid pointer unary operation.");
                ret QualifiedValue(null, null);
            }
        } else {
            let value: QualifiedValue = this.CompileExpression(unary_op->operand, false);
            let kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

            if unary_op->operator == TokenType::MUL {
                if value.Type().IsPointer() {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                    } else {
                        ret value;
                    }
                } else {
                    this.Error((String("Cannot dereference non-pointer type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::MINUS {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type().IsSigned() {
                        if !pointer {
                            ret QualifiedValue(LLVMBuildNeg(this.builder, value.Value(), ""), value.Type());
                        } else {
                            this.Error("Invalid pointer unary operation.");
                            ret QualifiedValue(null, null);
                        }
                    } else {
                        this.Error((String("Cannot negate unsigned type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildFNeg(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot negate type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::NOT {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildNot(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot invert type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid unary operation '") + TokenTypeToString(unary_op->operator) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }
    }

    priv CompileBinaryOperation(mut this: Compiler&, binary_op: BinaryOpNode*) -> QualifiedValue {
        let (left: QualifiedValue, right: QualifiedValue) = (this.CompileExpression(binary_op->left, false), this.CompileExpression(binary_op->right, false));
        let (left_kind: LLVMTypeKind, right_kind: LLVMTypeKind) = (LLVMGetTypeKind(left.Type().Value()), LLVMGetTypeKind(right.Type().Value()));

        if left.Type().IsPointer() && right.Type().IsPointer() {
            if binary_op->operator == TokenType::MINUS {
                let left_int: LLVMValueRef = LLVMBuildPtrToInt(this.builder, left.Value(), LLVMInt64TypeInContext(this.context), "");
                let right_int: LLVMValueRef = LLVMBuildPtrToInt(this.builder, right.Value(), LLVMInt64TypeInContext(this.context), "");
                ret QualifiedValue(LLVMBuildSub(this.builder, left_int, right_int, ""), this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left.Type().IsPointer() && right_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right.Type().IsPointer()) {
            let ptr: QualifiedValue = left.Type().IsPointer() ? left : right;
            let index: QualifiedValue = left.Type().IsPointer() ? right : left;
            let width: u32 = LLVMGetIntTypeWidth(index.Value());

            if width == 64u32 {
                if binary_op->operator == TokenType::PLUS {
                    let indices[]: LLVMValueRef = { index.Value() };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), "") };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else {
                    this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildUDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::MOD {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSRem(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildURem(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGT : LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGE : LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLT : LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLE : LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::AND || binary_op->operator == TokenType::BITWISE_AND {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::AND {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildAnd(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::OR || binary_op->operator == TokenType::BITWISE_OR {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::OR {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildOr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::BITWISE_XOR {
                ret QualifiedValue(LLVMBuildXor(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::LSHIFT {
                ret QualifiedValue(LLVMBuildShl(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::RSHIFT {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildAShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildLShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind) && (right_kind == LLVMTypeKind::LLVMFloatTypeKind || right_kind == LLVMTypeKind::LLVMDoubleTypeKind) {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildFAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildFSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildFMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                ret QualifiedValue(LLVMBuildFDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MOD {
                ret QualifiedValue(LLVMBuildFRem(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileType(mut this: Compiler&, type_node: ASTNode*) -> QualifiedType& {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->type_name == "bool" {
                ret this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            } else if primitive_type->type_name == "i8" || primitive_type->type_name == "u8" {
                ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i16" || primitive_type->type_name == "u16" {
                ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i32" || primitive_type->type_name == "u32" || primitive_type->type_name == "char" {
                ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i64" || primitive_type->type_name == "u64" {
                ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i128" || primitive_type->type_name == "u128" {
                ret this.type_manager.Primitive(LLVMInt128TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "f32" {
                ret this.type_manager.Primitive(LLVMFloatTypeInContext(this.context), false);
            } else if primitive_type->type_name == "f64" {
                ret this.type_manager.Primitive(LLVMDoubleTypeInContext(this.context), false);
            } else if primitive_type->type_name == "void" {
                ret this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
            } else {
                if !this.scope_manager.Has(primitive_type->type_name) {
                    this.Error((String("Symbol '") + primitive_type->type_name + "' not found.").Data());
                    ret null;
                }

                let symbol: Symbol* = this.scope_manager.Get(primitive_type->type_name);

                if symbol->kind == SymbolKind::Type {
                    let _type: QualifiedType& = symbol->value.Type();

                    if _type.IsPrimitive() { ret _type; } else {
                        ret this.type_manager.Copy(_type, primitive_type->mutable);
                    }
                } else {
                    this.Error((String("Invalid symbol kind '") + SymbolKindToString(symbol->kind) + "'.").Data());
                    ret null;
                }
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(pointer_type->base_type), pointer_type->mutable);
        } else if type_node->node_type == ASTNodeType::REFERENCE_TYPE {
            let reference_type: ReferenceTypeNode* = type_node as ReferenceTypeNode*;
            ret this.type_manager.Reference(this.CompileType(reference_type->base_type), reference_type->mutable);
        } else if type_node->node_type == ASTNodeType::ARRAY_TYPE {
            let array_type: ArrayTypeNode* = type_node as ArrayTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(array_type->element_type), true);
        } else if type_node->node_type == ASTNodeType::FUNCTION_TYPE {
            let function_type: FunctionTypeNode* = type_node as FunctionTypeNode*;
            let mut param_types: Vector<LLVMTypeRef>;
            let mut j: u64 = 0u64;

            while j < function_type->parameters.Size() {
                let param: ParameterNode* = function_type->parameters[j];
                param_types.PushBack(this.CompileType(param->param_type).Value());
                j += 1u64;
            }

            let return_type: LLVMTypeRef = this.CompileType(function_type->return_type).Value();
            ret this.type_manager.Pointer(this.type_manager.Primitive(LLVMFunctionType(return_type, param_types.Data(), param_types.Size() as u32, function_type->var_arg ? 1i32 : 0i32), false), false);
        } else {
            this.Error((String("Unknown type '") + ASTNodeTypeToString(type_node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: Compiler&, string: i8*) {
        printf("Compiler error: %s\n", string);
        exit(1i32);
    }
};