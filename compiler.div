include "divio", "divstr", "divvec", "divmap", "divpair", "divptr", "divwin", "divfile", "divllvm", "lexer.div", "parser.div" : *;

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right { ret true; }
    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMElementTypeOf(value: LLVMValueRef) -> LLVMTypeRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMAlloca {
        ret LLVMGetAllocatedType(value);
    } else {
        ret LLVMGetElementType(LLVMTypeOf(value));
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

func LLVMValueToString(value: LLVMValueRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintValueToString(value);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

func LLVMAddressOf(value: LLVMValueRef) -> LLVMValueRef {
    if LLVMIsAInstruction(value) != null && LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMLoad {
        let operand: LLVMValueRef = LLVMGetOperand(value, 0u32);
        LLVMInstructionEraseFromParent(value);
        ret operand;
    } else {
        printf("Failed to get address of '%s'.\n", LLVMValueToString(value).Data());
        exit(1i32);
        ret null;
    }
}

class Field {
    pub initializer: ASTNode*,
    pub visibility: TokenType
} impl {
    Field(mut this: Field&, initializer: ASTNode*, visibility: TokenType) {
        (this.initializer, this.visibility) = (initializer, visibility);
    }

    ~Field(this: Field&) {}
};

class Method {
    pub name: String,
    pub value: LLVMValueRef,
    pub visibility: TokenType
} impl {
    Method(mut this: Method&, name: String, value: LLVMValueRef, visibility: TokenType) {
        (this.name, this.value, this.visibility) = (name, value, visibility);
    }

    ~Method(this: Method&) {}
};

class QualifiedType {
    pub current_class: QualifiedType** = null,
    priv value: LLVMTypeRef, priv pointee: QualifiedType* = null,
    priv reference: bool = false, priv mutable: bool = false, priv signed: bool = false,
    pub copy: QualifiedType* = null, pub original: QualifiedType* = null,

    pub fields: Map<String, Pair<Field, QualifiedType*>>,
    pub methods: Vector<Pair<Method, QualifiedType*>>,
    pub name: String, priv _class: bool = false,

    pub sret: QualifiedType* = null, pub byval: QualifiedType* = null,
    priv params: Vector<QualifiedType*>, priv return: QualifiedType* = null,
    priv _function: bool = false
} impl {
    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, signed: bool) {
        (this.value, this.signed) = (value, signed);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) {
        (this.value, this.params, this.return, this._function) = (value, params, return, true);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, name: String) {
        (this.value, this.mutable, this.name, this._class) = (value, mutable, name, true);
    }

    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, reference: bool, pointee: QualifiedType*) {
        (this.value, this.mutable, this.reference, this.pointee) = (value, mutable, reference, pointee);
    }

    ~QualifiedType(this: QualifiedType&) {}

    pub IsMutable(this: QualifiedType&) -> bool { ret this.mutable; }
    pub IsSigned(this: QualifiedType&) -> bool { ret this.signed; }
    pub IsPointer(this: QualifiedType&) -> bool { ret this.pointee != null; }
    pub IsReference(this: QualifiedType&) -> bool { ret this.reference; }
    pub IsPrimitive(this: QualifiedType&) -> bool { ret !this.IsPointer() && !this.IsClass(); }
    pub IsFunction(this: QualifiedType&) -> bool { ret this._function; }
    pub IsClass(this: QualifiedType&) -> bool { ret this._class; }

    pub Value(this: QualifiedType&) -> LLVMTypeRef {
        if this.value != null {
            ret this.value;
        } else {
            this.Error("Null type!");
            ret null;
        }
    }

    pub Pointee(this: QualifiedType&) -> QualifiedType& {
        if this.pointee != null {
            ret this.pointee;
        } else {
            this.Error("Null pointee!");
            ret null;
        }
    }

    pub Parameters(this: QualifiedType&) -> Vector<QualifiedType*>& {
        if this._function {
            ret this.params;
        } else {
            this.Error("Not a function!");
            ret null;
        }
    }

    pub Return(this: QualifiedType&) -> QualifiedType* {
        if this._function {
            ret this.return;
        } else {
            this.Error("Not a function!");
            ret null;
        }
    }

    pub Fields(this: QualifiedType&) -> Map<String, Pair<Field, QualifiedType*>>& {
        if this._class {
            if this.original != null {
                ret this.original->fields;
            } else {
                ret this.fields;
            }
        } else {
            this.Error("Not a class!");
            ret null;
        }
    }

    pub Methods(this: QualifiedType&) -> Vector<Pair<Method, QualifiedType*>>& {
        if this._class {
            if this.original != null {
                ret this.original->methods;
            } else {
                ret this.methods;
            }
        } else {
            this.Error("Not a class!");
            ret null;
        }
    }

    pub Index(this: QualifiedType&, name: String&) -> i64 {
        let fields: Map<String, Pair<Field, QualifiedType*>>& = this.Fields();
        let mut i: u64 = 0u64;

        while i < fields.Size() {
            if fields.Data()[i].left == name {
                ret i as i64;
            } i += 1u64;
        } ret -1i64;
    }

    pub Has(this: QualifiedType&, name: String&) -> bool {
        let methods: Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Has(this: QualifiedType&, name: String&, params: Vector<QualifiedType*>&) -> bool {
        let methods: Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                let mut state: bool = false;

                if *this.current_class != null {
                    state = **this.current_class == this;
                }

                if methods[i].left.visibility == TokenType::PUBLIC || state {
                    let (mut match: bool, mut j: u64) = (true, 0u64);
                    let _params: Vector<QualifiedType*>& = methods[i].right->Pointee().Parameters();
                    let offset: u64 = _params[0u64]->sret != null ? 2u64 : 1u64;

                    if params.Size() != _params.Size() - offset {
                        i += 1u64;
                        continue;
                    }

                    while params.Size() > j {
                        let mut _type: QualifiedType* = _params[j + offset];

                        if _type->byval != null {
                            _type = _type->byval;
                        }

                        if _type->IsReference() && (*_type) != params[j] {
                            _type = _type->Pointee();
                        }

                        if (*_type) != params[j] {
                            match = false;
                            break;
                        } else {
                            j += 1u64;
                        }
                    }

                    if match {
                        ret true;
                    }
                }
            } i += 1u64;
        } ret false;
    }

    pub Get(this: QualifiedType&, name: String&) -> Pair<Method, QualifiedType*>& {
        let methods: Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                ret methods[i];
            } i += 1u64;
        } ret null;
    }

    pub Get(this: QualifiedType&, name: String&, params: Vector<QualifiedType*>&) -> Pair<Method, QualifiedType*>& {
        let mut matches: Vector<Pair<Method, QualifiedType*>>;
        let methods: Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let (mut state: u64, mut i: u64) = (0u64, 0u64);

        while i < methods.Size() {
            if methods[i].left.name == name {
                let mut _state: bool = false;

                if *this.current_class != null {
                    _state = **this.current_class == this;
                }

                if methods[i].left.visibility != TokenType::PUBLIC && !_state {
                    if state < 1u64 { state = 1u64; }
                } else {
                    let (mut match: bool, mut j: u64) = (true, 0u64);
                    let _params: Vector<QualifiedType*>& = methods[i].right->Pointee().Parameters();
                    let offset: u64 = _params[0u64]->sret != null ? 2u64 : 1u64;

                    if params.Size() != _params.Size() - offset {
                        i += 1u64;
                        continue;
                    }

                    while params.Size() > j {
                        let mut _type: QualifiedType* = _params[j + offset];

                        if _type->byval != null {
                            _type = _type->byval;
                        }

                        if _type->IsReference() && (*_type) != params[j] {
                            _type = _type->Pointee();
                        }

                        if (*_type) != params[j] {
                            match = false;
                            break;
                        } else {
                            j += 1u64;
                        }
                    }

                    if !match {
                        state = 2u64;
                    } else {
                        matches.PushBack(methods[i]);
                    }
                }
            } i += 1u64;
        }

        if matches.Size() != 0u64 {
            if matches.Size() > 1u64 {
                this.Error("Overloading with references/pointers not supported yet.");
                ret null;
            } else {
                ret matches[0u64];
            }
        } else {
            if state == 0u64 {
                this.Error((String("Class '") + this.name + "' doesn't contain any member named '" + name + "'.").Data());
                ret null;
            } else if state == 1u64 {
                this.Error((String("Function '") + name + "' is not accessible.").Data());
                ret null;
            } else {
                this.Error((String("Invalid arguments for: '") + name + "'.").Data());
                ret null;
            }
        }        
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        if this.pointee != null && other.pointee != null {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && (*this.pointee) == (*other.pointee);
        } else {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && this.pointee == other.pointee;
        }
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }

    priv Error(this: QualifiedType&, message: i8*) {
        printf("Qualified type error: %s\n", message);
        exit(1i32);
    }
};

class TypeManager {
    priv current_class: QualifiedType** = null,
    priv types: Vector<QualifiedType*>
} impl {
    TypeManager(this: TypeManager&) {}

    ~TypeManager(mut this: TypeManager&) {
        printf("Disposing %llu types...\n", this.types.Size());
        let mut i: u64 = 0u64;

        while i < this.types.Size() {
            del this.types[i];
            i += 1u64;
        }

        this.types.Clear();
    }

    pub Primitive(mut this: TypeManager&, value: LLVMTypeRef, signed: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, signed);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Function(mut this: TypeManager&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, params, return);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Class(mut this: TypeManager&, value: LLVMTypeRef, name: String) -> QualifiedType* {
        let mut _type: QualifiedType* = new QualifiedType(value, false, name);
        _type->current_class = this.current_class;
        this.types.PushBack(_type);
        ret _type;
    }

    pub Pointer(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, false, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Reference(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, true, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Copy(mut this: TypeManager&, mut _type: QualifiedType*, mutable: bool) -> QualifiedType* {
        if mutable != _type->IsMutable() {
            let mut copy: QualifiedType* = null;

            if _type->IsClass() {
                if _type->copy != null {
                    ret _type->copy;
                } else {
                    _type->copy = new QualifiedType(_type->Value(), mutable, _type->name);
                    (copy, copy->original, copy->current_class) = (_type->copy, _type, _type->current_class);
                }
            } else if _type->IsPointer() {
                copy = new QualifiedType(_type->Value(), mutable, _type->IsReference(), _type->Pointee());
            } else {
                this.Error("Cannot copy primitive or function type.");
                ret null;
            }

            this.types.PushBack(copy);
            ret copy;
        } else {
            ret _type;
        }
    }

    priv Error(this: TypeManager&, message: i8*) {
        printf("Type manager error: %s\n", message);
        exit(1i32);
    }
};

class QualifiedValue {
    priv value: LLVMValueRef,
    priv _type: QualifiedType*,
    pub instance: LLVMValueRef = null,
    pub instance_type: QualifiedType* = null,
    pub return: bool = false
} impl {
    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*) {
        (this.value, this._type) = (value, _type);
    }

    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*, instance: QualifiedValue&) {
        (this.value, this._type, this.instance, this.instance_type) = (value, _type, instance.value, instance._type);
    }

    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*, return: bool) {
        (this.value, this._type, this.return) = (value, _type, return);
    }

    ~QualifiedValue(this: QualifiedValue&) {}

    pub Null(this: QualifiedValue&) -> bool {
        ret this.value == null;
    }

    pub Value(this: QualifiedValue&) -> LLVMValueRef {
        if this.value != null {
            ret this.value;
        } else {
            this.Error("Null value!");
            ret null;
        }
    }

    pub Type(this: QualifiedValue&) -> QualifiedType& {
        if this._type != null {
            ret this._type;
        } else {
            this.Error("Null type!");
            ret null;
        }
    }

    priv Error(this: QualifiedValue&, message: i8*) {
        printf("Qualified value error: %s\n", message);
        exit(1i32);
    }
};

enum SymbolKind {
    Variable, Constant, Function, Parameter, Generic, Class, Type
};

func SymbolKindToString(kind: SymbolKind) -> String {
    if kind == SymbolKind::Variable { ret { "Variable" } as String; }
    else if kind == SymbolKind::Constant { ret { "Constant" } as String; }
    else if kind == SymbolKind::Function { ret { "Function" } as String; }
    else if kind == SymbolKind::Parameter { ret { "Parameter" } as String; }
    else if kind == SymbolKind::Generic { ret { "Generic" } as String; }
    else if kind == SymbolKind::Class { ret { "Class" } as String; }
    else if kind == SymbolKind::Type { ret { "Type" } as String; }
    else { ret { "Unknown" } as String; }
}

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: QualifiedValue,
    pub pointer: void* = null
} impl {
    Symbol(mut this: Symbol&, name: String, kind: SymbolKind, value: QualifiedValue) {
        (this.name, this.kind, this.value) = (name, kind, value);
    }

    Symbol(mut this: Symbol&, name: String, kind: SymbolKind, pointer: void*) {
        (this.name, this.kind, this.pointer) = (name, kind, pointer);
    }

    ~Symbol(this: Symbol&) {}
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub instances: Vector<QualifiedValue>,
    pub name: String
} impl {
    Scope(mut this: Scope&, parent: Scope*, name: String&, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(this: Scope&, name: String&) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }
    
    pub Has(this: Scope&, name: String&, kind: SymbolKind) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name && this.symbols[i]->kind == kind {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(mut this: Scope&, name: String&, kind: SymbolKind, value: QualifiedValue&, overload: bool) -> Symbol* {
        if this.Has(name) && !overload {
            this.Error((String("Symbol '") + name + "' already exists.").Data());
            ret null;
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value);
            this.symbols.PushBack(symbol);
            ret symbol;
        }
    }

    pub Set(mut this: Scope&, name: String&, kind: SymbolKind, pointer: void*, overload: bool) -> Symbol* {
        if this.Has(name) && !overload {
            this.Error((String("Symbol '") + name + "' already exists.").Data());
            ret null;
        } else {
            let symbol: Symbol* = new Symbol(name, kind, pointer);
            this.symbols.PushBack(symbol);
            ret symbol;
        }
    }

    pub Get(this: Scope&, name: String&) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    pub Get(this: Scope&, name: String&, kind: SymbolKind) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name && this.symbols[i]->kind == kind {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(this: Scope&, message: i8*) {
        printf("Scope error: %s\n", message);
        exit(1i32);
    }
};

class ScopeManager {
    pub compiler: void* = null,
    pub builder: LLVMBuilderRef = null,
    pub CompileDestructor: func(void*, QualifiedType*, QualifiedValue),
    pub CompileDestructor2: func(void*, LLVMValueRef, QualifiedType*),
    pub scopes: Vector<Scope*>,
    pub current: Scope* = null
} impl {
    ScopeManager(mut this: ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(mut this: ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(mut this: ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(mut this: ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                let mut i: u64 = 0u64;

                while i < temp->instances.Size() {
                    let instance: QualifiedValue = temp->instances[i];

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        (*this.CompileDestructor2)(this.compiler, instance.Value(), &instance.Type());
                    } i += 1u64;
                }

                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub RegisterInstance(mut this: ScopeManager&, instance: QualifiedValue) {
        if !this.current->global {
            this.current->instances.PushBack(instance);
        } else {
            this.Error("Cannot register instance in global scope.");
            ret;
        }
    }

    pub InvokeDestructors(this: ScopeManager&, except: QualifiedValue) {
        let mut scope: Scope* = this.current;

        while !scope->global {
            let mut i: u64 = 0u64;

            while i < scope->instances.Size() {
                let instance: QualifiedValue = scope->instances[i];

                if instance != except {
                    (*this.CompileDestructor2)(this.compiler, instance.Value(), &instance.Type());
                } i += 1u64;
            } scope = scope->parent;
        }
    }

    pub InvokeDestructors(this: ScopeManager&) {
        let mut scope: Scope* = this.current;

        while !scope->global {
            let mut i: u64 = 0u64;

            while i < scope->instances.Size() {
                let instance: QualifiedValue = scope->instances[i];
                (*this.CompileDestructor2)(this.compiler, instance.Value(), &instance.Type());
                i += 1u64;
            } scope = scope->parent;
        }
    }

    pub Has(this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) {
                ret true;
            } else {
                scope = scope->parent;
            }
        } ret false;
    }

    pub Has(this: ScopeManager&, name: String, kind: SymbolKind) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name, kind) {
                ret true;
            } else {
                scope = scope->parent;
            }
        } ret false;
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, value: QualifiedValue, overload: bool) -> Symbol* {
        ret this.current->Set(name, kind, value, overload);
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, pointer: void*, overload: bool) -> Symbol* {
        ret this.current->Set(name, kind, pointer, overload);
    }

    pub Get(this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) {
                ret scope->Get(name);
            } else {
                scope = scope->parent;
            }
        } ret null;
    }

    pub Get(this: ScopeManager&, name: String, kind: SymbolKind) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name, kind) {
                ret scope->Get(name, kind);
            } else {
                scope = scope->parent;
            }
        } ret null;
    }

    pub Namespaces(this: ScopeManager&) -> Vector<String> {
        let mut scope: Scope* = this.current;
        let mut inverse: Vector<String>;

        while scope->parent != null {
            if scope->global {
                inverse.PushBack(scope->name);
            } scope = scope->parent;
        }

        let mut result: Vector<String>;
        let mut i: u64 = inverse.Size();

        while i > 0u64 {
            result.PushBack(inverse[i - 1u64]);
            i -= 1u64;
        } ret result;
    }

    pub ResolveChild(this: ScopeManager&, scope: Scope*, identifier: IdentifierNode*) -> Scope* {
        let mut i: u64 = 0u64;

        while i < scope->children.Size() {
            if scope->children[i]->name == identifier->name {
                ret scope->children[i];
            } else {
                i += 1u64;
            }
        }

        this.Error((String("Scope '") + identifier->name + "' not found.").Data());
        ret null;
    }

    pub ResolveScopeHalf(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        let mut scope: Scope* = this.current;

        while !scope->global {
            scope = scope->parent;
        }

        if resolution->scope != null {
            if resolution->scope->node_type == ASTNodeType::SCOPE_RESOLUTION {
                scope = this.ResolveScopeFull(resolution->scope as ScopeResolutionNode*);
            } else {
                scope = this.ResolveChild(scope, resolution->scope as IdentifierNode*);
            }
        } else {
            while scope->parent != null {
                scope = scope->parent;
            }
        } ret scope;
    }

    pub ResolveScopeFull(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        ret this.ResolveChild(this.ResolveScopeHalf(resolution), resolution->identifier);
    }

    pub Resolve(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Symbol* {
        let scope: Scope* = this.ResolveScopeHalf(resolution);

        if scope->Has(resolution->identifier->name) {
            ret scope->Get(resolution->identifier->name);
        } else {
            this.Error((String("Symbol '") + resolution->identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, identifier: IdentifierNode*) -> Symbol* {
        if this.Has(identifier->name) {
            ret this.Get(identifier->name);
        } else {
            this.Error((String("Symbol '") + identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, node: ASTNode*) -> Symbol* {
        if node->node_type == ASTNodeType::SCOPE_RESOLUTION {
            ret this.Resolve(node as ScopeResolutionNode*);
        } else if node->node_type == ASTNodeType::IDENTIFIER {
            ret this.Resolve(node as IdentifierNode*);
        } else {
            this.Error((String("Unknown resolution '") + ASTNodeTypeToString(node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: ScopeManager&, message: i8*) {
        printf("Scope manager error: %s\n", message);
        exit(1i32);
    }
};

class Mangler {
    pub prefix: i8* = "$d",
    pub scope_manager: ScopeManager* = null
} impl {
    Mangler(mut this: Mangler&) {}
    ~Mangler(mut this: Mangler&) {}

    priv MangleType(this: Mangler&, _type: QualifiedType*) -> String {
        let kind: LLVMTypeKind = LLVMGetTypeKind(_type->Value());

        if kind == LLVMTypeKind::LLVMVoidTypeKind {
            ret String("v");
        } else if kind == LLVMTypeKind::LLVMPointerTypeKind {
            ret String("P") + this.MangleType(_type->Pointee());
        } else if kind == LLVMTypeKind::LLVMFunctionTypeKind {
            let mut result: String = "F";
            result += this.MangleType(_type->Return());
            let params: Vector<QualifiedType*> = _type->Parameters();
            let mut i: u64 = 0u64;

            while i < params.Size() {
                result += this.MangleType(params[i]);
                i += 1u64;
            } ret result;
        } else if kind == LLVMTypeKind::LLVMStructTypeKind {
            ret String(LLVMGetStructName(_type->Value()));
        } else if kind == LLVMTypeKind::LLVMIntegerTypeKind {
            let width: u32 = LLVMGetIntTypeWidth(_type->Value());
            ret String(width == 1u32 ? "b" : (width == 8u32 ? "c" : (width == 16u32 ? "s" : (width == 32u32 ? "i" : "l"))));
        } else if kind == LLVMTypeKind::LLVMDoubleTypeKind {
            ret String("d");
        } else if kind == LLVMTypeKind::LLVMFloatTypeKind {
            ret String("f");
        } else {
            this.Error((String("Unknown type '") + LLVMTypeToString(_type->Value()) + "'.").Data());
            ret String("");
        }
    }

    priv MangleName(this: Mangler&, name: String) -> String {
        if this.scope_manager == null {
            this.Error("Scope manager not set!");
            ret String("");
        }

        let mut result: String = this.prefix;
        let mut names: Vector<String> = this.scope_manager->Namespaces();
        names.PushBack(name);

        if names.Size() > 1u64 {
            result += "N";
        }

        let mut i: u64 = 0u64;

        while i < names.Size() {
            let length[32]: i8;
            sprintf(length, "%llu", names[i].Size());
            result += length;
            result += names[i];
            i += 1u64;
        }

        if names.Size() > 1u64 {
            result += "E";
        } ret result;
    }

    pub MangleFunction(this: Mangler&, name: String, _type: QualifiedType*) -> String {
        let mut result: String = this.MangleName(name);
        let params: Vector<QualifiedType*> = _type->Parameters();
        let mut j: u64 = 0u64;

        while j < params.Size() {
            result += this.MangleType(params[j]);
            j += 1u64;
        } ret result;
    }

    pub MangleClass(this: Mangler&, name: String) -> String {
        ret this.MangleName(name);
    }

    pub MangleClass(this: Mangler&, name: String, types: Vector<QualifiedType*>) -> String {
        let mut result: String = this.MangleName(name);

        if types.Size() > 0u64 {
            result += "I";
        }

        let mut j: u64 = 0u64;

        while j < types.Size() {
            result += this.MangleType(types[j]);
            j += 1u64;
        }

        if types.Size() > 0u64 {
            result += "E";
        } ret result;
    }

    priv Error(this: Mangler&, message: i8*) {
        printf("Mangler error: %s\n", message);
        exit(1i32);
    }
};

class Generic {
    priv current_generic: Generic** = null,
    priv compiler: void* = null,
    priv CompileClass: func(void*, ClassDeclNode*, Generic*) -> (QualifiedType*),
    priv mangler: Mangler* = null,
    priv scope_manager: ScopeManager* = null,
    priv cache: Map<String, QualifiedType*>,
    priv name: String, pub current: String,
    priv types: Vector<QualifiedType*>,
    priv ast: ClassDeclNode* = null,
    priv scope: Scope* = null
} impl {
    Generic(mut this: Generic&, compiler: void*, mut ast: ClassDeclNode*, mangler: Mangler*, scope_manager: ScopeManager*, generic: Generic**) {
        (this.compiler, this.mangler, this.scope_manager) = (compiler, mangler, scope_manager);
        (this.current_generic, this.scope) = (generic, this.scope_manager->current);
        (this.ast, this.name, ast->generic) = (ast, ast->name, false);
    }

    ~Generic(this: Generic&) {}

    pub Set(mut this: Generic&, _class: QualifiedType*) {
        if this.current != "" {
            this.cache[this.current] = _class;
            this.current = "";
        } else {
            this.Error("Not in a generic compilation.");
            ret;
        }
    }

    pub Get(mut this: Generic&, types: Vector<QualifiedType*>) -> QualifiedType& {
        *this.current_generic = this;
        let scope: Scope* = this.scope_manager->current;
        this.scope_manager->current = this.scope;

        if this.current != "" {
            this.Error("Nested generics are not supported.");
            ret null;
        }

        if types.Size() != this.ast->types.Size() {
            this.Error("Generic type parameter count mismatch.");
            ret null;
        }

        let name: String = this.mangler->MangleClass(this.name, types);

        if this.cache.Has(name) {
            this.scope_manager->current = scope;
            ret this.cache[name];
        } else {
            this.current = name;
            this.types = types;
        }

        let mut i: u64 = 0u64;
        let mut symbols: Vector<Symbol*>;

        while i < this.ast->types.Size() {
            symbols.PushBack(this.scope->Set(this.ast->types[i], SymbolKind::Type, QualifiedValue(null, types[i]), false));
            i += 1u64;
        }

        let mut temp: Generic* = this;
        let _class: QualifiedType* = (*this.CompileClass)(this.compiler, this.ast, temp);
        let mut j: u64 = 0u64;

        while j < symbols.Size() {
            let index: i64 = this.scope->symbols.Index(symbols[j]);

            if index != -1i64 {
                this.scope->symbols.Pop(index as u64);
                del symbols[j];
            } j += 1u64;
        }

        this.types.Clear();
        this.scope_manager->current = scope;
        *this.current_generic = null;
        ret _class;
    }

    priv Error(this: Generic&, message: i8*) {
        printf("Generic error: %s\n", message);
        exit(1i32);
    }
};

class Forward {
    pub _class: QualifiedType*,
    pub generic: Generic* = null,
    pub types: Vector<QualifiedType*>,
    pub decl: FunctionDeclNode*,
    pub _type: QualifiedType*,
    pub value: LLVMValueRef
} impl {
    Forward(mut this: Forward&, decl: FunctionDeclNode*, _type: QualifiedType*, value: LLVMValueRef, _class: QualifiedType*) {
        (this.decl, this._type, this.value, this._class) = (decl, _type, value, _class);
    }

    Forward(mut this: Forward&, decl: FunctionDeclNode*, _type: QualifiedType*, value: LLVMValueRef, _class: QualifiedType*, types: Vector<QualifiedType*>&, generic: Generic*) {
        (this.decl, this._type, this.value, this._class, this.types, this.generic) = (decl, _type, value, _class, types, generic);
    }

    ~Forward(this: Forward&) {}
};

class Compiler {
    priv mangler: Mangler,
    priv mangling: bool = true,
    priv generics: Vector<Generic*>,
    priv type_manager: TypeManager,
    priv generic: Generic* = null,
    priv _class: QualifiedType* = null,
    priv function: QualifiedType* = null,
    priv function_ref: LLVMValueRef = null,
    priv scope_manager: ScopeManager,
    pub include_paths: Vector<String>,
    priv included_paths: Vector<String>,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv forwards: Vector<Forward>,
    pub target_machine: LLVMTargetMachineRef = null,
    priv layout: LLVMTargetDataRef = null,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv target: LLVMTargetRef = null,
    priv triple: i8* = null
} impl {
    Compiler(mut this: Compiler&) {
        LLVMInitializeNativeTarget();
        LLVMInitializeNativeAsmPrinter();
        // LLVMInitializeNativeAsmParser();
        // LLVMInitializeNativeDisassembler();
        this.triple = LLVMGetDefaultTargetTriple();
        this.context = LLVMContextCreate();
        let err: i8* = null;

        if LLVMGetTargetFromTriple(this.triple, &this.target, &err) != 0i32 {
            printf("Failed to get target from triple: %s.\n", err);
            LLVMDisposeMessage(err);
            ret;
        }

        LLVMDisposeMessage(err);
        this.target_machine = LLVMCreateTargetMachine(this.target, this.triple, "generic", "", LLVMCodeGenOptLevel::LLVMCodeGenLevelDefault, LLVMRelocMode::LLVMRelocDefault, LLVMCodeModel::LLVMCodeModelDefault);
        this.layout = LLVMCreateTargetDataLayout(this.target_machine);

        this.scope_manager.compiler = this as void*;
        this.scope_manager.CompileDestructor = Compiler::CompileDestructor as func(void*, QualifiedType*, QualifiedValue);
        this.scope_manager.CompileDestructor2 = Compiler::CompileDestructor2 as func(void*, LLVMValueRef, QualifiedType*);
        this.mangler.scope_manager = &this.scope_manager;
        this.type_manager.current_class = &this._class;
    }

    ~Compiler(mut this: Compiler&) {
        this.mangler.scope_manager = null;
        this.type_manager.current_class = null;
        this.scope_manager.CompileDestructor2 = null;
        this.scope_manager.CompileDestructor = null;
        this.scope_manager.compiler = null;

        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        LLVMDisposeTargetMachine(this.target_machine);
        LLVMContextDispose(this.context);
    }

    pub Forget(mut this: Compiler&) {
        this.module = null;
    }

    pub Compile(mut this: Compiler&, ast: RootNode*, file_name: String&) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        this.builder = LLVMCreateBuilderInContext(this.context);
        this.scope_manager.builder = this.builder;
        LLVMSetSourceFileName(this.module, file_name.Data(), file_name.Size() - 1u64);
        LLVMSetTarget(this.module, this.triple);
        let layout: i8* = LLVMCopyStringRepOfTargetData(this.layout);
        LLVMSetDataLayout(this.module, layout);
        LLVMDisposeMessage(layout);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        this.CompileForwardDeclarations();
        let mut j: u64 = 0u64;

        while j < this.generics.Size() {
            del this.generics[j];
            j += 1u64;
        }

        this.generics.Clear();
        this.included_paths.Clear();
        this.forwards.Clear();
        let err: i8* = null;

        if LLVMVerifyModule(this.module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0i32 {
            printf("Module verification failed: %s.\n", err);
            LLVMDisposeMessage(err);
            ret null;
        }

        LLVMDisposeMessage(err);
        this.scope_manager.builder = null;
        ret this.module;
    }

    priv CompileForwardDeclarations(mut this: Compiler&) {
        let mut i: u64 = 0u64;

        while i < this.forwards.Size() {
            let mut forward: Forward& = this.forwards[i];
            (this.function, this.function_ref) = (forward._type, forward.value);
            let params: Vector<QualifiedType*> = this.function->Parameters();
            let scope: Scope* = this.scope_manager.current;
            this._class = forward._class;

            if forward.generic != null {
                this.scope_manager.current = forward.generic->scope;
            }

            let mut j: u64 = 0u64;
            let mut symbols: Vector<Symbol*>;

            while j < forward.types.Size() {
                symbols.PushBack(forward.generic->scope->Set(forward.generic->ast->types[j], SymbolKind::Type, QualifiedValue(null, forward.types[j]), false));
                j += 1u64;
            }

            this.scope_manager.PushScope(forward.decl->name, false);
            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function_ref, "");
            LLVMPositionBuilderAtEnd(this.builder, entry);
            let mut k: u64 = 0u64;

            while k < forward.decl->_type->parameters.Size() {
                let param: ParameterNode* = forward.decl->_type->parameters[k];
                let index: u64 = params[0u64]->sret != null ? k + 1u64 : k;

                if params[index]->byval != null {
                    this.scope_manager.RegisterInstance(QualifiedValue(LLVMGetParam(this.function_ref, index as u32), this.type_manager.Pointer(params[index]->byval, param->is_mutable)));
                }

                if param->is_mutable {
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, params[index]->Value(), "");

                    LLVMPositionBuilderAtEnd(this.builder, current);
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(pointer, this.type_manager.Pointer(params[index], param->is_mutable)), false);
                    LLVMBuildStore(this.builder, LLVMGetParam(this.function_ref, index as u32), pointer);
                } else {
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(LLVMGetParam(this.function_ref, index as u32), params[index]), false);
                } k += 1u64;
            }

            this.CompileBlock(forward.decl->body);
            this.scope_manager.PopScope();

            if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                let mut state: bool = true;

                if LLVMGetTypeKind(this.function->Return().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                    if params.Size() > 0u64 {
                        state = params[0u64].sret != null;
                    } else {
                        state = false;
                    }
                }

                if !state {
                    LLVMBuildRetVoid(this.builder);
                } else {
                    this.Error((String("Function '") + forward.decl->name + "' must return a value.").Data());
                    ret;
                }
            }

            let mut l: u64 = 0u64;

            while l < symbols.Size() {
                let index: i64 = forward.generic->scope->symbols.Index(symbols[l]);

                if index != -1i64 {
                    forward.generic->scope->symbols.Pop(index as u64);
                    del symbols[l];
                } l += 1u64;
            }

            if forward.generic != null {
                this.scope_manager.current = scope;
            }

            this.function = null;
            this.function_ref = null;
            this._class = null;
            i += 1u64;
        }
    }

    priv CompileDeclaration(mut this: Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::INCLUDE_STMT {
            this.CompileInclude(decl as IncludeStmtNode*);
        } else if decl->node_type == ASTNodeType::CONSTANT_DECL {
            this.CompileConstant(decl as ConstantDeclNode*);
        } else if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::CLASS_DECL {
            this.CompileClass(decl as ClassDeclNode*, null);
        } else if decl->node_type == ASTNodeType::ENUM_DECL {
            this.CompileEnum(decl as EnumDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else if decl->node_type == ASTNodeType::TYPE_DECL {
            let type_decl: TypeDeclNode* = decl as TypeDeclNode*;
            this.scope_manager.Set(type_decl->name, SymbolKind::Type, QualifiedValue(null, this.CompileType(type_decl->_type)), false);
        } else {
            this.Error((String("Unknown declaration '") + ASTNodeTypeToString(decl->node_type) + "'.").Data());
        }
    }

    priv CompileInclude(mut this: Compiler&, include_stmt: IncludeStmtNode*) {
        let mut i: u64 = 0u64;

        while i < include_stmt->modules.Size() {
            let (mut found: bool, mut j: u64) = (false, 0u64);
            let module: String = include_stmt->modules[i];

            while j < this.include_paths.Size() {
                let mut path: String = this.include_paths[j] + "\\" + include_stmt->modules[i];
                let attr: DWORD = GetFileAttributesA(path.Data());
                j += 1u64;

                if attr == INVALID_FILE_ATTRIBUTES {
                    continue;
                }

                if (attr & FILE_ATTRIBUTE_DIRECTORY) != 0u32{
                    path += "\\Entry.div";

                    if GetFileAttributesA(path.Data()) == INVALID_FILE_ATTRIBUTES {
                        this.Error("Module entry point not found.");
                        ret;
                    }
                }

                if this.included_paths.Index(path) != -1i64 {
                    found = true;
                    break;
                }

                let (mut lexer: Lexer, mut parser: Parser);
                let ast: RootNode* = parser.Parse(lexer.Lex(ReadFile(path.Data())));
                let mut k: u64 = 0u64;

                while k < ast->declarations.Size() {
                    let decl: ASTNode* = ast->declarations[k];
                    this.CompileDeclaration(decl);
                    k += 1u64;
                }

                found = true;
                this.included_paths.PushBack(path);
                break;
            }

            if !found {
                this.Error("Module not found.");
                ret;
            } else {
                i += 1u64;
            }
        }
    }

    priv CompileConstant(mut this: Compiler&, constant_decl: ConstantDeclNode*) {
        let _type: QualifiedType& = this.CompileType(constant_decl->var_type);
        let mut initializer: QualifiedValue;

        if constant_decl->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
            initializer = this.CompileExpression(constant_decl->initializer, false);
        } else {
            let mut values: Vector<LLVMValueRef>;
            let initializer_list: InitializerListNode* = constant_decl->initializer as InitializerListNode*;
            let fields: Map<String, Pair<Field, QualifiedType*>> = _type.Fields();
            let mut i: u64 = 0u64;

            while i < fields.Size() {
                if i < initializer_list->expressions.Size() {
                    values.PushBack(this.CompileExpression(initializer_list->expressions[i], false).Value());
                } else {
                    if fields[i].right.left.initializer != null {
                        values.PushBack(this.CompileExpression(fields[i].right.left.initializer, false).Value());
                    } else {
                        this.Error((String("Missing initializer for field '") + fields[i].left + "'.").Data());
                        ret;
                    }
                } i += 1u64;
            }

            initializer = QualifiedValue(LLVMConstNamedStruct(_type.Value(), values.Data(), values.Size() as u32), _type);
        }

        if initializer.Type() != _type {
            this.Error((String("Incompatible constant initialization types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
            ret;
        }

        let global: LLVMValueRef = LLVMAddGlobal(this.module, _type.Value(), constant_decl->name.Data());
        this.scope_manager.Set(constant_decl->name, SymbolKind::Variable, QualifiedValue(global, this.type_manager.Pointer(_type, false)), false);
        LLVMSetLinkage(global, LLVMLinkage::LLVMPrivateLinkage);
        LLVMSetInitializer(global, initializer.Value());
        LLVMSetGlobalConstant(global, 1i32);
    }

    priv ProcessType(mut this: Compiler&, _type: QualifiedType*) -> QualifiedType* {
        if LLVMGetTypeKind(_type->Value()) != LLVMTypeKind::LLVMStructTypeKind {
            ret _type;
        } else {
            let size: u64 = LLVMABISizeOfType(this.layout, _type->Value());

            if size > 8u64 {
                ret this.type_manager.Pointer(_type, _type->IsMutable());
            } else {
                if size > 4u64 {
                    ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), true);
                } else if size > 2u64 {
                    ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), true);
                } else if size > 1u64 {
                    ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), true);
                } else {
                    ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true);
                }
            }
        }
    }

    priv CompileFunction(mut this: Compiler&, func_decl: FunctionDeclNode*) -> QualifiedValue {
        if func_decl->generic {
            this.Error("Generic functions are not supported yet.");
            ret QualifiedValue(null, null);
        }

        let (mut params: Vector<QualifiedType*>, mut param_types: Vector<LLVMTypeRef>);
        let mut return_type: QualifiedType* = this.CompileType(func_decl->_type->return_type);
        let mut attributes: Vector<LLVMTypeRef>;
        let mut sret: bool = false;

        if LLVMGetTypeKind(return_type->Value()) == LLVMTypeKind::LLVMStructTypeKind {
            let mut processed_type: QualifiedType& = this.ProcessType(return_type);
            processed_type.sret = return_type;

            if LLVMGetTypeKind(processed_type.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                return_type = processed_type;
            } else {
                params.PushBack(processed_type);
                param_types.PushBack(processed_type.Value());
                attributes.PushBack(return_type->Value());
                return_type = this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
                sret = true;
            }
        }

        let mut i: u64 = 0u64;

        while i < func_decl->_type->parameters.Size() {
            let param: ParameterNode* = func_decl->_type->parameters[i];
            let real_type: QualifiedType& = this.CompileType(param->param_type);
            let mut processed_type: QualifiedType& = this.ProcessType(real_type);
            param_types.PushBack(processed_type.Value());
            params.PushBack(processed_type);

            if real_type != processed_type {
                attributes.PushBack(LLVMGetTypeKind(processed_type.Value()) == LLVMTypeKind::LLVMPointerTypeKind ? real_type.Value() : null);
                processed_type.byval = real_type;
            } else {
                attributes.PushBack(null);
            } i += 1u64;
        }

        let mut name: String = func_decl->name;
        let type_ref: LLVMTypeRef = LLVMFunctionType(return_type->Value(), param_types.Data(), param_types.Size() as u32, func_decl->_type->var_arg ? 1i32 : 0i32);
        let mut _type: QualifiedType& = this.type_manager.Function(type_ref, params, return_type);
        let mangling: bool = this.mangling && name != "main";
        _type->name = name;

        if mangling {
            name = this.mangler.MangleFunction(func_decl->name, _type);
        }

        let function: LLVMValueRef = LLVMAddFunction(this.module, name.Data(), _type->Value());
        let value: QualifiedValue = QualifiedValue(function, this.type_manager.Pointer(_type, false));
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, value, mangling);
        let mut j: u64 = 0u64;

        while j < attributes.Size() {
            if attributes[j] != null {
                let attribute_kind: u32 = sret && j == 0u64 ? LLVMGetEnumAttributeKindForName("sret", 4u64) : LLVMGetEnumAttributeKindForName("byval", 5u64);
                LLVMAddAttributeAtIndex(function, (j + 1u64) as u32, LLVMCreateTypeAttribute(this.context, attribute_kind, attributes[j]));
            } j += 1u64;
        }

        if func_decl->body != null {
            if this.generic != null {
                this.forwards.PushBack(Forward(func_decl, _type, function, this._class, this.generic->types, this.generic));
            } else {
                this.forwards.PushBack(Forward(func_decl, _type, function, this._class));
            }
        } ret value;
    }

    priv ValueToType(mut this: Compiler&, values: Vector<QualifiedValue>) -> Vector<QualifiedType*> {
        let mut result: Vector<QualifiedType*>;
        let mut i: u64 = 0u64;

        while i < values.Size() {
            result.PushBack(values[i].Type());
            i += 1u64;
        } ret result;
    }

    priv CompileConstructor(mut this: Compiler&, _class: QualifiedType&, pointer: QualifiedValue, params: Vector<QualifiedValue>) {
        let mut need_copy: bool = false;

        if params.Size() == 1u64 {
            if params[0u64].Type().IsPointer() {
                need_copy = params[0u64].Type().Pointee() == _class;
            }
        }

        let param_types: Vector<QualifiedType*> = this.ValueToType(params);
        let is_constructed: bool = false; // _class.constructed.Index(_class.name) != -1i64;
        let has_constructor: bool = _class.Has(_class.name, param_types);

        let mut i: u64 = 0u64;
        let fields: Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();

        while i < fields.Size() {
            let field: Pair<String, Pair<Field, QualifiedType*>>& = fields[i];
            let mut value: QualifiedValue;

            if !(has_constructor && !is_constructed) && i < params.Size() {
                value = params[i];
            } else {
                if field.right.left.initializer != null {
                    value = this.CompileExpression(field.right.left.initializer, false);
                } else {
                    value = QualifiedValue(null, field.right.right);
                }
            }

            if need_copy && !(has_constructor && !is_constructed) {
                value = QualifiedValue(LLVMBuildStructGEP2(this.builder, params[0u64].Type().Pointee().Value(), params[0u64].Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true));
            }

            if field.right.right->IsClass() {
                let mut _params: Vector<QualifiedValue>;
                if !value.Null() { _params.PushBack(value); }
                this.CompileConstructor(field.right.right, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)), _params);
            } else if !value.Null() {
                if value.Type().IsPointer() {
                    let pointee: QualifiedType& = value.Type().Pointee();

                    if pointee == field.right.right {
                        value = QualifiedValue(LLVMBuildLoad2(this.builder, pointee.Value(), value.Value(), ""), pointee);
                    }
                }

                this.CompileAssignment2(value, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)), TokenType::ASSIGN, true);
            } i += 1u64;
        }

        if has_constructor && !is_constructed {
            let param_types: Vector<QualifiedType*> = this.ValueToType(params);

            if _class.Has(_class.name, param_types) {
                let method: Pair<Method, QualifiedType*>& = _class.Get(_class.name, param_types);
                this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, true);
            } else {
                this.Error("Class doesn't have compatible constructor.");
            }
        } else {
            if params.Size() > fields.Size() {
                this.Error("Too many parameters.");
            }
        }
    }

    priv CompileDestructor(mut this: Compiler&, _class: QualifiedType&, pointer: QualifiedValue) {
        let (params: Vector<QualifiedValue>, params_types: Vector<QualifiedType*>);

        if _class.Has(String("~") + _class.name, params_types) {
            let method: Pair<Method, QualifiedType*>& = _class.Get(String("~") + _class.name, params_types);
            this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, true);
        }

        let fields: Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();
        let mut i: u64 = 0u64;

        while i < fields.Size() {
            let field: Pair<String, Pair<Field, QualifiedType*>>& = fields[i];

            if field.right.right->IsClass() {
                this.CompileDestructor(field.right.right, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)));
            } i += 1u64;
        }
    }

    priv CompileDestructor2(mut this: Compiler&, value: LLVMValueRef, _type: QualifiedType*) {
        this.CompileDestructor(_type->Pointee(), QualifiedValue(value, _type));
    }

    priv CompileClass(mut this: Compiler&, class_decl: ClassDeclNode*, mut generic: Generic*) -> QualifiedType* {
        if class_decl->generic {
            if generic != null {
                this.Error("Nested generics are not supported.");
                ret null;
            }

            let mut _generic: Generic* = new Generic(this as void*, class_decl, &this.mangler, &this.scope_manager, &this.generic);
            _generic->CompileClass = Compiler::CompileClass as func(void*, ClassDeclNode*, Generic*) -> (QualifiedType*);
            this.scope_manager.Set(class_decl->name, SymbolKind::Generic, _generic as void*, false);
            this.generics.PushBack(_generic);
            ret null;
        }

        let mut struct_name: i8* = class_decl->name.Data();
        if generic != null { struct_name = generic->current.Data(); }
        let mut _class: QualifiedType& = this.type_manager.Class(LLVMStructCreateNamed(this.context, struct_name), class_decl->name);

        if generic != null { generic->Set(_class); } else {
            this.scope_manager.Set(class_decl->name, SymbolKind::Class, QualifiedValue(null, _class), false);
        }

        let mut i: u64 = 0u64;
        let mut field_types: Vector<LLVMTypeRef>;

        while i < class_decl->fields.Size() {
            let field: Pair<TokenType, FieldNode*>& = class_decl->fields[i];
            let field_type: QualifiedType& = this.CompileType(field.right->field_type);
            _class.fields[field.right->name] = Pair<Field, QualifiedType*>(Field(field.right->initializer, field.left), field_type);
            field_types.PushBack(field_type.Value());
            i += 1u64;
        }

        this._class = _class;
        LLVMStructSetBody(_class.Value(), field_types.Data(), field_types.Size() as u32, 0i32);
        this.scope_manager.PushScope(class_decl->name, true);
        let (mut j: u64, mut k: u64) = (0u64, 0u64);

        while j < class_decl->constructors.Size() {
            let method: QualifiedValue = this.CompileFunction(class_decl->constructors[j]);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->constructors[j]->name, method.Value(), TokenType::PUBLIC), method.Type()));
            j += 1u64;
        }

        if class_decl->destructor != null {
            let method: QualifiedValue = this.CompileFunction(class_decl->destructor);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->destructor->name, method.Value(), TokenType::PUBLIC), method.Type()));
        }

        while k < class_decl->methods.Size() {
            let method: QualifiedValue = this.CompileFunction(class_decl->methods[k].right);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->methods[k].right->name, method.Value(), class_decl->methods[k].left), method.Type()));
            k += 1u64;
        }

        this.scope_manager.PopScope();
        this._class = null;
        ret _class;
    }

    priv CompileEnum(mut this: Compiler&, enum_decl: EnumDeclNode*) {
        let underlying_type: QualifiedType& = this.CompileType(enum_decl->underlying_type);

        if LLVMGetTypeKind(underlying_type.Value()) != LLVMTypeKind::LLVMIntegerTypeKind {
            this.Error("Expected an integer type.");
            ret;
        }

        this.scope_manager.Set(enum_decl->name, SymbolKind::Type, QualifiedValue(null, underlying_type), false);
        let mut value: LLVMValueRef = LLVMConstInt(underlying_type.Value(), 0u64, underlying_type.IsSigned() ? 1i32 : 0i32);
        this.scope_manager.PushScope(enum_decl->name, true);
        let mut i: u64 = 0u64;

        while i < enum_decl->values.Size() {
            if enum_decl->values[i].right != null {
                let _value: QualifiedValue = this.CompileExpression(enum_decl->values[i].right, false);

                if _value.Type() == underlying_type {
                    value = _value.Value();
                } else {
                    this.Error((String("Incompatible enum value types. ('") + LLVMTypeToString(_value.Type().Value()) + "' != '" + LLVMTypeToString(underlying_type.Value()) + "').").Data());
                    ret;
                }
            }

            this.scope_manager.Set(enum_decl->values[i].left, SymbolKind::Constant, QualifiedValue(value, underlying_type), false);
            value = LLVMConstAdd(value, LLVMConstInt(underlying_type.Value(), 1u64, underlying_type.IsSigned() ? 1i32 : 0i32));
            i += 1u64;
        }

        this.scope_manager.PopScope();
    }

    priv CompileExtern(mut this: Compiler&, extern_block: ExternBlockNode*) {
        if !this.mangling {
            this.Error("Already in a extern block.");
            ret;
        }

        if extern_block->linkage != "C" {
            this.Error((String("Unknown linkage '") + extern_block->linkage + "'.").Data());
            ret;
        }

        this.mangling = false;
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        this.mangling = true;
    }

    priv CompileBlock(mut this: Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(mut this: Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            this.CompileReturn(stmt as ReturnStmtNode*);
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression, false);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement '") + ASTNodeTypeToString(stmt->node_type) + "'.").Data());
        }
    }

    priv CompileReturn(mut this: Compiler&, ret_stmt: ReturnStmtNode*) {
        if ret_stmt->value != null {
            let params: Vector<QualifiedType*> = this.function->Parameters();
            let mut state: bool = false;

            if params.Size() > 0u64 {
                state = params[0u64].sret != null;
            }

            if state || this.function->Return().sret != null {
                let value: QualifiedValue = this.CompileExpression(ret_stmt->value, true);
                let return: LLVMTypeRef = this.function->Return().Value();

                if LLVMGetTypeKind(return) == LLVMTypeKind::LLVMIntegerTypeKind {
                    this.scope_manager.InvokeDestructors(value);
                    LLVMBuildRet(this.builder, LLVMBuildLoad2(this.builder, return, value.Value(), ""));
                } else {
                    let mut _params: Vector<QualifiedValue>;
                    _params.PushBack(value);
                    this.CompileConstructor(value.Type().Pointee(), QualifiedValue(LLVMGetParam(this.function_ref, 0u32), params[0u64]), _params);
                    this.scope_manager.InvokeDestructors(value);
                    LLVMBuildRetVoid(this.builder);
                }
            } else {
                let value: QualifiedValue = this.CompileExpression(ret_stmt->value, this.function->Return().IsReference());
                this.scope_manager.InvokeDestructors();
                LLVMBuildRet(this.builder, value.Value());
            }
        } else {
            this.scope_manager.InvokeDestructors();
            LLVMBuildRetVoid(this.builder);
        }
    }

    priv CompileIf(mut this: Compiler&, if_stmt: IfStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let (mut current: IfStmtNode*, mut end_block: LLVMBasicBlockRef) = (if_stmt, null);

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement '") + ASTNodeTypeToString(else_stmt->node_type) + "'.").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } then_block = end_block;
            }

            let mut else_block: LLVMBasicBlockRef;

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } else_block = end_block;
            }

            let condition: QualifiedValue = this.CompileExpression(current->condition, false);
            LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(mut this: Compiler&, while_stmt: WhileStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));

        LLVMBuildBr(this.builder, compare_block);
        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: QualifiedValue = this.CompileExpression(while_stmt->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->body as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        // this.scope_manager.InvokeDestructors();
        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        // this.scope_manager.InvokeDestructors();
        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(mut this: Compiler&, variable: VariableDeclNode*) {
        let _type: QualifiedType& = this.CompileType(variable->var_type);
        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
        let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, _type.Value(), "");
        this.scope_manager.Set(variable->name, SymbolKind::Variable, QualifiedValue(pointer, this.type_manager.Pointer(_type, variable->is_mutable)), false);
        LLVMPositionBuilderAtEnd(this.builder, current);

        if _type.IsClass() {
            let mut params: Vector<QualifiedValue>;

            if variable->initializer != null {
                if variable->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
                    params.PushBack(this.CompileExpression(variable->initializer, true));
                } else {
                    let initializer_list: InitializerListNode* = variable->initializer as InitializerListNode*;
                    let mut i: u64 = 0u64;

                    while i < initializer_list->expressions.Size() {
                        params.PushBack(this.CompileExpression(initializer_list->expressions[i], false));
                        i += 1u64;
                    }
                }
            }

            let instance: QualifiedValue = QualifiedValue(pointer, this.type_manager.Pointer(_type, false));
            this.CompileConstructor(_type, instance, params);
            this.scope_manager.RegisterInstance(instance);
        } else if variable->initializer != null {
            let initializer: QualifiedValue = this.CompileExpression(variable->initializer, _type.IsReference());

            if initializer.Type() != _type {
                this.Error((String("Incompatible variable initialization types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
                ret;
            }

            LLVMBuildStore(this.builder, initializer.Value(), pointer);
        }

        if variable->next != null {
            this.CompileVariable(variable->next);
        }
    }

    priv CompileAssignment(mut this: Compiler&, assignment: AssignmentNode*) -> QualifiedValue {
        let pointer: QualifiedValue = this.CompileExpression(assignment->left, true);
        let mut value: QualifiedValue = this.CompileExpression(assignment->right, false);
        value = this.CompileAssignment2(value, pointer, assignment->operator, false);

        if assignment->next != null {
            this.CompileAssignment(assignment->next);
            ret QualifiedValue(null, null);
        } else {
            ret value;
        }
    }

    priv CompileAssignment2(mut this: Compiler&, mut value: QualifiedValue, mut pointer: QualifiedValue, operator: TokenType, ignore: bool) -> QualifiedValue {
        if pointer.Type().Pointee().IsReference() {
            pointer = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
        }

        if !pointer.Type().IsMutable() && !ignore {
            this.Error("Cannot assign to immutable variable.");
            ret QualifiedValue(null, null);
        }

        if pointer.Type().Pointee().IsClass() {
            let mut params: Vector<QualifiedValue>;
            params.PushBack(value);

            let _class: QualifiedType& = pointer.Type().Pointee();
            let param_types: Vector<QualifiedType*> = this.ValueToType(params);

            if _class.Has(String("op="), param_types) && operator == TokenType::ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op+="), param_types) && operator == TokenType::PLUS_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op+="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op-="), param_types) && operator == TokenType::MINUS_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op-="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op*="), param_types) && operator == TokenType::MUL_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op*="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op/="), param_types) && operator == TokenType::DIV_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op/="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op%="), param_types) && operator == TokenType::MOD_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op%="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op&="), param_types) && operator == TokenType::AND_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op&="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op|="), param_types) && operator == TokenType::OR_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op|="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op^="), param_types) && operator == TokenType::XOR_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op^="), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op<<"), param_types) && operator == TokenType::LSHIFT_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op<<"), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if _class.Has(String("op>>"), param_types) && operator == TokenType::RSHIFT_ASSIGN {
                let method: Pair<Method, QualifiedType*>& = _class.Get(String("op>>"), param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            } else if value.Type() == _class && operator == TokenType::ASSIGN {
                let fields: Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();
                value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), true));
                let mut i: u64 = 0u64;

                while i < fields.Size() {
                    let field: Pair<String, Pair<Field, QualifiedType*>>& = fields[i];
                    let _value: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, field.right.right->Value(), LLVMBuildStructGEP2(this.builder, value.Type().Pointee().Value(), value.Value(), _class.Index(field.left) as u32, ""), ""), field.right.right);
                    let _pointer: QualifiedValue = QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true));
                    this.CompileAssignment2(_value, _pointer, operator, ignore);
                    i += 1u64;
                }
            } else {
                this.Error((String("Incompatible class assignment types. ('") + LLVMTypeToString(_class.Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            if operator != TokenType::ASSIGN {
                let other: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
                let (value_kind: LLVMTypeKind, other_kind: LLVMTypeKind) = (LLVMGetTypeKind(pointer.Type().Pointee().Value()), LLVMGetTypeKind(value.Type().Value()));

                if value.Type().IsPointer() && other.Type().IsPointer() {
                    if operator == TokenType::MINUS_ASSIGN {
                        let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false);
                        value = QualifiedValue(LLVMBuildSub(this.builder, LLVMBuildPtrToInt(this.builder, other.Value(), _type.Value(), ""), LLVMBuildPtrToInt(this.builder, value.Value(), _type.Value(), ""), ""), _type);
                    } else {
                        this.Error((String("Invalid pointer assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if (value.Type().IsPointer() && other_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (value_kind == LLVMTypeKind::LLVMIntegerTypeKind && other.Type().IsPointer()) {
                    let ptr: QualifiedValue = value.Type().IsPointer() ? value : other;
                    let index: QualifiedValue = value.Type().IsPointer() ? other : value;
                    let width: u32 = LLVMGetIntTypeWidth(index.Type().Value());

                    if width == 64u32 {
                        if operator == TokenType::PLUS_ASSIGN {
                            let indices[]: LLVMValueRef = { index.Value() };
                            value = QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                        } else if operator == TokenType::MINUS_ASSIGN {
                            let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), "") };
                            value = QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                        } else {
                            this.Error((String("Invalid pointer assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(ptr.Type().Value()) + "'.").Data());
                            ret QualifiedValue(null, null);
                        }
                    } else {
                        this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind && other_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type() != other.Type() {
                        this.Error((String("Incompatible assignment operation types. ('") + LLVMTypeToString(value.Type().Value()) + "' != '" + LLVMTypeToString(other.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    if operator == TokenType::PLUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildAdd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MINUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildSub(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MUL_ASSIGN {
                        value = QualifiedValue(LLVMBuildMul(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::DIV_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildSDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildUDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else if operator == TokenType::MOD_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildSRem(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildURem(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else if operator == TokenType::AND_ASSIGN {
                        value = QualifiedValue(LLVMBuildAnd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::OR_ASSIGN {
                        value = QualifiedValue(LLVMBuildOr(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::XOR_ASSIGN {
                        value = QualifiedValue(LLVMBuildXor(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::LSHIFT_ASSIGN {
                        value = QualifiedValue(LLVMBuildShl(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::RSHIFT_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildAShr(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildLShr(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else {
                        this.Error((String("Invalid assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if (value_kind == LLVMTypeKind::LLVMFloatTypeKind || value_kind == LLVMTypeKind::LLVMDoubleTypeKind) && (other_kind == LLVMTypeKind::LLVMFloatTypeKind || other_kind == LLVMTypeKind::LLVMDoubleTypeKind) {
                    if value.Type() != other.Type() {
                        this.Error((String("Incompatible assignment operation types. ('") + LLVMTypeToString(value.Type().Value()) + "' != '" + LLVMTypeToString(other.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    if operator == TokenType::PLUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildFAdd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MINUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildFSub(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MUL_ASSIGN {
                        value = QualifiedValue(LLVMBuildFMul(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::DIV_ASSIGN {
                        value = QualifiedValue(LLVMBuildFDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MOD_ASSIGN {
                        value = QualifiedValue(LLVMBuildFRem(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else {
                        this.Error((String("Invalid assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Invalid type '") + LLVMTypeToString(value.Type().Value()) + "' for assignment operation '" + TokenTypeToString(operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            }

            if value.Type() != pointer.Type().Pointee() && !(LLVMIsAConstantPointerNull(value.Value()) != null && pointer.Type().Pointee().IsPointer()) {
                this.Error((String("Incompatible assignment types. ('") + LLVMTypeToString(pointer.Type().Pointee().Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            LLVMBuildStore(this.builder, value.Value(), pointer.Value());
        } ret pointer;
    }

    priv CompileExpression(mut this: Compiler&, expr: ASTNode*, pointer: bool) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            if !pointer {
                ret this.CompileLiteral(expr as LiteralNode*);
            } else {
                this.Error("Invalid pointer literal expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CALL {
            let value: QualifiedValue = this.CompileCall(expr as CallNode*, pointer);

            if !pointer || (pointer && value.Type().IsPointer()) {
                ret value;
            } else {
                this.Error("Invalid pointer call expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::TERNARY {
            ret this.CompileTernary(expr as TernaryNode*, pointer);
        } else if expr->node_type == ASTNodeType::IDENTIFIER || expr->node_type == ASTNodeType::SCOPE_RESOLUTION {
            let symbol: Symbol* = this.scope_manager.Resolve(expr);

            if (symbol->kind == SymbolKind::Variable || symbol->kind == SymbolKind::Constant || symbol->kind == SymbolKind::Parameter) && !pointer {
                if symbol->kind == SymbolKind::Constant || (symbol->kind == SymbolKind::Parameter && !symbol->value.Type().IsMutable()) {
                    ret symbol->value;
                } else {
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, symbol->value.Type().Pointee().Value(), symbol->value.Value(), ""), symbol->value.Type().Pointee());
                }
            } else if symbol->kind == SymbolKind::Function || pointer {
                ret symbol->value;
            } else {
                this.Error((String("Invalid symbol kind '") + SymbolKindToString(symbol->kind) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::NEW {
            ret this.CompileNew(expr as NewNode*);
        } else if expr->node_type == ASTNodeType::DELETE {
            ret this.CompileDelete(expr as DeleteNode*);
        } else if expr->node_type == ASTNodeType::CAST {
            let value: QualifiedValue = this.CompileCast(expr as CastNode*, pointer);

            if !pointer || (pointer && value.Type().IsPointer()) {
                ret value;
            } else {
                this.Error("Invalid pointer cast expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::INDEX_ACCESS {
            ret this.CompileIndexAccess(expr as IndexAccessNode*, pointer);
        } else if expr->node_type == ASTNodeType::MEMBER_ACCESS {
            ret this.CompileMemberAccess(expr as MemberAccessNode*, pointer);
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompileUnaryOperation(expr as UnaryOpNode*, pointer);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            if !pointer {
                ret this.CompileBinaryOperation(expr as BinaryOpNode*);
            } else {
                this.Error("Invalid pointer binary expression.");
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Unknown expression '") + ASTNodeTypeToString(expr->node_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileLiteral(mut this: Compiler&, literal: LiteralNode*) -> QualifiedValue {
        if literal->literal_type == TokenType::INTEGER {
            let (mut state: bool, mut base: i32) = (false, 10i32);
            let (mut signed: bool, mut width: u64) = (true, 32u64);
            let (mut value: String, mut size: String);
            let mut i: u64 = 0u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == '0' && (literal->value[i + 1u64] == 'x' || literal->value[i + 1u64] == 'o' || literal->value[i + 1u64] == 'b') {
                        if i != 0u64 || base != 10i32 {
                            this.Error((String("Invalid integer '") + literal->value + "'.").Data());
                            ret QualifiedValue(null, null);
                        } else {
                            base = literal->value[i + 1u64] == 'x' ? 16i32 : (literal->value[i + 1u64] == 'o' ? 8i32 : 2i32);
                        } i += 1u64;
                    } else if literal->value[i] == 'u' {
                        (signed, state) = (false, true);
                    } else if literal->value[i] == 'i' {
                        (signed, state) = (true, true);
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 128u64 {
                _type = LLVMInt128TypeInContext(this.context);
            } else if width == 64u64 {
                _type = LLVMInt64TypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMInt32TypeInContext(this.context);
            } else if width == 16u64 {
                _type = LLVMInt16TypeInContext(this.context);
            } else if width == 8u64 {
                _type = LLVMInt8TypeInContext(this.context);
            } else {
                this.Error((String("Invalid integer size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstInt(_type, value.ToInteger(base) as u64, signed ? 1i32 : 0i32), this.type_manager.Primitive(_type, signed));
        } else if literal->literal_type == TokenType::FLOAT {
            let (mut state: bool, mut i: u64) = (false, 0u64);
            let (mut value: String, mut size: String);
            let mut width: u64 = 32u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == 'f' {
                        state = true;
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 64u64 {
                _type = LLVMDoubleTypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMFloatTypeInContext(this.context);
            } else {
                this.Error((String("Invalid float size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstReal(_type, value.ToFloat()), this.type_manager.Primitive(_type, false));
        } else if literal->literal_type == TokenType::TRUE || literal->literal_type == TokenType::FALSE {
            let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            ret QualifiedValue(LLVMConstInt(_type.Value(), literal->literal_type == TokenType::TRUE ? 1u64 : 0u64, 0i32), _type);
        } else if literal->literal_type == TokenType::STRING {
            let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "");
            ret QualifiedValue(value, this.type_manager.Pointer(this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true), false));
        } else if literal->literal_type == TokenType::CHAR {
            let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true);
            ret QualifiedValue(LLVMConstInt(_type.Value(), literal->value[0u64] as u64, 0i32), _type);
        } else if literal->literal_type == TokenType::NULL {
            let _type: QualifiedType& = this.type_manager.Pointer(this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false), false);
            ret QualifiedValue(LLVMConstNull(_type.Value()), _type);
        } else {
            this.Error((String("Unknown literal type '") + TokenTypeToString(literal->literal_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileCall(mut this: Compiler&, call: CallNode*, pointer: bool) -> QualifiedValue {
        let mut values: Vector<QualifiedValue>;
        let mut i: u64 = 0u64;

        while i < call->arguments.Size() {
            values.PushBack(this.CompileExpression(call->arguments[i], false));
            i += 1u64;
        }

        ret this.CompileCall2(this.CompileExpression(call->function, true), values, pointer, false);
    }

    priv CompileCall2(mut this: Compiler&, _func: QualifiedValue, values: Vector<QualifiedValue>&, pointer: bool, ignore: bool) -> QualifiedValue {
        let mut args: Vector<LLVMValueRef>;
        let ret_type: QualifiedType& = _func.Type().Pointee().Return();
        let params: Vector<QualifiedType*> = _func.Type().Pointee().Parameters();
        let mut return: QualifiedValue = QualifiedValue(null, null);
        let mut i: u64 = 0u64;

        if _func.instance != null {
            let mut param: QualifiedType* = params[0u64];

            if param->sret != null {
                param = params[1u64];
            }

            if param->IsMutable() && !_func.instance_type->Pointee().IsMutable() && !ignore {
                this.Error((String("Cannot call mutable method '") + _func.Type().Pointee().name + "' on immutable instance.").Data());
                ret QualifiedValue(null, null);
            } else {
                args.PushBack(_func.instance);
            }
        }

        if params.Size() > 0u64 {
            if params[0u64]->sret != null {
                let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, params[0u64]->sret->Value(), "");
                return = QualifiedValue(_pointer, this.type_manager.Pointer(params[0u64]->sret, true), true);
                LLVMPositionBuilderAtEnd(this.builder, current);
                this.scope_manager.RegisterInstance(return);
                args.PushBack(return.Value());
            }
        }

        while i < values.Size() {
            let mut value: QualifiedValue = values[i];
            let mut index: u64 = params[0u64]->sret != null ? i + 1u64 : i;

            if _func.instance != null {
                index += 1u64;
            }

            if index < params.Size() {
                if params[index]->byval != null {
                    let mut _params: Vector<QualifiedValue>;
                    value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
                    _params.PushBack(value);
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, value.Type().Pointee().Value(), "");
                    LLVMPositionBuilderAtEnd(this.builder, current);
                    value = QualifiedValue(pointer, value.Type());
                    this.CompileConstructor(value.Type().Pointee(), value, _params);

                    if LLVMGetTypeKind(params[index]->Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                        args.PushBack(LLVMBuildLoad2(this.builder, params[index]->Value(), value.Value(), ""));
                    } else {
                        args.PushBack(value.Value());
                    }
                } else {
                    let param: QualifiedType& = params[index];

                    if param.IsReference() && param != value.Type() {
                        value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), true));
                    }

                    args.PushBack(value.Value());
                }
            } else {
                args.PushBack(value.Value());
            } i += 1u64;
        }

        let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.Type().Pointee().Value(), _func.Value(), args.Data(), args.Size() as u32, "");

        if ret_type.sret != null {
            let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, ret_type.sret->Value(), "");
            return = QualifiedValue(_pointer, this.type_manager.Pointer(ret_type.sret, true), true);
            LLVMPositionBuilderAtEnd(this.builder, current);
            LLVMBuildStore(this.builder, value, LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(ret_type.Value(), 0u32), ""));
            this.scope_manager.RegisterInstance(return);
        }

        if return.Null() {
            ret QualifiedValue(value, ret_type);
        } else {
            if !pointer {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, return.Type().Pointee().Value(), return.Value(), ""), return.Type().Pointee());
            } else {
                ret return;
            }
        }
    }

    priv CompileTernary(mut this: Compiler&, ternary: TernaryNode*, pointer: bool) -> QualifiedValue {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let then_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let else_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let merge_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

        let condition: QualifiedValue = this.CompileExpression(ternary->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

        LLVMPositionBuilderAtEnd(this.builder, then_block);
        let then_value: QualifiedValue = this.CompileExpression(ternary->then_expr, pointer);
        LLVMBuildBr(this.builder, merge_block);

        LLVMPositionBuilderAtEnd(this.builder, else_block);
        let else_value: QualifiedValue = this.CompileExpression(ternary->else_expr, pointer);
        LLVMBuildBr(this.builder, merge_block);

        if then_value.Type() != else_value.Type() {
            this.Error((String("Incompatible ternary types. ('") + LLVMTypeToString(then_value.Type().Value()) + "' != '" + LLVMTypeToString(else_value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        LLVMPositionBuilderAtEnd(this.builder, merge_block);
        let value: LLVMValueRef = LLVMBuildPhi(this.builder, then_value.Type().Value(), "");

        let blocks[]: LLVMBasicBlockRef = { then_block, else_block };
        let values[]: LLVMValueRef = { then_value.Value(), else_value.Value() };
        LLVMAddIncoming(value, values, blocks, 2u32);

        ret QualifiedValue(value, then_value.Type());
    }

    priv CompileIndexAccess(mut this: Compiler&, index_access: IndexAccessNode*, pointer: bool) -> QualifiedValue {
        let mut value: QualifiedValue = this.CompileExpression(index_access->expression, false);
        let index: QualifiedValue = this.CompileExpression(index_access->index, false);

        if value.Type().IsClass() {
            let mut params: Vector<QualifiedValue>;
            value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
            params.PushBack(index);

            let method: Pair<Method, QualifiedType*>& = value.Type().Pointee().Get(String("op[]"), this.ValueToType(params));
            ret this.CompileCall2(QualifiedValue(method.left.value, method.right, value), params, pointer, false);
        }

        if !value.Type().IsPointer() {
            this.Error("Index access value must be a pointer.");
            ret QualifiedValue(null, null);
        }

        let indices[]: LLVMValueRef = { index.Value() };
        let target_pointer: LLVMValueRef = LLVMBuildGEP2(this.builder, value.Type().Pointee().Value(), value.Value(), indices, 1u32, "");

        if !pointer {
            ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), target_pointer, ""), value.Type().Pointee());
        } else {
            ret QualifiedValue(target_pointer, value.Type());
        }
    }

    priv CompileMemberAccess(mut this: Compiler&, member_access: MemberAccessNode*, pointer: bool) -> QualifiedValue {
        let mut instance: QualifiedValue = this.CompileExpression(member_access->expression, true);

        if instance.Type().Pointee().IsReference() {
            instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee());
        }

        if member_access->arrow {
            instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee());

            if !instance.Type().IsPointer() {
                this.Error("Member access value must be a pointer.");
                ret QualifiedValue(null, null);
            }
        }

        if !instance.Type().Pointee().IsClass() {
            this.Error((String("Cannot access member '") + member_access->member + "' of non-class type.").Data());
            ret QualifiedValue(null, null);
        }

        let mut state: bool = true;
        let index: i64 = instance.Type().Pointee().Index(member_access->member);
        if this._class != null { state = (*this._class) != instance.Type().Pointee(); }

        if index == -1i64 {
            if instance.Type().Pointee().Has(member_access->member) {
                let value: Pair<Method, QualifiedType*>& = instance.Type().Pointee().Get(member_access->member);

                if value.left.visibility != TokenType::PUBLIC && state {
                    this.Error((String("Method '") + member_access->member + "' is private.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    if pointer {
                        ret QualifiedValue(value.left.value, value.right, instance);
                    } else {
                        this.Error("Invalid pointer member access.");
                        ret QualifiedValue(null, null);
                    }
                }
            } else {
                this.Error((String("Class does not have member '") + member_access->member + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }

        let field: Pair<Field, QualifiedType*>& = instance.Type().Pointee().Fields()[member_access->member];

        if field.left.visibility != TokenType::PUBLIC && state {
            this.Error((String("Field '") + member_access->member + "' is private.").Data());
            ret QualifiedValue(null, null);
        }

        let field_pointer: LLVMValueRef = LLVMBuildStructGEP2(this.builder, instance.Type().Pointee().Value(), instance.Value(), index as u32, "");

        if !pointer {
            ret QualifiedValue(LLVMBuildLoad2(this.builder, field.right->Value(), field_pointer, ""), field.right);
        } else {
            ret QualifiedValue(field_pointer, this.type_manager.Pointer(field.right, instance.Type().Pointee().IsMutable()));
        }
    }

    priv CompileNew(mut this: Compiler&, _new: NewNode*) -> QualifiedValue {
        let _type: QualifiedType& = this.CompileType(_new->_type);
        let mut pointer: LLVMValueRef = null;

        if _new->size != null {
            let size: QualifiedValue = this.CompileExpression(_new->size, false);

            if LLVMGetTypeKind(size.Type().Value()) != LLVMTypeKind::LLVMIntegerTypeKind || LLVMGetIntTypeWidth(size.Type().Value()) != 64u32 || size.Type().IsSigned() {
                this.Error("Size must be an unsigned 64-bit integer.");
                ret QualifiedValue(null, null);
            }

            let mut _size: LLVMValueRef = LLVMConstInt(LLVMInt64TypeInContext(this.context), LLVMABISizeOfType(this.layout, _type.Value()), 0i32);
            _size = LLVMBuildAdd(this.builder, LLVMBuildMul(this.builder, _size, size.Value(), ""), LLVMConstInt(LLVMInt64TypeInContext(this.context), 8u64, 0i32), "");
            pointer = LLVMBuildArrayMalloc(this.builder, LLVMInt8TypeInContext(this.context), _size, "");
            LLVMBuildStore(this.builder, size.Value(), LLVMBuildBitCast(this.builder, pointer, LLVMPointerType(LLVMInt64TypeInContext(this.context), 0u32), ""));

            let indices[]: LLVMValueRef = { LLVMConstInt(LLVMInt64TypeInContext(this.context), 8u64, 0i32) };
            pointer = LLVMBuildGEP2(this.builder, LLVMInt8TypeInContext(this.context), pointer, indices, 1u32, "");
            pointer = LLVMBuildBitCast(this.builder, pointer, LLVMPointerType(_type.Value(), 0u32), "");

            if _type.IsClass() {
                let value: LLVMValueRef = LLVMBuildAlloca(this.builder, LLVMInt64TypeInContext(this.context), "");
                LLVMBuildStore(this.builder, LLVMConstInt(LLVMInt64TypeInContext(this.context), 0u64, 0i32), value);

                let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
                let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, compare_block);
                let index: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), value, "");
                LLVMBuildCondBr(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, index, size.Value(), ""), loop_block, end_block);

                let params: Vector<QualifiedValue>;
                let indices[]: LLVMValueRef = { index };
                LLVMPositionBuilderAtStart(this.builder, loop_block);
                this.CompileConstructor(_type, QualifiedValue(LLVMBuildGEP2(this.builder, _type.Value(), pointer, indices, 1u32, ""), this.type_manager.Pointer(_type, true)), params);
                LLVMBuildStore(this.builder, LLVMBuildAdd(this.builder, index, LLVMConstInt(LLVMInt64TypeInContext(this.context), 1u64, 0i32), ""), value);
                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, end_block);
            }
        } else {
            pointer = LLVMBuildMalloc(this.builder, _type.Value(), "");
        }

        ret QualifiedValue(pointer, this.type_manager.Pointer(_type, true));
    }

    priv CompileDelete(mut this: Compiler&, delete: DeleteNode*) -> QualifiedValue {
        let pointer: QualifiedValue = this.CompileExpression(delete->expression, false);

        if !pointer.Type().IsPointer() {
            this.Error("Delete value must be a pointer.");
            ret QualifiedValue(null, null);
        }

        let mut _pointer: LLVMValueRef = pointer.Value();

        if LLVMGetTypeKind(pointer.Type().Pointee().Value()) != LLVMTypeKind::LLVMIntegerTypeKind || LLVMGetIntTypeWidth(pointer.Type().Pointee().Value()) != 8u32 {
            _pointer = LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(LLVMInt8TypeInContext(this.context), 0u32), "");
        }

        if delete->array {
            let indices[]: LLVMValueRef = { LLVMConstInt(LLVMInt64TypeInContext(this.context), -8i64 as u64, 0i32) };
            _pointer = LLVMBuildGEP2(this.builder, LLVMInt8TypeInContext(this.context), _pointer, indices, 1u32, "");

            if pointer.Type().Pointee().IsClass() {
                let count: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(LLVMInt64TypeInContext(this.context), 0u32), ""), "");

                let value: LLVMValueRef = LLVMBuildAlloca(this.builder, LLVMInt64TypeInContext(this.context), "");
                LLVMBuildStore(this.builder, LLVMConstInt(LLVMInt64TypeInContext(this.context), 0u64, 0i32), value);

                let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
                let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, compare_block);
                let index: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), value, "");
                LLVMBuildCondBr(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, index, count, ""), loop_block, end_block);

                let indices[]: LLVMValueRef = { index };
                LLVMPositionBuilderAtStart(this.builder, loop_block);
                this.CompileDestructor(pointer.Type().Pointee(), QualifiedValue(LLVMBuildGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), indices, 1u32, ""), pointer.Type()));
                LLVMBuildStore(this.builder, LLVMBuildAdd(this.builder, index, LLVMConstInt(LLVMInt64TypeInContext(this.context), 1u64, 0i32), ""), value);
                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, end_block);
            }
        } else {
            if pointer.Type().Pointee().IsClass() {
                this.CompileDestructor(pointer.Type().Pointee(), pointer);
            }
        }

        LLVMBuildFree(this.builder, _pointer);
        ret QualifiedValue(null, null);
    }

    priv CompileCast(mut this: Compiler&, cast: CastNode*, pointer: bool) -> QualifiedValue {
        let target: QualifiedType& = this.CompileType(cast->target_type);
        let target_kind: LLVMTypeKind = LLVMGetTypeKind(target.Value());

        if cast->expression->node_type == ASTNodeType::INITIALIZER_LIST {
            if !target.IsClass() {
                this.Error("Expected a class.");
                ret QualifiedValue(null, null);
            }

            let mut params: Vector<QualifiedValue>;
            let initializer_list: InitializerListNode* = cast->expression as InitializerListNode*;
            let mut i: u64 = 0u64;

            while i < initializer_list->expressions.Size() {
                params.PushBack(this.CompileExpression(initializer_list->expressions[i], false));
                i += 1u64;
            }

            let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, target.Value(), "");
            LLVMPositionBuilderAtEnd(this.builder, current);
            let instance: QualifiedValue = QualifiedValue(_pointer, this.type_manager.Pointer(target, false));
            this.CompileConstructor(target, instance, params);
            this.scope_manager.RegisterInstance(instance);

            if !pointer {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, target.Value(), instance.Value(), ""), target);
            } else {
                ret instance;
            }
        }

        let value: QualifiedValue = this.CompileExpression(cast->expression, false);
        let value_kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

        if value.Type() == target {
            this.Error((String("Redundant cast. ('") + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "')").Data());
            ret QualifiedValue(null, null);
        }

        if value.Type().IsPointer() && target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            ret QualifiedValue(LLVMBuildPtrToInt(this.builder, value.Value(), target.Value(), ""), target);
        } else if value_kind == LLVMTypeKind::LLVMFloatTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                ret QualifiedValue(LLVMBuildFPExt(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMDoubleTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }
            
            if target_kind == LLVMTypeKind::LLVMFloatTypeKind {
                ret QualifiedValue(LLVMBuildFPTrunc(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if target.IsPointer() {
                ret QualifiedValue(LLVMBuildIntToPtr(this.builder, value.Value(), target.Value(), ""), target);
            }

            if target_kind == LLVMTypeKind::LLVMFloatTypeKind || target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if value.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSIToFP(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildUIToFP(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                let value_width: u32 = LLVMGetIntTypeWidth(value.Type().Value());
                let target_width: u32 = LLVMGetIntTypeWidth(target.Value());

                if target_width > value_width {
                    if value.Type().IsSigned() {
                        ret QualifiedValue(LLVMBuildSExt(this.builder, value.Value(), target.Value(), ""), target);
                    } else {
                        ret QualifiedValue(LLVMBuildZExt(this.builder, value.Value(), target.Value(), ""), target);
                    }
                } else if target_width < value_width {
                    ret QualifiedValue(LLVMBuildTrunc(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(value.Value(), target);
                }
            }
        }

        if value.Type().IsPointer() && target.IsPointer() {
            ret QualifiedValue(LLVMBuildBitCast(this.builder, value.Value(), target.Value(), ""), target);
        } else {
            this.Error(String("Cannot cast '" + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileUnaryOperation(mut this: Compiler&, unary_op: UnaryOpNode*, pointer: bool) -> QualifiedValue {
        if unary_op->operator == TokenType::BITWISE_AND {
            if !pointer {
                ret this.CompileExpression(unary_op->operand, true);
            } else {
                this.Error("Invalid pointer unary operation.");
                ret QualifiedValue(null, null);
            }
        } else {
            let value: QualifiedValue = this.CompileExpression(unary_op->operand, false);
            let kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

            if unary_op->operator == TokenType::MUL {
                if value.Type().IsPointer() {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                    } else {
                        ret value;
                    }
                } else {
                    this.Error((String("Cannot dereference non-pointer type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::MINUS {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type().IsSigned() {
                        if !pointer {
                            ret QualifiedValue(LLVMBuildNeg(this.builder, value.Value(), ""), value.Type());
                        } else {
                            this.Error("Invalid pointer unary operation.");
                            ret QualifiedValue(null, null);
                        }
                    } else {
                        this.Error((String("Cannot negate unsigned type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildFNeg(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot negate type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::NOT {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildNot(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot invert type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid unary operation '") + TokenTypeToString(unary_op->operator) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }
    }

    priv CompileBinaryOperation(mut this: Compiler&, binary_op: BinaryOpNode*) -> QualifiedValue {
        let (left: QualifiedValue, right: QualifiedValue) = (this.CompileExpression(binary_op->left, false), this.CompileExpression(binary_op->right, false));
        let (left_kind: LLVMTypeKind, right_kind: LLVMTypeKind) = (LLVMGetTypeKind(left.Type().Value()), LLVMGetTypeKind(right.Type().Value()));

        if left.Type().IsPointer() && right.Type().IsPointer() {
            if binary_op->operator == TokenType::MINUS {
                let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false);
                ret QualifiedValue(LLVMBuildSub(this.builder, LLVMBuildPtrToInt(this.builder, left.Value(), _type.Value(), ""), LLVMBuildPtrToInt(this.builder, right.Value(), _type.Value(), ""), ""), _type);
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left.Type().IsPointer() && right_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right.Type().IsPointer()) {
            let ptr: QualifiedValue = left.Type().IsPointer() ? left : right;
            let index: QualifiedValue = left.Type().IsPointer() ? right : left;
            let width: u32 = LLVMGetIntTypeWidth(index.Type().Value());

            if width == 64u32 {
                if binary_op->operator == TokenType::PLUS {
                    let indices[]: LLVMValueRef = { index.Value() };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), "") };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else {
                    this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible binary operation types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildUDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::MOD {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSRem(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildURem(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGT : LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGE : LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLT : LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLE : LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::AND || binary_op->operator == TokenType::BITWISE_AND {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::AND {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildAnd(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::OR || binary_op->operator == TokenType::BITWISE_OR {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && binary_op->operator == TokenType::OR {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildOr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if binary_op->operator == TokenType::BITWISE_XOR {
                ret QualifiedValue(LLVMBuildXor(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::LSHIFT {
                ret QualifiedValue(LLVMBuildShl(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::RSHIFT {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildAShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildLShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind) && (right_kind == LLVMTypeKind::LLVMFloatTypeKind || right_kind == LLVMTypeKind::LLVMDoubleTypeKind) {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible binary operation types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if binary_op->operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildFAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildFSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildFMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::DIV {
                ret QualifiedValue(LLVMBuildFDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::MOD {
                ret QualifiedValue(LLVMBuildFRem(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if binary_op->operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if binary_op->operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(binary_op->operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(binary_op->operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileType(mut this: Compiler&, type_node: ASTNode*) -> QualifiedType& {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->type_name == "bool" {
                ret this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            } else if primitive_type->type_name == "i8" || primitive_type->type_name == "u8" {
                ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i16" || primitive_type->type_name == "u16" {
                ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i32" || primitive_type->type_name == "u32" || primitive_type->type_name == "char" {
                ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i64" || primitive_type->type_name == "u64" {
                ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i128" || primitive_type->type_name == "u128" {
                ret this.type_manager.Primitive(LLVMInt128TypeInContext(this.context), primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "f32" {
                ret this.type_manager.Primitive(LLVMFloatTypeInContext(this.context), false);
            } else if primitive_type->type_name == "f64" {
                ret this.type_manager.Primitive(LLVMDoubleTypeInContext(this.context), false);
            } else if primitive_type->type_name == "void" {
                ret this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
            } else {
                let mut _type: QualifiedType* = null;

                if this.scope_manager.Has(primitive_type->type_name, SymbolKind::Type) {
                    _type = this.scope_manager.Get(primitive_type->type_name, SymbolKind::Type)->value.Type();
                } else if this.scope_manager.Has(primitive_type->type_name, SymbolKind::Class) {
                    _type = this.scope_manager.Get(primitive_type->type_name, SymbolKind::Class)->value.Type();
                } else if this.scope_manager.Has(primitive_type->type_name, SymbolKind::Generic) {
                    if primitive_type->generic {
                        let mut types: Vector<QualifiedType*>;
                        let mut i: u64 = 0u64;

                        while i < primitive_type->types.Size() {
                            types.PushBack(this.CompileType(primitive_type->types[i]));
                            i += 1u64;
                        }

                        _type = (this.scope_manager.Get(primitive_type->type_name, SymbolKind::Generic)->pointer as Generic*)->Get(types);
                    } else {
                        this.Error((String("Generic type '") + primitive_type->type_name + "' requires parameters.").Data());
                        ret null;
                    }
                } else {
                    this.Error((String("Type '") + primitive_type->type_name + "' not found.").Data());
                    ret null;
                }

                if _type->IsClass() || _type->IsPointer() {
                    ret this.type_manager.Copy(_type, primitive_type->mutable);
                } else {
                    ret _type;
                }
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(pointer_type->base_type), pointer_type->mutable);
        } else if type_node->node_type == ASTNodeType::REFERENCE_TYPE {
            let reference_type: ReferenceTypeNode* = type_node as ReferenceTypeNode*;
            ret this.type_manager.Reference(this.CompileType(reference_type->base_type), reference_type->mutable);
        } else if type_node->node_type == ASTNodeType::ARRAY_TYPE {
            let array_type: ArrayTypeNode* = type_node as ArrayTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(array_type->element_type), true);
        } else if type_node->node_type == ASTNodeType::FUNCTION_TYPE {
            let function_type: FunctionTypeNode* = type_node as FunctionTypeNode*;
            let (mut params: Vector<QualifiedType*>, mut param_types: Vector<LLVMTypeRef>);
            let mut return_type: QualifiedType* = this.CompileType(function_type->return_type);

            if LLVMGetTypeKind(return_type->Value()) == LLVMTypeKind::LLVMStructTypeKind {
                let mut processed_type: QualifiedType& = this.ProcessType(return_type);

                if LLVMGetTypeKind(processed_type.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                    return_type = processed_type;
                } else {
                    params.PushBack(processed_type);
                    param_types.PushBack(processed_type.Value());
                    return_type = this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
                    processed_type.sret = return_type;
                }
            }

            let mut i: u64 = 0u64;

            while i < function_type->parameters.Size() {
                let param: ParameterNode* = function_type->parameters[i];
                let real_type: QualifiedType& = this.CompileType(param->param_type);
                let mut processed_type: QualifiedType& = this.ProcessType(real_type);
                param_types.PushBack(processed_type.Value());
                params.PushBack(processed_type);

                if real_type != processed_type {
                    processed_type.byval = real_type;
                } i += 1u64;
            }

            ret this.type_manager.Pointer(this.type_manager.Function(LLVMFunctionType(return_type->Value(), param_types.Data(), param_types.Size() as u32, function_type->var_arg ? 1i32 : 0i32), params, return_type), false);
        } else {
            this.Error((String("Unknown type '") + ASTNodeTypeToString(type_node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: Compiler&, message: i8*) {
        printf("Compiler error: %s\n", message);
        exit(1i32);
    }
};