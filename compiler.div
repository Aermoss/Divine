/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divio", "divstr", "divvec", "divmap", "divpair", "divptr", "divfile", "divllvm" : *;

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right {
        ret true;
    }

    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

func LLVMValueToString(value: LLVMValueRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintValueToString(value);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

func LLVMAddressOf(value: LLVMValueRef) -> LLVMValueRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMLoad {
        let operand: LLVMValueRef = LLVMGetOperand(value, 0u32);
        LLVMInstructionEraseFromParent(value);
        ret operand;
    } else {
        printf("Failed to get address of '%s'.\n", LLVMValueToString(value).Data());
        exit(1i32);
        ret null;
    }
}

class Field {
    pub initializer: ASTNode*,
    pub visibility: TokenType,
    pub index: u64 = 0u64
} impl {
    Field(this: mut Field&, initializer: ASTNode*, visibility: TokenType, index: u64) {
        (this.initializer, this.visibility, this.index) = (initializer, visibility, index);
    }

    ~Field(this: Field&) {}
};

class Method {
    pub name: String,
    pub value: LLVMValueRef,
    pub visibility: TokenType
} impl {
    Method(this: mut Method&, name: String, value: LLVMValueRef, visibility: TokenType) {
        (this.name, this.value, this.visibility) = (name, value, visibility);
    }

    ~Method(this: Method&) {}
};

class QualifiedType {
    pub current_class: QualifiedType** = null,
    priv value: LLVMTypeRef, priv pointee: QualifiedType* = null,
    priv reference: bool = false, priv mutable: bool = false, priv signed: bool = false,
    priv array: bool = false, priv size: u64 = 0u64,

    pub constructed: Vector<QualifiedType*>,
    pub fields: Map<String, Pair<Field, QualifiedType*>>,
    pub methods: Vector<Pair<Method, QualifiedType*>>,
    pub name: String, priv _class: bool = false,

    pub sret: QualifiedType* = null, pub byval: QualifiedType* = null,
    priv params: Vector<QualifiedType*>, priv return: QualifiedType* = null,
    priv _function: bool = false
} impl {
    QualifiedType(this: mut QualifiedType&, value: LLVMTypeRef, signed: bool) {
        (this.value, this.signed) = (value, signed);
    }

    QualifiedType(this: mut QualifiedType&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) {
        (this.value, this.params, this.return, this._function) = (value, params, return, true);
    }

    QualifiedType(this: mut QualifiedType&, value: LLVMTypeRef, mutable: bool, name: String) {
        (this.value, this.mutable, this.name, this._class) = (value, mutable, name, true);
    }

    QualifiedType(this: mut QualifiedType&, value: LLVMTypeRef, mutable: bool, reference: bool, pointee: QualifiedType*) {
        (this.value, this.mutable, this.reference, this.pointee) = (value, mutable, reference, pointee);
    }

    QualifiedType(this: mut QualifiedType&, value: LLVMTypeRef, mutable: bool, size: u64, pointee: QualifiedType*) {
        (this.value, this.mutable, this.size, this.pointee, this.array) = (value, mutable, size, pointee, true);
    }

    ~QualifiedType(this: QualifiedType&) {}

    pub IsMutable(this: QualifiedType&) -> bool { ret this.mutable; }
    pub IsSigned(this: QualifiedType&) -> bool { ret this.signed; }
    pub IsPointer(this: QualifiedType&) -> bool { ret this.pointee != null && !this.array; }
    pub IsReference(this: QualifiedType&) -> bool { ret this.reference; }
    pub IsArray(this: QualifiedType&) -> bool { ret this.array; }
    pub IsPrimitive(this: QualifiedType&) -> bool { ret !this.IsPointer() && !this.IsClass(); }
    pub IsFunction(this: QualifiedType&) -> bool { ret this._function; }
    pub IsClass(this: QualifiedType&) -> bool { ret this._class; }

    pub Value(this: QualifiedType&) -> LLVMTypeRef {
        if this.value != null {
            ret this.value;
        } else {
            this.Error("Null type!");
            ret null;
        }
    }

    pub Pointee(this: QualifiedType&) -> QualifiedType& {
        if this.pointee != null {
            if !this.array {
                ret this.pointee;
            } else {
                this.Error("Not a pointer!");
                ret null;
            }
        } else {
            this.Error("Null pointee!");
            ret null;
        }
    }

    pub Size(this: QualifiedType&) -> u64 {
        if this.array {
            ret this.size;
        } else {
            this.Error("Not an array!");
            ret 0u64;
        }
    }

    pub Element(this: QualifiedType&) -> QualifiedType& {
        if this.pointee != null {
            if this.array {
                ret this.pointee;
            } else {
                this.Error("Not an array!");
                ret null;
            }
        } else {
            this.Error("Null pointee!");
            ret null;
        }
    }

    pub Parameters(this: QualifiedType&) -> mut Vector<QualifiedType*>& {
        if this._function {
            ret this.params;
        } else {
            this.Error("Not a function!");
            ret null;
        }
    }

    pub Return(this: QualifiedType&) -> QualifiedType& {
        if this._function {
            ret this.return;
        } else {
            this.Error("Not a function!");
            ret null;
        }
    }

    pub Fields(this: QualifiedType&) -> mut Map<String, Pair<Field, QualifiedType*>>& {
        if this._class {
            ret this.fields;
        } else {
            this.Error("Not a class!");
            ret null;
        }
    }

    pub Methods(this: QualifiedType&) -> mut Vector<Pair<Method, QualifiedType*>>& {
        if this._class {
            ret this.methods;
        } else {
            this.Error("Not a class!");
            ret null;
        }
    }

    pub Index(this: QualifiedType&, name: String&) -> i64 {
        let fields: mut Map<String, Pair<Field, QualifiedType*>>& = this.Fields();
        let mut i: u64 = 0u64;

        while i < fields.Size() {
            if fields[i].left == name {
                ret fields[i].right.left.index as i64;
            } i += 1u64;
        } ret -1i64;
    }

    pub Has(this: QualifiedType&, name: String&) -> bool {
        let methods: mut Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Has(this: QualifiedType&, name: String&, params: Vector<QualifiedType*>&) -> bool {
        let methods: mut Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                let mut state: bool = false;

                if *this.current_class != null {
                    state = **this.current_class == this;
                }

                if methods[i].left.visibility == TokenType::PUBLIC || state {
                    let (mut match: bool, mut j: u64) = (true, 0u64);
                    let _params: Vector<QualifiedType*>& = methods[i].right->Pointee().Parameters();
                    let offset: u64 = _params[0u64]->sret != null ? 2u64 : 1u64;

                    if params.Size() != _params.Size() - offset {
                        i += 1u64;
                        continue;
                    }

                    while params.Size() > j {
                        let mut _type: QualifiedType* = _params[j + offset];

                        if _type->byval != null {
                            _type = _type->byval;
                        }

                        if _type->IsReference() && *_type != *(params[j]) {
                            _type = _type->Pointee();
                        }

                        let mut _state: bool = false;

                        if params[j]->IsReference() {
                            if *_type == params[j]->Pointee() {
                                _state = true;
                            } else if _type->IsPointer() && params[j]->Pointee().IsPointer() {
                                if LLVMGetTypeKind(_type->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(params[j]->Pointee().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                                    _state = true;
                                }
                            }
                        }

                        if _type->IsPointer() && params[j]->IsPointer() {
                            if LLVMGetTypeKind(_type->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(params[j]->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                                _state = true;
                            }
                        }

                        if *_type != *(params[j]) && !_state {
                            match = false;
                            break;
                        } j += 1u64;
                    }

                    if match {
                        ret true;
                    }
                }
            } i += 1u64;
        } ret false;
    }

    pub Get(this: QualifiedType&, name: String&) -> mut Pair<Method, QualifiedType*>& {
        let methods: mut Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let mut i: u64 = 0u64;

        while i < methods.Size() {
            if methods[i].left.name == name {
                ret methods[i];
            } i += 1u64;
        } ret null;
    }

    pub Get(this: QualifiedType&, name: String&, params: Vector<QualifiedType*>&) -> mut Pair<Method, QualifiedType*>& {
        let (mut match: u64, mut best: u64) = (0u64, 0u64);
        let methods: mut Vector<Pair<Method, QualifiedType*>>& = this.Methods();
        let (mut state: u64, mut i: u64) = (0u64, 0u64);

        while i < methods.Size() {
            if methods[i].left.name == name {
                let mut _state: bool = false;

                if *this.current_class != null {
                    _state = **this.current_class == this;
                }

                if methods[i].left.visibility != TokenType::PUBLIC && !_state {
                    if state < 1u64 { state = 1u64; }
                } else {
                    let (mut _match: bool, mut score: u64, mut j: u64) = (true, 1u64, 0u64);
                    let _params: Vector<QualifiedType*>& = methods[i].right->Pointee().Parameters();
                    let offset: u64 = _params[0u64]->sret != null ? 2u64 : 1u64;

                    if params.Size() != _params.Size() - offset {
                        i += 1u64;
                        continue;
                    }

                    while params.Size() > j {
                        let mut _type: QualifiedType* = _params[j + offset];

                        if _type->byval != null {
                            _type = _type->byval;
                        }

                        if _type->IsReference() && *_type != *(params[j]) {
                            _type = _type->Pointee();
                        }

                        let (mut _state: bool, mut state_: bool) = (false, false);

                        if params[j]->IsReference() {
                            if *_type == params[j]->Pointee() {
                                _state = true;
                            } else if _type->IsPointer() && params[j]->Pointee().IsPointer() {
                                if LLVMGetTypeKind(_type->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(params[j]->Pointee().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                                    state_ = true;
                                }
                            }
                        }

                        if _type->IsPointer() && params[j]->IsPointer() {
                            if LLVMGetTypeKind(_type->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(params[j]->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                                state_ = true;
                            }
                        }

                        if *_type == *(params[j]) || _state || state_ {
                            score += _state ? 3u64 : (state_ ? 1u64 : 2u64);
                        } else {
                            _match = false;
                            break;
                        } j += 1u64;
                    }

                    if !_match {
                        state = 2u64;
                    } else if score > best {
                        (match, best) = (i, score);
                    }
                }
            } i += 1u64;
        }

        if best != 0u64 {
            ret methods[match];
        } else {
            if state == 0u64 {
                this.Error((String("Class '") + this.name + "' doesn't contain any member named '" + name + "'.").Data());
                ret null;
            } else if state == 1u64 {
                this.Error((String("Function '") + name + "' is not accessible.").Data());
                ret null;
            } else {
                this.Error((String("Invalid arguments for: '") + name + "'.").Data());
                ret null;
            }
        }        
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        if this.pointee != null && other.pointee != null {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && (*this.pointee) == (*other.pointee);
        } else {
            ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && this.pointee == other.pointee;
        }
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }

    priv Error(this: QualifiedType&, message: i8*) {
        printf("Qualified type error: %s\n", message);
        exit(1i32);
    }
};

class TypeManager {
    pub current_class: QualifiedType** = null,
    priv types: Vector<QualifiedType*>
} impl {
    TypeManager(this: TypeManager&) {}

    ~TypeManager(this: mut TypeManager&) {
        printf("Disposing %llu types...\n", this.types.Size());
        let mut i: u64 = 0u64;

        while i < this.types.Size() {
            del this.types[i];
            i += 1u64;
        }

        this.types.Clear();
    }

    pub Primitive(this: mut TypeManager&, value: LLVMTypeRef, signed: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, signed);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Function(this: mut TypeManager&, value: LLVMTypeRef, params: Vector<QualifiedType*>, return: QualifiedType*) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, params, return);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Class(this: mut TypeManager&, value: LLVMTypeRef, name: String) -> QualifiedType* {
        let _type: mut QualifiedType* = new QualifiedType(value, false, name);
        _type->current_class = this.current_class;
        this.types.PushBack(_type);
        ret _type;
    }

    pub Pointer(this: mut TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, false, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Reference(this: mut TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, true, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Array(this: mut TypeManager&, pointee: QualifiedType*, size: u64, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMArrayType2(pointee->Value(), size), mutable, size, pointee);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Copy(this: mut TypeManager&, _type: mut QualifiedType*, mutable: bool) -> QualifiedType* {
        if mutable != _type->IsMutable() {
            let mut copy: mut QualifiedType* = null;

            if _type->IsPointer() {
                copy = new QualifiedType(_type->Value(), mutable, _type->IsReference(), _type->Pointee());
                (copy->byval, copy->sret) = (_type->byval, _type->sret);
            } else {
                this.Error("Cannot copy non-pointer type.");
                ret null;
            }

            this.types.PushBack(copy);
            ret copy;
        } else {
            ret _type;
        }
    }

    priv Error(this: TypeManager&, message: i8*) {
        printf("Type manager error: %s\n", message);
        exit(1i32);
    }
};

class QualifiedValue {
    priv value: LLVMValueRef,
    priv _type: QualifiedType*,
    pub instance: LLVMValueRef = null,
    pub instance_type: QualifiedType* = null,
    pub binding: bool = false,
    pub return: bool = false
} impl {
    QualifiedValue(this: mut QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*) {
        (this.value, this._type) = (value, _type);
    }

    QualifiedValue(this: mut QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*, instance: QualifiedValue&) {
        (this.value, this._type, this.instance, this.instance_type) = (value, _type, instance.value, instance._type);
    }

    QualifiedValue(this: mut QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*, return: bool, binding: bool) {
        (this.value, this._type, this.return, this.binding) = (value, _type, return, binding);
    }

    QualifiedValue(this: mut QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*, return: bool) {
        (this.value, this._type, this.return) = (value, _type, return);
    }

    ~QualifiedValue(this: QualifiedValue&) {}

    pub Null(this: QualifiedValue&) -> bool {
        ret this.value == null;
    }

    pub Value(this: QualifiedValue&) -> LLVMValueRef {
        if this.value != null {
            ret this.value;
        } else {
            this.Error("Null value!");
            ret null;
        }
    }

    pub Type(this: QualifiedValue&) -> QualifiedType& {
        if this._type != null {
            ret this._type;
        } else {
            this.Error("Null type!");
            ret null;
        }
    }

    priv Error(this: QualifiedValue&, message: i8*) {
        printf("Qualified value error: %s\n", message);
        exit(1i32);
    }
};

enum SymbolKind {
    Variable, GlobalVariable, Constant, Function, Parameter, Generic, Class, Type
};

func SymbolKindToString(kind: SymbolKind) -> String {
    if kind == SymbolKind::Variable { ret { "Variable" } as String; }
    else if kind == SymbolKind::GlobalVariable { ret { "GlobalVariable" } as String; }
    else if kind == SymbolKind::Constant { ret { "Constant" } as String; }
    else if kind == SymbolKind::Function { ret { "Function" } as String; }
    else if kind == SymbolKind::Parameter { ret { "Parameter" } as String; }
    else if kind == SymbolKind::Generic { ret { "Generic" } as String; }
    else if kind == SymbolKind::Class { ret { "Class" } as String; }
    else if kind == SymbolKind::Type { ret { "Type" } as String; }
    else { ret { "Unknown" } as String; }
}

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: QualifiedValue,
    pub pointer: void* = null
} impl {
    Symbol(this: mut Symbol&, name: String, kind: SymbolKind, value: QualifiedValue) {
        (this.name, this.kind, this.value) = (name, kind, value);
    }

    Symbol(this: mut Symbol&, name: String, kind: SymbolKind, pointer: void*) {
        (this.name, this.kind, this.pointer) = (name, kind, pointer);
    }

    ~Symbol(this: Symbol&) {}
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub instances: Vector<QualifiedValue>,
    pub name: String
} impl {
    Scope(this: mut Scope&, parent: Scope*, name: String&, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(this: Scope&, name: String&) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }
    
    pub Has(this: Scope&, name: String&, kind: SymbolKind) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name && this.symbols[i]->kind == kind {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(this: mut Scope&, name: String&, kind: SymbolKind, value: QualifiedValue&, overload: bool) -> Symbol* {
        if this.Has(name) && !overload {
            this.Error((String("Symbol '") + name + "' already exists.").Data());
            ret null;
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value);
            this.symbols.PushBack(symbol);
            ret symbol;
        }
    }

    pub Set(this: mut Scope&, name: String&, kind: SymbolKind, pointer: void*, overload: bool) -> Symbol* {
        if this.Has(name) && !overload {
            this.Error((String("Symbol '") + name + "' already exists.").Data());
            ret null;
        } else {
            let symbol: Symbol* = new Symbol(name, kind, pointer);
            this.symbols.PushBack(symbol);
            ret symbol;
        }
    }

    pub Get(this: Scope&, name: String&) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    pub Get(this: Scope&, name: String&, kind: SymbolKind) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name && this.symbols[i]->kind == kind {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(this: Scope&, message: i8*) {
        printf("Scope error: %s\n", message);
        exit(1i32);
    }
};

class ScopeManager {
    pub compiler: void* = null,
    pub builder: LLVMBuilderRef = null,
    pub CompileDestructor: func(void*, QualifiedType*, QualifiedValue),
    pub CompileDestructor2: func(void*, LLVMValueRef, QualifiedType*),
    pub scopes: Vector<Scope*>,
    pub current: mut Scope* = null
} impl {
    ScopeManager(this: mut ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(this: mut ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(this: mut ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(this: mut ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                let mut i: u64 = 0u64;

                while i < temp->instances.Size() {
                    let instance: QualifiedValue = temp->instances[i];

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        this.CompileDestructor2(this.compiler, instance.Value(), &instance.Type());
                    } i += 1u64;
                }

                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub RegisterInstance(this: mut ScopeManager&, instance: QualifiedValue) {
        if !this.current->global {
            this.current->instances.PushBack(instance);
        } else {
            this.Error("Cannot register instance in global scope.");
            ret;
        }
    }

    pub InvokeDestructors(this: ScopeManager&, except: QualifiedValue) {
        let mut scope: Scope* = this.current;

        while !scope->global {
            let mut i: u64 = 0u64;

            while i < scope->instances.Size() {
                let instance: QualifiedValue = scope->instances[i];

                if instance != except {
                    this.CompileDestructor2(this.compiler, instance.Value(), &instance.Type());
                } i += 1u64;
            } scope = scope->parent;
        }
    }

    pub InvokeDestructors(this: ScopeManager&) {
        let mut scope: Scope* = this.current;

        while !scope->global {
            let mut i: u64 = 0u64;

            while i < scope->instances.Size() {
                let instance: QualifiedValue = scope->instances[i];
                this.CompileDestructor2(this.compiler, instance.Value(), &instance.Type());
                i += 1u64;
            } scope = scope->parent;
        }
    }

    pub Has(this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) {
                ret true;
            } else {
                scope = scope->parent;
            }
        } ret false;
    }

    pub Has(this: ScopeManager&, name: String, kind: SymbolKind) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name, kind) {
                ret true;
            } else {
                scope = scope->parent;
            }
        } ret false;
    }

    pub Set(this: mut ScopeManager&, name: String, kind: SymbolKind, value: QualifiedValue, overload: bool) -> Symbol* {
        ret this.current->Set(name, kind, value, overload);
    }

    pub Set(this: mut ScopeManager&, name: String, kind: SymbolKind, pointer: void*, overload: bool) -> Symbol* {
        ret this.current->Set(name, kind, pointer, overload);
    }

    pub Get(this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) {
                ret scope->Get(name);
            } else {
                scope = scope->parent;
            }
        } ret null;
    }

    pub Get(this: ScopeManager&, name: String, kind: SymbolKind) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name, kind) {
                ret scope->Get(name, kind);
            } else {
                scope = scope->parent;
            }
        } ret null;
    }

    pub Namespaces(this: ScopeManager&) -> Vector<String> {
        let mut scope: Scope* = this.current;
        let mut inverse: Vector<String>;

        while scope->parent != null {
            if scope->global {
                inverse.PushBack(scope->name);
            } scope = scope->parent;
        }

        let mut result: Vector<String>;
        let mut i: u64 = inverse.Size();

        while i > 0u64 {
            result.PushBack(inverse[i - 1u64]);
            i -= 1u64;
        } ret result;
    }

    pub ResolveChild(this: ScopeManager&, scope: Scope*, identifier: IdentifierNode*) -> Scope* {
        let mut i: u64 = 0u64;

        while i < scope->children.Size() {
            if scope->children[i]->name == identifier->name {
                ret scope->children[i];
            } else {
                i += 1u64;
            }
        }

        this.Error((String("Scope '") + identifier->name + "' not found.").Data());
        ret null;
    }

    pub ResolveScopeHalf(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        let mut scope: Scope* = this.current;

        while !scope->global {
            scope = scope->parent;
        }

        if resolution->scope != null {
            if resolution->scope->node_type == ASTNodeType::SCOPE_RESOLUTION {
                scope = this.ResolveScopeFull(resolution->scope as ScopeResolutionNode*);
            } else {
                scope = this.ResolveChild(scope, resolution->scope as IdentifierNode*);
            }
        } else {
            while scope->parent != null {
                scope = scope->parent;
            }
        } ret scope;
    }

    pub ResolveScopeFull(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Scope* {
        ret this.ResolveChild(this.ResolveScopeHalf(resolution), resolution->identifier);
    }

    pub Resolve(this: ScopeManager&, resolution: ScopeResolutionNode*) -> Symbol* {
        let scope: Scope* = this.ResolveScopeHalf(resolution);

        if scope->Has(resolution->identifier->name) {
            ret scope->Get(resolution->identifier->name);
        } else {
            this.Error((String("Symbol '") + resolution->identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, identifier: IdentifierNode*) -> Symbol* {
        if this.Has(identifier->name) {
            ret this.Get(identifier->name);
        } else {
            this.Error((String("Symbol '") + identifier->name + "' not found.").Data());
            ret null;
        }
    }

    pub Resolve(this: ScopeManager&, node: ASTNode*) -> Symbol* {
        if node->node_type == ASTNodeType::SCOPE_RESOLUTION {
            ret this.Resolve(node as ScopeResolutionNode*);
        } else if node->node_type == ASTNodeType::IDENTIFIER {
            ret this.Resolve(node as IdentifierNode*);
        } else {
            this.Error((String("Unknown resolution '") + ASTNodeTypeToString(node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: ScopeManager&, message: i8*) {
        printf("Scope manager error: %s\n", message);
        exit(1i32);
    }
};

class Mangler {
    pub prefix: i8* = "$d",
    pub scope_manager: ScopeManager* = null
} impl {
    Mangler(this: mut Mangler&) {}
    ~Mangler(this: mut Mangler&) {}

    priv MangleType(this: Mangler&, _type: QualifiedType*) -> String {
        let kind: LLVMTypeKind = LLVMGetTypeKind(_type->Value());

        if kind == LLVMTypeKind::LLVMVoidTypeKind {
            ret String("v");
        } else if kind == LLVMTypeKind::LLVMPointerTypeKind {
            ret String("P") + this.MangleType(_type->Pointee());
        } else if kind == LLVMTypeKind::LLVMFunctionTypeKind {
            let mut result: String = "F";
            result += this.MangleType(_type->Return());
            let params: Vector<QualifiedType*> = _type->Parameters();
            let mut i: u64 = 0u64;

            while i < params.Size() {
                result += this.MangleType(params[i]);
                i += 1u64;
            } ret result;
        } else if kind == LLVMTypeKind::LLVMStructTypeKind {
            let mut name: String = LLVMGetStructName(_type->Value());

            if name[0u64] != '$' || name[1u64] != 'd' {
                name = this.MangleClass(name);
            } ret String(name.Data() + 2u64);
        } else if kind == LLVMTypeKind::LLVMIntegerTypeKind {
            let width: u32 = LLVMGetIntTypeWidth(_type->Value());
            ret String(width == 1u32 ? "b" : (width == 8u32 ? "c" : (width == 16u32 ? "s" : (width == 32u32 ? "i" : "l"))));
        } else if kind == LLVMTypeKind::LLVMDoubleTypeKind {
            ret String("d");
        } else if kind == LLVMTypeKind::LLVMFloatTypeKind {
            ret String("f");
        } else {
            this.Error((String("Unknown type '") + LLVMTypeToString(_type->Value()) + "'.").Data());
            ret String("");
        }
    }

    priv MangleName(this: Mangler&, name: String) -> String {
        if this.scope_manager == null {
            this.Error("Scope manager not set!");
            ret String("");
        }

        let mut result: String = this.prefix;
        let mut names: Vector<String> = this.scope_manager->Namespaces();
        names.PushBack(name);

        if names.Size() > 1u64 {
            result += "N";
        }

        let mut i: u64 = 0u64;

        while i < names.Size() {
            let length[32u64]: i8;
            sprintf(length, "%llu", names[i].Size() - 1u64);
            result += length;
            result += names[i];
            i += 1u64;
        }

        if names.Size() > 1u64 {
            result += "E";
        } ret result;
    }

    pub MangleFunction(this: Mangler&, name: String, _type: QualifiedType*) -> String {
        let mut result: String = this.MangleName(name);
        let params: Vector<QualifiedType*> = _type->Parameters();
        let mut i: u64 = 0u64;

        while i < params.Size() {
            result += this.MangleType(params[i]);
            i += 1u64;
        } ret result;
    }

    pub MangleClass(this: Mangler&, name: String) -> String {
        ret this.MangleName(name);
    }

    pub MangleClass(this: Mangler&, name: String, types: Vector<QualifiedType*>) -> String {
        let mut result: String = this.MangleName(name);

        if types.Size() > 0u64 {
            result += "I";
        }

        let mut i: u64 = 0u64;

        while i < types.Size() {
            result += this.MangleType(types[i]);
            i += 1u64;
        }

        if types.Size() > 0u64 {
            result += "E";
        } ret result;
    }

    priv Error(this: Mangler&, message: i8*) {
        printf("Mangler error: %s\n", message);
        exit(1i32);
    }
};

class Generic {
    priv current_generic: mut Generic** = null,
    priv compiler: void* = null,
    pub CompileClass: func(void*, ClassDeclNode*, Generic*) -> QualifiedType*,
    priv mangler: Mangler* = null,
    priv scope_manager: mut ScopeManager* = null,
    priv cache: Map<String, QualifiedType*>,
    priv name: String, pub current: String,
    pub types: Vector<QualifiedType*>,
    pub ast: ClassDeclNode* = null,
    pub scope: mut Scope* = null
} impl {
    Generic(this: mut Generic&, compiler: void*, ast: mut ClassDeclNode*, mangler: Mangler*, scope_manager: ScopeManager*, generic: Generic**) {
        (this.compiler, this.mangler, this.scope_manager) = (compiler, mangler, scope_manager);
        (this.current_generic, this.scope) = (generic, this.scope_manager->current);
        (this.ast, this.name, ast->generic) = (ast, ast->name, false);
    }

    ~Generic(this: Generic&) {}

    pub Set(this: mut Generic&, _class: QualifiedType*) {
        if this.current != "" {
            this.cache[this.current] = _class;
            this.current = "";
        } else {
            this.Error("Not in a generic compilation.");
            ret;
        }
    }

    pub Get(this: mut Generic&, types: Vector<QualifiedType*>) -> QualifiedType& {
        *this.current_generic = this;
        let scope: Scope* = this.scope_manager->current;
        this.scope_manager->current = this.scope;

        if this.current != "" {
            this.Error("Nested generics are not supported.");
            ret null;
        }

        if types.Size() != this.ast->types.Size() {
            this.Error("Generic type parameter count mismatch.");
            ret null;
        }

        let name: String = this.mangler->MangleClass(this.name, types);

        if this.cache.Has(name) {
            this.scope_manager->current = scope;
            ret this.cache[name];
        } else {
            this.current = name;
            this.types = types;
        }

        let mut i: u64 = 0u64;
        let mut symbols: Vector<Symbol*>;

        while i < this.ast->types.Size() {
            symbols.PushBack(this.scope->Set(this.ast->types[i], SymbolKind::Type, QualifiedValue(null, types[i]), false));
            i += 1u64;
        }

        let mut temp: Generic* = this;
        let _class: QualifiedType* = this.CompileClass(this.compiler, this.ast, temp);
        let mut j: u64 = 0u64;

        while j < symbols.Size() {
            let index: i64 = this.scope->symbols.Index(symbols[j]);

            if index != -1i64 {
                this.scope->symbols.Pop(index as u64);
                del symbols[j];
            } j += 1u64;
        }

        this.types.Clear();
        this.scope_manager->current = scope;
        *this.current_generic = null;
        ret _class;
    }

    priv Error(this: Generic&, message: i8*) {
        printf("Generic error: %s\n", message);
        exit(1i32);
    }
};

class Forward {
    pub _class: QualifiedType*,
    pub generic: Generic* = null,
    pub types: Vector<QualifiedType*>,
    pub decl: FunctionDeclNode*,
    pub _type: QualifiedType*,
    pub value: LLVMValueRef
} impl {
    Forward(this: mut Forward&, decl: FunctionDeclNode*, _type: QualifiedType*, value: LLVMValueRef, _class: QualifiedType*) {
        (this.decl, this._type, this.value, this._class) = (decl, _type, value, _class);
    }

    Forward(this: mut Forward&, decl: FunctionDeclNode*, _type: QualifiedType*, value: LLVMValueRef, _class: QualifiedType*, types: Vector<QualifiedType*>&, generic: Generic*) {
        (this.decl, this._type, this.value, this._class, this.types, this.generic) = (decl, _type, value, _class, types, generic);
    }

    ~Forward(this: Forward&) {}
};

class Compiler {
    priv mangler: Mangler,
    priv mangling: bool = true,
    priv generics: Vector<Generic*>,
    priv type_manager: TypeManager,
    priv generic: Generic* = null,
    priv _class: QualifiedType* = null,
    priv function: QualifiedType* = null,
    priv function_ref: LLVMValueRef = null,
    priv scope_manager: ScopeManager,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv forwards: Vector<Forward>,
    pub target_machine: LLVMTargetMachineRef = null,
    priv layout: LLVMTargetDataRef = null,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv target: LLVMTargetRef = null,
    priv triple: i8* = null
} impl {
    Compiler(this: mut Compiler&) {
        LLVMInitializeNativeTarget();
        LLVMInitializeNativeAsmPrinter();
        // LLVMInitializeNativeAsmParser();
        // LLVMInitializeNativeDisassembler();
        this.triple = LLVMGetDefaultTargetTriple();
        this.context = LLVMContextCreate();
        let err: i8* = null;

        if LLVMGetTargetFromTriple(this.triple, &this.target, &err) != 0i32 {
            printf("Failed to get target from triple: %s.\n", err);
            LLVMDisposeMessage(err);
            ret;
        }

        LLVMDisposeMessage(err);
        this.target_machine = LLVMCreateTargetMachine(this.target, this.triple, "generic", "", LLVMCodeGenOptLevel::LLVMCodeGenLevelDefault, LLVMRelocMode::LLVMRelocDefault, LLVMCodeModel::LLVMCodeModelDefault);
        this.layout = LLVMCreateTargetDataLayout(this.target_machine);

        this.scope_manager.compiler = this as void*;
        this.scope_manager.CompileDestructor = Compiler::CompileDestructor;
        this.scope_manager.CompileDestructor2 = Compiler::CompileDestructor2;
        this.mangler.scope_manager = &this.scope_manager;
        this.type_manager.current_class = &this._class;
    }

    ~Compiler(this: mut Compiler&) {
        this.mangler.scope_manager = null;
        this.type_manager.current_class = null;
        this.scope_manager.CompileDestructor2 = null;
        this.scope_manager.CompileDestructor = null;
        this.scope_manager.compiler = null;

        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        LLVMDisposeTargetMachine(this.target_machine);
        LLVMContextDispose(this.context);
    }

    pub Forget(this: mut Compiler&) {
        this.module = null;
    }

    pub Compile(this: mut Compiler&, ast: RootNode*, file_name: String&) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        this.builder = LLVMCreateBuilderInContext(this.context);
        this.scope_manager.builder = this.builder;
        LLVMSetSourceFileName(this.module, file_name.Data(), file_name.Size() - 1u64);
        LLVMSetTarget(this.module, this.triple);
        let layout: i8* = LLVMCopyStringRepOfTargetData(this.layout);
        LLVMSetDataLayout(this.module, layout);
        LLVMDisposeMessage(layout);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        this.CompileForwardDeclarations();
        let mut j: u64 = 0u64;

        while j < this.generics.Size() {
            del this.generics[j];
            j += 1u64;
        }

        this.generics.Clear();
        this.forwards.Clear();
        let err: i8* = null;

        if LLVMVerifyModule(this.module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0i32 {
            printf("Module verification failed: %s.\n", err);
            LLVMDisposeMessage(err);
            ret null;
        }

        LLVMDisposeMessage(err);
        this.scope_manager.builder = null;
        ret this.module;
    }

    priv CompileForwardDeclarations(this: mut Compiler&) {
        let mut i: u64 = 0u64;

        while i < this.forwards.Size() {
            let forward: Forward& = this.forwards[i];
            (this.function, this.function_ref) = (forward._type, forward.value);
            let params: Vector<QualifiedType*> = this.function->Parameters();
            let scope: Scope* = this.scope_manager.current;
            this._class = forward._class;

            if forward.generic != null {
                this.scope_manager.current = forward.generic->scope;
            }

            let mut j: u64 = 0u64;
            let mut symbols: Vector<Symbol*>;

            while j < forward.types.Size() {
                symbols.PushBack(forward.generic->scope->Set(forward.generic->ast->types[j], SymbolKind::Type, QualifiedValue(null, forward.types[j]), false));
                j += 1u64;
            }

            this.scope_manager.PushScope(forward.decl->name, false);
            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function_ref, "");
            LLVMPositionBuilderAtEnd(this.builder, entry);
            let mut k: u64 = 0u64;

            while k < forward.decl->_type->parameters.Size() {
                let param: ParameterNode* = forward.decl->_type->parameters[k];
                let index: u64 = params[0u64]->sret != null ? k + 1u64 : k;

                if params[index]->byval != null {
                    this.scope_manager.RegisterInstance(QualifiedValue(LLVMGetParam(this.function_ref, index as u32), this.type_manager.Pointer(params[index]->byval, param->mutable)));
                }

                let mut state: bool = params[index]->byval != null;
                let mut _type: QualifiedType* = params[index];

                while !state {
                    if _type->IsPointer() {
                        _type = _type->Pointee();
                    } else {
                        if _type->IsClass() {
                            state = true;
                        } break;
                    }
                }

                if param->mutable || state {
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, params[index]->Value(), "");

                    LLVMPositionBuilderAtEnd(this.builder, current);
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(pointer, this.type_manager.Pointer(params[index], param->mutable), false, true), false);
                    LLVMBuildStore(this.builder, LLVMGetParam(this.function_ref, index as u32), pointer);
                } else {
                    this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(LLVMGetParam(this.function_ref, index as u32), params[index], false, true), false);
                } k += 1u64;
            }

            let mut l: u64 = 0u64;

            while forward.decl->constructors.Size() > l {
                let _class: QualifiedType& = this.CompileType(forward.decl->constructors[l]->expression);

                if !_class.IsClass() {
                    this.Error("Constructor type must be a class.");
                    ret;
                }

                let mut values: Vector<QualifiedValue>;
                let mut m: u64 = 0u64;

                while forward.decl->constructors[l]->arguments.Size() > m {
                    values.PushBack(this.CompileExpression(forward.decl->constructors[l]->arguments[m], false));
                    m += 1u64;
                }

                let index: u64 = params[0u64]->sret != null ? 1u64 : 0u64;
                let instance: QualifiedValue = QualifiedValue(LLVMGetParam(this.function_ref, index as u32), params[index]);
                this.CompileConstructor(_class, this.CompileCast2(instance, this.type_manager.Pointer(_class, _class.IsMutable())), values);
                l += 1u64;
            }

            this.CompileBlock(forward.decl->body);
            this.scope_manager.PopScope();

            if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                let mut state: bool = true;

                if LLVMGetTypeKind(this.function->Return().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                    if params.Size() > 0u64 {
                        state = params[0u64]->sret != null;
                    } else {
                        state = false;
                    }
                }

                if !state {
                    LLVMBuildRetVoid(this.builder);
                } else {
                    this.Error((String("Function '") + forward.decl->name + "' must return a value.").Data());
                    ret;
                }
            }

            let mut m: u64 = 0u64;

            while m < symbols.Size() {
                let index: i64 = forward.generic->scope->symbols.Index(symbols[m]);

                if index != -1i64 {
                    forward.generic->scope->symbols.Pop(index as u64);
                    del symbols[m];
                } m += 1u64;
            }

            if forward.generic != null {
                this.scope_manager.current = scope;
            }

            this.function = null;
            this.function_ref = null;
            this._class = null;
            i += 1u64;
        }
    }

    priv CompileDeclaration(this: mut Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::CONSTANT_DECL {
            this.CompileConstant(decl as ConstantDeclNode*);
        } else if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::CLASS_DECL {
            this.CompileClass(decl as ClassDeclNode*, null);
        } else if decl->node_type == ASTNodeType::ENUM_DECL {
            this.CompileEnum(decl as EnumDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else if decl->node_type == ASTNodeType::TYPE_DECL {
            let type_decl: TypeDeclNode* = decl as TypeDeclNode*;
            this.scope_manager.Set(type_decl->name, SymbolKind::Type, QualifiedValue(null, this.CompileType(type_decl->_type)), false);
        } else {
            this.Error((String("Unknown declaration '") + ASTNodeTypeToString(decl->node_type) + "'.").Data());
        }
    }

    priv CompileConstant(this: mut Compiler&, constant_decl: ConstantDeclNode*) {
        let _type: QualifiedType& = this.CompileType(constant_decl->_type);
        let mut initializer: QualifiedValue;

        if constant_decl->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
            initializer = this.CompileExpression(constant_decl->initializer, false);
        } else {
            let mut values: Vector<LLVMValueRef>;
            let initializer_list: InitializerListNode* = constant_decl->initializer as InitializerListNode*;
            let fields: mut Map<String, Pair<Field, QualifiedType*>>& = _type.Fields();
            let mut i: u64 = 0u64;

            while i < fields.Size() {
                if i < initializer_list->expressions.Size() {
                    values.PushBack(this.CompileExpression(initializer_list->expressions[i], false).Value());
                } else {
                    if fields[i].right.left.initializer != null {
                        values.PushBack(this.CompileExpression(fields[i].right.left.initializer, false).Value());
                    } else {
                        this.Error((String("Missing initializer for field '") + fields[i].left + "'.").Data());
                        ret;
                    }
                } i += 1u64;
            }

            initializer = QualifiedValue(LLVMConstNamedStruct(_type.Value(), values.Data(), values.Size() as u32), _type);
        }

        if initializer.Type() != _type {
            this.Error((String("Incompatible constant initialization types. ('") + LLVMTypeToString(_type.Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
            ret;
        }

        let global: LLVMValueRef = LLVMAddGlobal(this.module, _type.Value(), constant_decl->name.Data());
        this.scope_manager.Set(constant_decl->name, SymbolKind::GlobalVariable, QualifiedValue(global, this.type_manager.Pointer(_type, false), false, true), false);
        LLVMSetLinkage(global, LLVMLinkage::LLVMPrivateLinkage);
        LLVMSetInitializer(global, initializer.Value());
        LLVMSetGlobalConstant(global, 1i32);
    }

    priv ProcessType(this: mut Compiler&, _type: QualifiedType*) -> QualifiedType* {
        if LLVMGetTypeKind(_type->Value()) != LLVMTypeKind::LLVMStructTypeKind {
            ret _type;
        } else {
            let size: u64 = LLVMABISizeOfType(this.layout, _type->Value());

            if size > 8u64 {
                ret this.type_manager.Pointer(_type, _type->IsMutable());
            } else {
                if size > 4u64 {
                    ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), true);
                } else if size > 2u64 {
                    ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), true);
                } else if size > 1u64 {
                    ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), true);
                } else {
                    ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true);
                }
            }
        }
    }

    priv CompileFunction(this: mut Compiler&, func_decl: FunctionDeclNode*) -> QualifiedValue {
        if func_decl->generic {
            this.Error("Generic functions are not supported yet.");
            ret QualifiedValue(null, null);
        }

        let (mut params: Vector<QualifiedType*>, mut param_types: Vector<LLVMTypeRef>);
        let mut return_type: QualifiedType* = this.CompileType(func_decl->_type->return_type);
        let mut attributes: Vector<LLVMTypeRef>;
        let mut sret: bool = false;

        if LLVMGetTypeKind(return_type->Value()) == LLVMTypeKind::LLVMStructTypeKind {
            let processed_type: mut QualifiedType& = this.ProcessType(return_type);
            processed_type.sret = return_type;

            if LLVMGetTypeKind(processed_type.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                return_type = processed_type;
            } else {
                params.PushBack(processed_type);
                param_types.PushBack(processed_type.Value());
                attributes.PushBack(return_type->Value());
                return_type = this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
                sret = true;
            }
        }

        let mut i: u64 = 0u64;

        while i < func_decl->_type->parameters.Size() {
            let param: ParameterNode* = func_decl->_type->parameters[i];
            let real_type: QualifiedType& = this.CompileType(param->param_type);
            let processed_type: mut QualifiedType& = this.ProcessType(real_type);
            param_types.PushBack(processed_type.Value());
            params.PushBack(processed_type);

            if real_type != processed_type {
                attributes.PushBack(LLVMGetTypeKind(processed_type.Value()) == LLVMTypeKind::LLVMPointerTypeKind ? real_type.Value() : null);
                processed_type.byval = real_type;
            } else {
                attributes.PushBack(null);
            } i += 1u64;
        }

        let mut name: String = func_decl->name;
        let type_ref: LLVMTypeRef = LLVMFunctionType(return_type->Value(), param_types.Data(), param_types.Size() as u32, func_decl->_type->var_arg ? 1i32 : 0i32);
        let _type: mut QualifiedType& = this.type_manager.Function(type_ref, params, return_type);
        let mangling: bool = this.mangling && name != "main";
        _type.name = name;

        if mangling {
            name = this.mangler.MangleFunction(func_decl->name, _type);
        }

        let function: LLVMValueRef = LLVMAddFunction(this.module, name.Data(), _type.Value());
        let value: QualifiedValue = QualifiedValue(function, this.type_manager.Pointer(_type, false));
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, value, mangling);
        let mut j: u64 = 0u64;

        while j < attributes.Size() {
            if attributes[j] != null {
                let attribute_kind: u32 = sret && j == 0u64 ? LLVMGetEnumAttributeKindForName("sret", 4u64) : LLVMGetEnumAttributeKindForName("byval", 5u64);
                LLVMAddAttributeAtIndex(function, (j + 1u64) as u32, LLVMCreateTypeAttribute(this.context, attribute_kind, attributes[j]));
            } j += 1u64;
        }

        if this._class == null && func_decl->constructors.Size() != 0u64 {
            this.Error("Constructors can only be declared inside classes.");
            ret value;
        }

        let mut k: u64 = 0u64;

        while func_decl->constructors.Size() > k {
            let _class: mut QualifiedType& = this.CompileType(func_decl->constructors[k]->expression);

            if !_class.IsClass() {
                this.Error("Constructor type must be a class.");
                ret value;
            }

            _class.constructed.PushBack(this._class);
            k += 1u64;
        }

        if func_decl->body != null {
            if this.generic != null {
                this.forwards.PushBack(Forward(func_decl, _type, function, this._class, this.generic->types, this.generic));
            } else {
                this.forwards.PushBack(Forward(func_decl, _type, function, this._class));
            }
        } ret value;
    }

    priv ValueToType(this: mut Compiler&, values: Vector<QualifiedValue>) -> Vector<QualifiedType*> {
        let mut result: Vector<QualifiedType*>;
        let mut i: u64 = 0u64;

        while i < values.Size() {
            result.PushBack(values[i].Type());
            i += 1u64;
        } ret result;
    }

    priv CompileConstructor(this: mut Compiler&, _class: QualifiedType&, pointer: QualifiedValue, params: Vector<QualifiedValue>) {
        let mut need_copy: bool = false;

        if params.Size() == 1u64 {
            if params[0u64].Type().IsPointer() {
                need_copy = params[0u64].Type().Pointee() == _class;
            }
        }

        let param_types: Vector<QualifiedType*> = this.ValueToType(params);
        let has_constructor: bool = _class.Has(_class.name, param_types);
        let (mut is_constructed: bool, mut i: u64) = (false, 0u64);

        while i < _class.constructed.Size() && this._class != null {
            let constructed: QualifiedType& = _class.constructed[i];

            if (*this._class) != constructed {
                i += 1u64;
            } else {
                is_constructed = true;
                break;
            }
        }

        let mut j: u64 = 0u64;
        let fields: mut Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();

        while j < fields.Size() {
            let field: mut Pair<String, Pair<Field, QualifiedType*>>& = fields[j];
            let mut value: QualifiedValue;

            if !(has_constructor && !is_constructed) && j < params.Size() {
                value = params[j];
            } else {
                if field.right.left.initializer != null {
                    value = this.CompileExpression(field.right.left.initializer, false);
                } else {
                    value = QualifiedValue(null, field.right.right);
                }
            }

            if need_copy && !(has_constructor && !is_constructed) {
                value = QualifiedValue(LLVMBuildStructGEP2(this.builder, params[0u64].Type().Pointee().Value(), params[0u64].Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true));
            }

            if field.right.right->IsClass() {
                let mut _params: Vector<QualifiedValue>;
                if !value.Null() { _params.PushBack(value); }
                this.CompileConstructor(field.right.right, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)), _params);
            } else if !value.Null() {
                if value.Type().IsPointer() {
                    let pointee: QualifiedType& = value.Type().Pointee();

                    if pointee == field.right.right {
                        value = QualifiedValue(LLVMBuildLoad2(this.builder, pointee.Value(), value.Value(), ""), pointee);
                    }
                }

                this.CompileAssignment2(value, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)), TokenType::ASSIGN, true);
            } j += 1u64;
        }

        if has_constructor && !is_constructed {
            let param_types: Vector<QualifiedType*> = this.ValueToType(params);

            if _class.Has(_class.name, param_types) {
                let method: Pair<Method, QualifiedType*>& = _class.Get(_class.name, param_types);
                this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, true);
            } else {
                this.Error("Class doesn't have compatible constructor.");
            }
        } else {
            if params.Size() > fields.Size() {
                this.Error("Too many parameters.");
            }
        }
    }

    priv CompileDestructor(this: mut Compiler&, _class: QualifiedType&, pointer: QualifiedValue) {
        let (params: Vector<QualifiedValue>, params_types: Vector<QualifiedType*>);

        if _class.Has(String("~") + _class.name, params_types) {
            let method: Pair<Method, QualifiedType*>& = _class.Get(String("~") + _class.name, params_types);
            this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, true);
        }

        let fields: mut Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();
        let mut i: u64 = 0u64;

        while i < fields.Size() {
            let field: mut Pair<String, Pair<Field, QualifiedType*>>& = fields[i];

            if field.right.right->IsClass() {
                this.CompileDestructor(field.right.right, QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(field.right.right, true)));
            } i += 1u64;
        }
    }

    priv CompileDestructor2(this: mut Compiler&, value: LLVMValueRef, _type: QualifiedType*) {
        this.CompileDestructor(_type->Pointee(), QualifiedValue(value, _type));
    }

    priv CompileClass(this: mut Compiler&, class_decl: ClassDeclNode*, generic: mut Generic*) -> QualifiedType* {
        if class_decl->generic {
            if generic != null {
                this.Error("Nested generics are not supported.");
                ret null;
            }

            let _generic: mut Generic* = new Generic(this as void*, class_decl, &this.mangler, &this.scope_manager, &this.generic);
            _generic->CompileClass = Compiler::CompileClass;
            this.scope_manager.Set(class_decl->name, SymbolKind::Generic, _generic as void*, false);
            this.generics.PushBack(_generic);
            ret null;
        }

        let mut struct_name: i8* = class_decl->name.Data();
        if generic != null { struct_name = generic->current.Data(); }
        let _class: mut QualifiedType& = this.type_manager.Class(LLVMStructCreateNamed(this.context, struct_name), class_decl->name);

        if generic != null { generic->Set(_class); } else {
            this.scope_manager.Set(class_decl->name, SymbolKind::Class, QualifiedValue(null, _class), false);
        }

        let mut field_types: Vector<LLVMTypeRef>; 
        let (mut i: u64, mut j: u64) = (0u64, 0u64);

        while i < class_decl->parents.Size() {
            let _type: QualifiedType& = this.CompileType(class_decl->parents[i]);
            _class.fields[_type.name] = Pair<Field, QualifiedType*>(Field(null, TokenType::PRIVATE, i), _type);
            field_types.PushBack(_type.Value());
            i += 1u64;
        }

        while j < class_decl->fields.Size() {
            let field: Pair<TokenType, FieldNode*>& = class_decl->fields[j];
            let field_type: QualifiedType& = this.CompileType(field.right->field_type);
            _class.fields[field.right->name] = Pair<Field, QualifiedType*>(Field(field.right->initializer, field.left, j), field_type);
            field_types.PushBack(field_type.Value());
            j += 1u64;
        }

        let (mut alignment: u32, mut k: u64) = (0u32, 0u64);

        while k < field_types.Size() {
            let _alignment: u32 = LLVMABIAlignmentOfType(this.layout, field_types[k]);

            if _alignment > alignment {
                alignment = _alignment;
            } k += 1u64;
        }

        let mut field_types2: Vector<LLVMTypeRef>;
        let (mut offset: u64, mut l: u64) = (0u64, 0u64);

        while l < field_types.Size() + 1u64 {
            let (mut size: u64, mut _alignment: u32) = (0u64, 0u32);

            if l != field_types.Size() {
                _alignment = LLVMABIAlignmentOfType(this.layout, field_types[l]);
                size = LLVMABISizeOfType(this.layout, field_types[l]);
            }

            let mut m: u64 = 0u64;

            while m < 2u64 {
                let n: u64 = (m > 0u64 ? _alignment : alignment) as u64;

                if n != 0u64 {
                    if (offset % n) != 0u64 && (l == field_types.Size() || (offset % n) + size > n) {
                        let padding: u64 = n - (offset % n);
                        field_types2.PushBack(LLVMArrayType(LLVMInt8TypeInContext(this.context), padding as u32));
                        offset += padding;
                    }
                } m += 1u64;
            }

            if l != field_types.Size() {
                field_types2.PushBack(field_types[l]);
                _class.fields[l].right.left.index = field_types2.Size() - 1u64;
                offset += size;
            } l += 1u64;
        }

        let prev_class: QualifiedType* = this._class;
        this._class = _class;

        if field_types2.Size() != 0u64 {
            LLVMStructSetBody(_class.Value(), field_types2.Data(), field_types2.Size() as u32, 1i32);
        }

        this.scope_manager.PushScope(class_decl->name, true);
        let (mut m: u64, mut n: u64) = (0u64, 0u64);

        while m < class_decl->constructors.Size() {
            let method: QualifiedValue = this.CompileFunction(class_decl->constructors[m]);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->constructors[m]->name, method.Value(), TokenType::PUBLIC), method.Type()));
            m += 1u64;
        }

        if class_decl->destructor != null {
            let method: QualifiedValue = this.CompileFunction(class_decl->destructor);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->destructor->name, method.Value(), TokenType::PUBLIC), method.Type()));
        }

        while n < class_decl->methods.Size() {
            let method: QualifiedValue = this.CompileFunction(class_decl->methods[n].right);
            _class.methods.PushBack(Pair<Method, QualifiedType*>(Method(class_decl->methods[n].right->name, method.Value(), class_decl->methods[n].left), method.Type()));
            n += 1u64;
        }

        this.scope_manager.PopScope();
        this._class = prev_class;
        ret _class;
    }

    priv CompileEnum(this: mut Compiler&, enum_decl: mut EnumDeclNode*) {
        let underlying_type: QualifiedType& = this.CompileType(enum_decl->underlying_type);

        if LLVMGetTypeKind(underlying_type.Value()) != LLVMTypeKind::LLVMIntegerTypeKind {
            this.Error("Expected an integer type.");
            ret;
        }

        this.scope_manager.Set(enum_decl->name, SymbolKind::Type, QualifiedValue(null, underlying_type), false);
        let mut value: LLVMValueRef = LLVMConstInt(underlying_type.Value(), 0u64, underlying_type.IsSigned() ? 1i32 : 0i32);
        this.scope_manager.PushScope(enum_decl->name, true);
        let mut i: u64 = 0u64;

        while i < enum_decl->values.Size() {
            if enum_decl->values[i].right != null {
                let _value: QualifiedValue = this.CompileExpression(enum_decl->values[i].right, false);

                if _value.Type() == underlying_type {
                    value = _value.Value();
                } else {
                    this.Error((String("Incompatible enum value types. ('") + LLVMTypeToString(_value.Type().Value()) + "' != '" + LLVMTypeToString(underlying_type.Value()) + "').").Data());
                    ret;
                }
            }

            this.scope_manager.Set(enum_decl->values[i].left, SymbolKind::Constant, QualifiedValue(value, underlying_type), false);
            value = LLVMConstAdd(value, LLVMConstInt(underlying_type.Value(), 1u64, underlying_type.IsSigned() ? 1i32 : 0i32));
            i += 1u64;
        }

        this.scope_manager.PopScope();
    }

    priv CompileExtern(this: mut Compiler&, extern_block: ExternBlockNode*) {
        if !this.mangling {
            this.Error("Already in a extern block.");
            ret;
        }

        if extern_block->linkage != "C" {
            this.Error((String("Unknown linkage '") + extern_block->linkage + "'.").Data());
            ret;
        }

        this.mangling = false;
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        this.mangling = true;
    }

    priv CompileBlock(this: mut Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(this: mut Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            this.CompileReturn(stmt as ReturnStmtNode*);
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression, false);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::LOOP_STMT {
            this.CompileLoop(stmt as LoopStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement '") + ASTNodeTypeToString(stmt->node_type) + "'.").Data());
        }
    }

    priv CompileReturn(this: mut Compiler&, ret_stmt: ReturnStmtNode*) {
        if ret_stmt->expression != null {
            let return: QualifiedType& = this.function->Return();
            let params: Vector<QualifiedType*> = this.function->Parameters();
            let mut state: bool = false;

            if params.Size() > 0u64 {
                state = params[0u64]->sret != null;
            }

            if return.sret != null || state {
                let mut value: QualifiedValue = this.CompileExpression(ret_stmt->expression, true);

                if value.Type().Pointee().IsReference() {
                    value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                }

                if LLVMGetTypeKind(return.Value()) == LLVMTypeKind::LLVMIntegerTypeKind {
                    if *return.sret != value.Type().Pointee() {
                        this.Error((String("Incompatible return types. ('") + LLVMTypeToString(return.sret->Value()) + "' != '" + LLVMTypeToString(value.Type().Pointee().Value()) + "').").Data());
                        ret;
                    }

                    this.scope_manager.InvokeDestructors(value);
                    LLVMBuildRet(this.builder, LLVMBuildLoad2(this.builder, return.Value(), value.Value(), ""));
                } else {
                    if *params[0u64]->sret != value.Type().Pointee() {
                        this.Error((String("Incompatible return types. ('") + LLVMTypeToString(return.sret->Value()) + "' != '" + LLVMTypeToString(value.Type().Pointee().Value()) + "').").Data());
                        ret;
                    }

                    let mut _params: Vector<QualifiedValue>;
                    _params.PushBack(value);
                    this.CompileConstructor(value.Type().Pointee(), QualifiedValue(LLVMGetParam(this.function_ref, 0u32), params[0u64]), _params);
                    this.scope_manager.InvokeDestructors(value);
                    LLVMBuildRetVoid(this.builder);
                }
            } else {
                let mut value: QualifiedValue = this.CompileExpression(ret_stmt->expression, false);

                if value.Type().IsReference() {
                    if return == value.Type().Pointee() {
                        value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                    }
                }

                if return.IsReference() {
                    if return.Pointee() == value.Type() {
                        value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
                    }
                }

                let mut state: bool = false;

                if return.IsPointer() && value.Type().IsPointer() {
                    if LLVMGetTypeKind(return.Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(value.Type().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                        state = true;
                    }
                }

                if return != value.Type() && !state {
                    this.Error((String("Incompatible return types. ('") + LLVMTypeToString(return.Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                    ret;
                }

                this.scope_manager.InvokeDestructors();
                LLVMBuildRet(this.builder, value.Value());
            }
        } else {
            this.scope_manager.InvokeDestructors();
            LLVMBuildRetVoid(this.builder);
        }
    }

    priv CompileIf(this: mut Compiler&, if_stmt: IfStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let (mut current: IfStmtNode*, mut end_block: LLVMBasicBlockRef) = (if_stmt, null);

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement '") + ASTNodeTypeToString(else_stmt->node_type) + "'.").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } then_block = end_block;
            }

            let mut else_block: LLVMBasicBlockRef;

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, function, "");
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                } else_block = end_block;
            }

            let condition: QualifiedValue = this.CompileExpression(current->condition, false);
            LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, function, "");
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(this: mut Compiler&, while_stmt: WhileStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

        if while_stmt->else_stmt != null {
            let else_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
            let condition: QualifiedValue = this.CompileExpression(while_stmt->condition, false);
            LLVMBuildCondBr(this.builder, condition.Value(), loop_block, else_block);

            LLVMPositionBuilderAtStart(this.builder, else_block);
            this.scope_manager.PushScope(String("else"), false);
            this.CompileBlock(while_stmt->else_stmt as BlockStmtNode*);
            this.scope_manager.PopScope();

            if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                LLVMBuildBr(this.builder, end_block);
            }
        } else {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: QualifiedValue = this.CompileExpression(while_stmt->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->loop_stmt as BlockStmtNode*);
        this.scope_manager.PopScope();
        this.blocks.PopBack();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
    }

    priv CompileLoop(this: mut Compiler&, loop_stmt: LoopStmtNode*) {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(loop_block, end_block));

        LLVMBuildBr(this.builder, loop_block);
        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("loop"), false);
        this.CompileBlock(loop_stmt->loop_stmt as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, loop_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        // this.scope_manager.InvokeDestructors();
        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        // this.scope_manager.InvokeDestructors();
        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(this: mut Compiler&, variable: VariableDeclNode*) {
        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        let mut _type: QualifiedType* = this.CompileType(variable->_type);

        if _type->IsClass() {
            let mut params: Vector<QualifiedValue>;
            let mut skip: bool = false;

            if variable->initializer != null {
                if variable->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
                    let mut value: QualifiedValue = this.CompileExpression(variable->initializer, false);

                    if !value.return {
                        if value.Type() == *_type {
                            value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), true));
                        } params.PushBack(value);
                    } else {
                        if *_type == value.Type() {
                            this.scope_manager.Set(variable->name, SymbolKind::Variable, QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(_type, variable->mutable), false, true), false);
                            skip = true;
                        } else {
                            this.Error((String("Incompatible variable initialization types. ('") + LLVMTypeToString(_type->Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                            ret;
                        }
                    }
                } else {
                    let initializer_list: InitializerListNode* = variable->initializer as InitializerListNode*;
                    let mut i: u64 = 0u64;

                    while i < initializer_list->expressions.Size() {
                        params.PushBack(this.CompileExpression(initializer_list->expressions[i], false));
                        i += 1u64;
                    }
                }
            }

            if !skip {
                LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                let instance: QualifiedValue = QualifiedValue(LLVMBuildAlloca(this.builder, _type->Value(), ""), this.type_manager.Pointer(_type, variable->mutable), false, true);
                LLVMPositionBuilderAtEnd(this.builder, current);

                this.CompileConstructor(_type, instance, params);
                this.scope_manager.Set(variable->name, SymbolKind::Variable, instance, false);
                this.scope_manager.RegisterInstance(instance);
            }
        } else {
            if variable->initializer != null {
                if variable->initializer->node_type == ASTNodeType::INITIALIZER_LIST {
                    let list: InitializerListNode* = variable->initializer as InitializerListNode*;

                    if variable->_type->node_type == ASTNodeType::ARRAY_TYPE {
                        let array: ArrayTypeNode* = variable->_type as ArrayTypeNode*;

                        if array->size == null && list->expressions.Size() > 0u64 {
                            _type = this.type_manager.Array(_type->Pointee(), list->expressions.Size(), _type->IsMutable());
                        }
                    }
                }
            }

            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let pointer: QualifiedValue = QualifiedValue(LLVMBuildAlloca(this.builder, _type->Value(), ""), this.type_manager.Pointer(_type, variable->mutable), false, true);
            LLVMPositionBuilderAtEnd(this.builder, current);

            if variable->initializer != null {
                if variable->initializer->node_type != ASTNodeType::INITIALIZER_LIST {
                    let mut initializer: QualifiedValue = this.CompileExpression(variable->initializer, false);

                    if initializer.Type().IsReference() {
                        if *_type == initializer.Type().Pointee() {
                            initializer = QualifiedValue(LLVMBuildLoad2(this.builder, initializer.Type().Pointee().Value(), initializer.Value(), ""), initializer.Type().Pointee());
                        }
                    }

                    if _type->IsReference() {
                        if _type->Pointee() == initializer.Type() {
                            initializer = QualifiedValue(LLVMAddressOf(initializer.Value()), this.type_manager.Pointer(initializer.Type(), initializer.Type().IsMutable()));
                        }
                    }

                    let mut state: bool = false;

                    if _type->IsPointer() && initializer.Type().IsPointer() {
                        if LLVMGetTypeKind(_type->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(initializer.Type().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                            state = true;
                        }
                    }

                    if *_type != initializer.Type() && !state {
                        this.Error((String("Incompatible variable initialization types. ('") + LLVMTypeToString(_type->Value()) + "' != '" + LLVMTypeToString(initializer.Type().Value()) + "').").Data());
                        ret;
                    }

                    LLVMBuildStore(this.builder, initializer.Value(), pointer.Value());
                } else {
                    let initializer_list: InitializerListNode* = variable->initializer as InitializerListNode*;
                    let mut i: u64 = 0u64;

                    while i < initializer_list->expressions.Size() {
                        let value: QualifiedValue = this.CompileExpression(initializer_list->expressions[i], false);
                        let indices[]: LLVMValueRef = { LLVMConstInt(LLVMInt32TypeInContext(this.context), i, 0i32) };
                        LLVMBuildStore(this.builder, value.Value(), LLVMBuildGEP2(this.builder, _type->Element().Value(), pointer.Value(), indices, 1u32, ""));
                        i += 1u64;
                    }
                }
            }

            this.scope_manager.Set(variable->name, SymbolKind::Variable, pointer, false);
        }

        if variable->next != null {
            this.CompileVariable(variable->next);
        }
    }

    priv CompileAssignment(this: mut Compiler&, assignment: AssignmentNode*) -> QualifiedValue {
        let pointer: QualifiedValue = this.CompileExpression(assignment->left, true);
        let mut value: QualifiedValue = this.CompileExpression(assignment->right, false);
        value = this.CompileAssignment2(value, pointer, assignment->operator, false);

        if assignment->next != null {
            this.CompileAssignment(assignment->next);
            ret QualifiedValue(null, null);
        } else {
            ret value;
        }
    }

    priv CompileAssignment2(this: mut Compiler&, mut value: QualifiedValue, mut pointer: QualifiedValue, operator: TokenType, ignore: bool) -> QualifiedValue {
        if pointer.Type().Pointee().IsReference() {
            pointer = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
        }

        if pointer.Type().Pointee().IsClass() {
            let mut params: Vector<QualifiedValue>;
            params.PushBack(value);

            let mut method_name: String = "op";
            method_name += AssignmentOperatorToString(operator);
            let param_types: Vector<QualifiedType*> = this.ValueToType(params);
            let _class: QualifiedType& = pointer.Type().Pointee();

            if _class.Has(method_name, param_types) {
                let method: Pair<Method, QualifiedType*>& = _class.Get(method_name, param_types);
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, pointer), params, false, false);
            }

            if !pointer.Type().IsMutable() && !ignore {
                this.Error("Cannot assign to immutable variable.");
                ret QualifiedValue(null, null);
            }

            if value.Type().IsReference() {
                if value.Type().Pointee() == _class {
                    value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                }
            }

            if value.Type() == _class {
                if operator != TokenType::ASSIGN {
                    this.Error((String("Invalid class assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(_class.Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }

                let fields: mut Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();
                value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), true));
                let mut i: u64 = 0u64;

                while i < fields.Size() {
                    let field: mut Pair<String, Pair<Field, QualifiedType*>>& = fields[i];
                    let mut _type: QualifiedType* = field.right.right;

                    if _type->IsPointer() {
                        _type = this.type_manager.Copy(_type, true);
                    }

                    let _value: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, _type->Value(), LLVMBuildStructGEP2(this.builder, value.Type().Pointee().Value(), value.Value(), _class.Index(field.left) as u32, ""), ""), _type);
                    let _pointer: QualifiedValue = QualifiedValue(LLVMBuildStructGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), _class.Index(field.left) as u32, ""), this.type_manager.Pointer(_type, true));
                    this.CompileAssignment2(_value, _pointer, operator, ignore);
                    i += 1u64;
                }
            } else {
                this.Error((String("Incompatible class assignment types. ('") + LLVMTypeToString(_class.Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            if operator != TokenType::ASSIGN {
                let other: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
                let (value_kind: LLVMTypeKind, other_kind: LLVMTypeKind) = (LLVMGetTypeKind(pointer.Type().Pointee().Value()), LLVMGetTypeKind(value.Type().Value()));

                if value.Type().IsPointer() && other.Type().IsPointer() {
                    if operator == TokenType::MINUS_ASSIGN {
                        let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false);
                        value = QualifiedValue(LLVMBuildSub(this.builder, LLVMBuildPtrToInt(this.builder, other.Value(), _type.Value(), ""), LLVMBuildPtrToInt(this.builder, value.Value(), _type.Value(), ""), ""), _type);
                    } else {
                        this.Error((String("Invalid pointer assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if (value.Type().IsPointer() && other_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (value_kind == LLVMTypeKind::LLVMIntegerTypeKind && other.Type().IsPointer()) {
                    let ptr: QualifiedValue& = value.Type().IsPointer() ? &value : &other;
                    let index: QualifiedValue& = value.Type().IsPointer() ? &other : &value;
                    let width: u32 = LLVMGetIntTypeWidth(index.Type().Value());

                    if width == 64u32 {
                        if operator == TokenType::PLUS_ASSIGN {
                            let indices[]: LLVMValueRef = { index.Value() };
                            value = QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Pointee().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                        } else if operator == TokenType::MINUS_ASSIGN {
                            let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), "") };
                            value = QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Pointee().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                        } else {
                            this.Error((String("Invalid pointer assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(ptr.Type().Value()) + "'.").Data());
                            ret QualifiedValue(null, null);
                        }
                    } else {
                        this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind && other_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type() != other.Type() {
                        this.Error((String("Incompatible assignment operation types. ('") + LLVMTypeToString(value.Type().Value()) + "' != '" + LLVMTypeToString(other.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    if operator == TokenType::PLUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildAdd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MINUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildSub(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MUL_ASSIGN {
                        value = QualifiedValue(LLVMBuildMul(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::DIV_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildSDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildUDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else if operator == TokenType::MOD_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildSRem(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildURem(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else if operator == TokenType::AND_ASSIGN {
                        value = QualifiedValue(LLVMBuildAnd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::OR_ASSIGN {
                        value = QualifiedValue(LLVMBuildOr(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::XOR_ASSIGN {
                        value = QualifiedValue(LLVMBuildXor(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::LSHIFT_ASSIGN {
                        value = QualifiedValue(LLVMBuildShl(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::RSHIFT_ASSIGN {
                        if value.Type().IsSigned() {
                            value = QualifiedValue(LLVMBuildAShr(this.builder, other.Value(), value.Value(), ""), value.Type());
                        } else {
                            value = QualifiedValue(LLVMBuildLShr(this.builder, other.Value(), value.Value(), ""), value.Type());
                        }
                    } else {
                        this.Error((String("Invalid assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if (value_kind == LLVMTypeKind::LLVMFloatTypeKind || value_kind == LLVMTypeKind::LLVMDoubleTypeKind) && (other_kind == LLVMTypeKind::LLVMFloatTypeKind || other_kind == LLVMTypeKind::LLVMDoubleTypeKind) {
                    if value.Type() != other.Type() {
                        this.Error((String("Incompatible assignment operation types. ('") + LLVMTypeToString(value.Type().Value()) + "' != '" + LLVMTypeToString(other.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    if operator == TokenType::PLUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildFAdd(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MINUS_ASSIGN {
                        value = QualifiedValue(LLVMBuildFSub(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MUL_ASSIGN {
                        value = QualifiedValue(LLVMBuildFMul(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::DIV_ASSIGN {
                        value = QualifiedValue(LLVMBuildFDiv(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else if operator == TokenType::MOD_ASSIGN {
                        value = QualifiedValue(LLVMBuildFRem(this.builder, other.Value(), value.Value(), ""), value.Type());
                    } else {
                        this.Error((String("Invalid assignment operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Invalid type '") + LLVMTypeToString(value.Type().Value()) + "' for assignment operation '" + TokenTypeToString(operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            }

            if !pointer.Type().IsMutable() && !ignore {
                this.Error("Cannot assign to immutable variable.");
                ret QualifiedValue(null, null);
            }

            if value.Type().IsReference() {
                if pointer.Type().Pointee() == value.Type().Pointee() {
                    value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                }
            }

            let mut state: bool = false;

            if pointer.Type().Pointee().IsPointer() && value.Type().IsPointer() {
                if LLVMGetTypeKind(pointer.Type().Pointee().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(value.Type().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                    state = true;
                }
            }

            if value.Type() != pointer.Type().Pointee() && !state {
                this.Error((String("Incompatible assignment types. ('") + LLVMTypeToString(pointer.Type().Pointee().Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            LLVMBuildStore(this.builder, value.Value(), pointer.Value());
        } ret pointer;
    }

    priv CompileExpression(this: mut Compiler&, expr: ASTNode*, pointer: bool) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            if !pointer {
                ret this.CompileLiteral(expr as LiteralNode*);
            } else {
                this.Error("Invalid pointer literal expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CALL {
            let value: QualifiedValue = this.CompileCall(expr as CallNode*, pointer);

            if !pointer || (pointer && value.Type().IsPointer()) {
                ret value;
            } else {
                this.Error("Invalid pointer call expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::TERNARY {
            ret this.CompileTernary(expr as TernaryNode*, pointer);
        } else if expr->node_type == ASTNodeType::IDENTIFIER || expr->node_type == ASTNodeType::SCOPE_RESOLUTION {
            let symbol: Symbol* = this.scope_manager.Resolve(expr);
            let (mut value: QualifiedValue, mut state: bool) = (symbol->value, false);

            if value.Type().IsPointer() {
                if value.Type().Pointee().byval != null {
                    let mut _type: QualifiedType* = value.Type().Pointee();

                    if _type->IsPointer() {
                        _type = this.type_manager.Copy(_type, value.Type().IsMutable());
                    }

                    (value, state) = (QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), _type, false, value.binding), true);
                }
            }

            if (symbol->kind == SymbolKind::Variable || symbol->kind == SymbolKind::GlobalVariable || symbol->kind == SymbolKind::Constant || symbol->kind == SymbolKind::Parameter) && !pointer {
                let mut _type: QualifiedType* = value.Type();

                while !state {
                    if _type->IsPointer() {
                        _type = _type->Pointee();
                    } else {
                        if _type->IsClass() {
                            state = true;
                        } break;
                    }
                }

                if symbol->value.Type().IsPointer() {
                    if symbol->value.Type().Pointee().IsArray() {
                        let _type: QualifiedType& = this.type_manager.Pointer(symbol->value.Type().Pointee().Element(), symbol->value.Type().IsMutable());
                        ret QualifiedValue(LLVMBuildBitCast(this.builder, symbol->value.Value(), _type.Value(), ""), _type);
                    }
                }

                if symbol->kind == SymbolKind::Constant || (symbol->kind == SymbolKind::Parameter && !value.Type().IsMutable() && !state) {
                    ret value;
                } else if symbol->kind == SymbolKind::GlobalVariable && !value.Type().Pointee().IsClass() && !value.Type().Pointee().IsPointer() {
                    ret QualifiedValue(LLVMGetInitializer(value.Value()), value.Type().Pointee());
                } else {
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                }
            } else if symbol->kind == SymbolKind::Function || pointer {
                ret value;
            } else {
                this.Error((String("Invalid symbol kind '") + SymbolKindToString(symbol->kind) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::NEW {
            ret this.CompileNew(expr as NewNode*);
        } else if expr->node_type == ASTNodeType::DELETE {
            ret this.CompileDelete(expr as DeleteNode*);
        } else if expr->node_type == ASTNodeType::CAST {
            let value: QualifiedValue = this.CompileCast(expr as CastNode*, pointer);

            if !pointer || (pointer && value.Type().IsPointer()) {
                ret value;
            } else {
                this.Error("Invalid pointer cast expression.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::INDEX_ACCESS {
            ret this.CompileIndexAccess(expr as IndexAccessNode*, pointer);
        } else if expr->node_type == ASTNodeType::MEMBER_ACCESS {
            ret this.CompileMemberAccess(expr as MemberAccessNode*, pointer);
        } else if expr->node_type == ASTNodeType::UNARY_OP {
            ret this.CompileUnaryOperation(expr as UnaryOpNode*, pointer);
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            ret this.CompileBinaryOperation(expr as BinaryOpNode*, pointer);
        } else {
            this.Error((String("Unknown expression '") + ASTNodeTypeToString(expr->node_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileLiteral(this: mut Compiler&, literal: LiteralNode*) -> QualifiedValue {
        if literal->literal_type == TokenType::INTEGER {
            let (mut state: bool, mut base: i32) = (false, 10i32);
            let (mut signed: bool, mut width: u64) = (true, 32u64);
            let (mut value: String, mut size: String);
            let mut i: u64 = 0u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == '0' && (literal->value[i + 1u64] == 'x' || literal->value[i + 1u64] == 'o' || literal->value[i + 1u64] == 'b') {
                        if i != 0u64 || base != 10i32 {
                            this.Error((String("Invalid integer literal '") + literal->value + "'.").Data());
                            ret QualifiedValue(null, null);
                        } else {
                            base = literal->value[i + 1u64] == 'x' ? 16i32 : (literal->value[i + 1u64] == 'o' ? 8i32 : 2i32);
                        } i += 1u64;
                    } else if literal->value[i] == 'u' {
                        (signed, state) = (false, true);
                    } else if literal->value[i] == 'i' {
                        (signed, state) = (true, true);
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 128u64 {
                _type = LLVMInt128TypeInContext(this.context);
            } else if width == 64u64 {
                _type = LLVMInt64TypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMInt32TypeInContext(this.context);
            } else if width == 16u64 {
                _type = LLVMInt16TypeInContext(this.context);
            } else if width == 8u64 {
                _type = LLVMInt8TypeInContext(this.context);
            } else {
                this.Error((String("Invalid integer size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstInt(_type, value.ToInteger(base) as u64, signed ? 1i32 : 0i32), this.type_manager.Primitive(_type, signed));
        } else if literal->literal_type == TokenType::FLOAT {
            let (mut state: bool, mut i: u64) = (false, 0u64);
            let (mut value: String, mut size: String);
            let mut width: u64 = 32u64;

            while i < literal->value.Size() {
                if !state {
                    if literal->value[i] == 'f' {
                        state = true;
                    } else {
                        value += literal->value[i];
                    }
                } else {
                    size += literal->value[i];
                } i += 1u64;
            }

            let mut _type: LLVMTypeRef;
            width = size.ToInteger() as u64;

            if width == 64u64 {
                _type = LLVMDoubleTypeInContext(this.context);
            } else if width == 32u64 {
                _type = LLVMFloatTypeInContext(this.context);
            } else {
                this.Error((String("Invalid float size '") + size +  "'.").Data());
                ret QualifiedValue(null, null);
            }

            ret QualifiedValue(LLVMConstReal(_type, value.ToFloat()), this.type_manager.Primitive(_type, false));
        } else if literal->literal_type == TokenType::TRUE || literal->literal_type == TokenType::FALSE {
            let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            ret QualifiedValue(LLVMConstInt(_type.Value(), literal->literal_type == TokenType::TRUE ? 1u64 : 0u64, 0i32), _type);
        } else if literal->literal_type == TokenType::STRING {
            let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "");
            ret QualifiedValue(value, this.type_manager.Pointer(this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true), false));
        } else if literal->literal_type == TokenType::CHAR {
            if (literal->value.Size() == 2u64 && literal->value[1u64] == '\0') || (literal->value.Size() == 1u64 && literal->value[0u64] == '\0') {
                let character: i8 = literal->value[0u64];
                let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), true);
                ret QualifiedValue(LLVMConstInt(_type.Value(), character as u64, 0i32), _type);
            } else {
                this.Error((String("Invalid character literal '") + literal->value + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if literal->literal_type == TokenType::NULL {
            let _type: QualifiedType& = this.type_manager.Pointer(this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false), false);
            ret QualifiedValue(LLVMConstNull(_type.Value()), _type);
        } else {
            this.Error((String("Unknown literal type '") + TokenTypeToString(literal->literal_type) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileCall(this: mut Compiler&, call: CallNode*, pointer: bool) -> QualifiedValue {
        if call->expression->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = call->expression as IdentifierNode*;

            if identifier->name == "sizeof" {
                if call->arguments.Size() != 1u64 {
                    this.Error("Invalid number of arguments for 'sizeof'.");
                    ret QualifiedValue(null, null);
                }

                let value: QualifiedValue = this.CompileExpression(call->arguments[0u64], true);
                let size: u64 = LLVMStoreSizeOfType(this.layout, value.Type().Pointee().Value());
                let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false);
                ret QualifiedValue(LLVMConstInt(_type.Value(), size, 0i32), _type);
            }
        }

        let mut values: Vector<QualifiedValue>;
        let mut i: u64 = 0u64;

        while i < call->arguments.Size() {
            values.PushBack(this.CompileExpression(call->arguments[i], false));
            i += 1u64;
        }

        if call->expression->node_type == ASTNodeType::MEMBER_ACCESS {
            let member_access: MemberAccessNode* = call->expression as MemberAccessNode*;
            let mut instance: QualifiedValue = this.CompileExpression(member_access->expression, true);

            if instance.Type().Pointee().IsReference() {
                instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee(), false, instance.binding);
            }

            if instance.binding || instance.Type().IsReference() {
                if member_access->arrow {
                    instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee(), false, instance.binding);
                }
            } else {
                if !member_access->arrow && !instance.return {
                    this.Error("Expected an arrow operator.");
                    ret QualifiedValue(null, null);
                }
            }

            if !instance.Type().IsPointer() {
                this.Error("Member access value must be a pointer.");
                ret QualifiedValue(null, null);
            }

            if !instance.Type().Pointee().IsClass() {
                this.Error((String("Cannot access member '") + member_access->member + "' of non-class type.").Data());
                ret QualifiedValue(null, null);
            }

            let mut state: bool = true;
            let index: i64 = instance.Type().Pointee().Index(member_access->member);
            if this._class != null { state = (*this._class) != instance.Type().Pointee(); }

            if index != -1i64 {
                let field: Pair<Field, QualifiedType*>& = instance.Type().Pointee().Fields()[member_access->member];

                if field.left.visibility != TokenType::PUBLIC && state {
                    this.Error((String("Field '") + member_access->member + "' is private.").Data());
                    ret QualifiedValue(null, null);
                }

                let field_pointer: LLVMValueRef = LLVMBuildStructGEP2(this.builder, instance.Type().Pointee().Value(), instance.Value(), index as u32, "");
                ret this.CompileCall2(QualifiedValue(LLVMBuildLoad2(this.builder, field.right->Value(), field_pointer, ""), field.right), values, pointer, false);
            } else {
                let method: Pair<Method, QualifiedType*>& = instance.Type().Pointee().Get(member_access->member, this.ValueToType(values));
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, instance), values, pointer, false);
            }
        } else if call->expression->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let _class: QualifiedType& = this.CompileType(call->expression);
            let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let instance: QualifiedValue = QualifiedValue(LLVMBuildAlloca(this.builder, _class.Value(), ""), this.type_manager.Pointer(_class, _class.IsMutable()), false, true);
            LLVMPositionBuilderAtEnd(this.builder, current);
            this.CompileConstructor(_class, instance, values);
            this.scope_manager.RegisterInstance(instance);

            if !pointer {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, _class.Value(), instance.Value(), ""), _class);
            } else {
                ret instance;
            }
        } else {
            ret this.CompileCall2(this.CompileExpression(call->expression, true), values, pointer, false);
        }
    }

    priv CompileCall2(this: mut Compiler&, _func: QualifiedValue, values: Vector<QualifiedValue>&, pointer: bool, ignore: bool) -> QualifiedValue {
        let mut args: Vector<LLVMValueRef>;
        let ret_type: QualifiedType& = _func.Type().Pointee().Return();
        let params: Vector<QualifiedType*> = _func.Type().Pointee().Parameters();
        let mut return: QualifiedValue = QualifiedValue(null, null);
        let mut i: u64 = 0u64;

        if params.Size() > 0u64 {
            if params[0u64]->sret != null {
                let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, params[0u64]->sret->Value(), "");
                return = QualifiedValue(_pointer, this.type_manager.Pointer(params[0u64]->sret, true), true, true);
                LLVMPositionBuilderAtEnd(this.builder, current);
                this.scope_manager.RegisterInstance(return);
                args.PushBack(return.Value());
            }
        }

        if _func.instance != null {
            let mut param: QualifiedType* = params[0u64];

            if param->sret != null {
                param = params[1u64];
            }

            if param->IsMutable() && !_func.instance_type->IsMutable() && !ignore {
                this.Error((String("Cannot call mutable method '") + _func.Type().Pointee().name + "' on immutable instance.").Data());
                ret QualifiedValue(null, null);
            } else {
                args.PushBack(_func.instance);
            }
        }

        while i < values.Size() {
            let mut value: QualifiedValue = values[i];
            let mut index: u64 = params[0u64]->sret != null ? i + 1u64 : i;

            if _func.instance != null {
                index += 1u64;
            }

            if index < params.Size() {
                let param: QualifiedType& = params[index];

                if param.byval != null {
                    if value.Type().IsReference() {
                        value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                    }

                    let mut state: bool = false;

                    if param.byval->IsPointer() && value.Type().IsPointer() {
                        if LLVMGetTypeKind(param.byval->Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(value.Type().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                            state = true;
                        }
                    }

                    if *param.byval != value.Type() && !state {
                        this.Error((String("Incompatible argument types for function '") + _func.Type().Pointee().name + "'. ('" + LLVMTypeToString(param.byval->Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    let mut _params: Vector<QualifiedValue>;
                    value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
                    _params.PushBack(value);
                    let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
                    LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
                    let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, value.Type().Pointee().Value(), "");
                    LLVMPositionBuilderAtEnd(this.builder, current);
                    value = QualifiedValue(pointer, value.Type());
                    this.CompileConstructor(value.Type().Pointee(), value, _params);

                    if LLVMGetTypeKind(param.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                        args.PushBack(LLVMBuildLoad2(this.builder, param.Value(), value.Value(), ""));
                    } else {
                        args.PushBack(value.Value());
                    }
                } else {
                    if value.Type().IsReference() {
                        if param == value.Type().Pointee() {
                            value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                        }
                    }

                    if param.IsReference() {
                        if param.Pointee() == value.Type() {
                            value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
                        }
                    }

                    let mut state: bool = false;

                    if param.IsPointer() && value.Type().IsPointer() {
                        if LLVMGetTypeKind(param.Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind || LLVMGetTypeKind(value.Type().Pointee().Value()) == LLVMTypeKind::LLVMVoidTypeKind {
                            state = true;
                        }
                    }

                    if param != value.Type() && !state {
                        this.Error((String("Incompatible argument types for function '") + _func.Type().Pointee().name + "'. ('" + LLVMTypeToString(param.Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                        ret QualifiedValue(null, null);
                    }

                    args.PushBack(value.Value());
                }
            } else {
                if value.Type().IsReference() {
                    value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                } args.PushBack(value.Value());
            } i += 1u64;
        }

        let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.Type().Pointee().Value(), _func.Value(), args.Data(), args.Size() as u32, "");

        if ret_type.sret != null {
            let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, ret_type.sret->Value(), "");
            return = QualifiedValue(_pointer, this.type_manager.Pointer(ret_type.sret, true), true, true);
            LLVMPositionBuilderAtEnd(this.builder, current);
            LLVMBuildStore(this.builder, value, LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(ret_type.Value(), 0u32), ""));
            this.scope_manager.RegisterInstance(return);
        }

        if return.Null() {
            ret QualifiedValue(value, ret_type);
        } else {
            if !pointer {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, return.Type().Pointee().Value(), return.Value(), ""), return.Type().Pointee(), true);
            } else {
                ret return;
            }
        }
    }

    priv CompileTernary(this: mut Compiler&, ternary: TernaryNode*, pointer: bool) -> QualifiedValue {
        let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
        let mut then_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let mut else_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
        let merge_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

        let condition: QualifiedValue = this.CompileExpression(ternary->condition, false);
        LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

        LLVMPositionBuilderAtEnd(this.builder, then_block);
        let then_value: QualifiedValue = this.CompileExpression(ternary->then_expr, pointer);
        then_block = LLVMGetInsertBlock(this.builder);
        LLVMBuildBr(this.builder, merge_block);

        LLVMPositionBuilderAtEnd(this.builder, else_block);
        let else_value: QualifiedValue = this.CompileExpression(ternary->else_expr, pointer);
        else_block = LLVMGetInsertBlock(this.builder);
        LLVMBuildBr(this.builder, merge_block);

        if then_value.Type() != else_value.Type() {
            this.Error((String("Incompatible ternary types. ('") + LLVMTypeToString(then_value.Type().Value()) + "' != '" + LLVMTypeToString(else_value.Type().Value()) + "').").Data());
            ret QualifiedValue(null, null);
        }

        LLVMPositionBuilderAtEnd(this.builder, merge_block);
        let value: LLVMValueRef = LLVMBuildPhi(this.builder, then_value.Type().Value(), "");

        let blocks[]: LLVMBasicBlockRef = { then_block, else_block };
        let values[]: LLVMValueRef = { then_value.Value(), else_value.Value() };
        LLVMAddIncoming(value, values, blocks, 2u32);

        ret QualifiedValue(value, then_value.Type());
    }

    priv CompileIndexAccess(this: mut Compiler&, index_access: IndexAccessNode*, pointer: bool) -> QualifiedValue {
        let mut value: QualifiedValue = this.CompileExpression(index_access->expression, false);
        let index: QualifiedValue = this.CompileExpression(index_access->index, false);

        if value.Type().IsReference() {
            value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
        }

        if value.Type().IsClass() {
            let mut params: Vector<QualifiedValue>;
            params.PushBack(index);

            // value = QualifiedValue(LLVMAddressOf(value.Value()), this.type_manager.Pointer(value.Type(), value.Type().IsMutable()));
            value = this.CompileExpression(index_access->expression, true);

            if value.Type().Pointee().IsReference() {
                value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
            }

            let method: Pair<Method, QualifiedType*>& = value.Type().Pointee().Get(String("op[]"), this.ValueToType(params));
            ret this.CompileCall2(QualifiedValue(method.left.value, method.right, value), params, pointer, false);
        }

        if !value.Type().IsPointer() {
            this.Error("Index access value must be a pointer.");
            ret QualifiedValue(null, null);
        }

        let indices[]: LLVMValueRef = { index.Value() };
        let target_pointer: LLVMValueRef = LLVMBuildGEP2(this.builder, value.Type().Pointee().Value(), value.Value(), indices, 1u32, "");
        ret QualifiedValue(target_pointer, this.type_manager.Reference(value.Type().Pointee(), value.Type().IsMutable()));
    }

    priv CompileMemberAccess(this: mut Compiler&, member_access: MemberAccessNode*, pointer: bool) -> QualifiedValue {
        let mut instance: QualifiedValue = this.CompileExpression(member_access->expression, true);

        if instance.Type().Pointee().IsReference() {
            instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee(), false, instance.binding);
        }

        if instance.binding || instance.Type().IsReference() {
            if member_access->arrow {
                instance = QualifiedValue(LLVMBuildLoad2(this.builder, instance.Type().Pointee().Value(), instance.Value(), ""), instance.Type().Pointee(), false, instance.binding);
            }
        } else {
            if !member_access->arrow && !instance.return {
                this.Error("Expected an arrow operator.");
                ret QualifiedValue(null, null);
            }
        }

        if !instance.Type().IsPointer() {
            this.Error("Member access value must be a pointer.");
            ret QualifiedValue(null, null);
        }

        if !instance.Type().Pointee().IsClass() {
            this.Error((String("Cannot access member '") + member_access->member + "' of non-class type.").Data());
            ret QualifiedValue(null, null);
        }

        let mut state: bool = true;
        let index: i64 = instance.Type().Pointee().Index(member_access->member);
        if this._class != null { state = (*this._class) != instance.Type().Pointee(); }

        if index != -1i64 {
            let field: Pair<Field, QualifiedType*>& = instance.Type().Pointee().Fields()[member_access->member];

            if field.left.visibility != TokenType::PUBLIC && state {
                this.Error((String("Field '") + member_access->member + "' is private.").Data());
                ret QualifiedValue(null, null);
            }

            let field_pointer: LLVMValueRef = LLVMBuildStructGEP2(this.builder, instance.Type().Pointee().Value(), instance.Value(), index as u32, "");

            if !pointer {
                if field.right->IsArray() {
                    let _type: QualifiedType& = this.type_manager.Pointer(field.right->Element(), instance.Type().IsMutable());
                    ret QualifiedValue(LLVMBuildBitCast(this.builder, field_pointer, _type.Value(), ""), _type);
                } else {
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, field.right->Value(), field_pointer, ""), field.right);
                }
            } else {
                ret QualifiedValue(field_pointer, this.type_manager.Pointer(field.right, instance.Type().IsMutable()), false, true);
            }
        } else {
            let method: Pair<Method, QualifiedType*>& = instance.Type().Pointee().Get(member_access->member);
            ret QualifiedValue(method.left.value, method.right, instance);
        }
    }

    priv CompileNew(this: mut Compiler&, _new: NewNode*) -> QualifiedValue {
        let _type: QualifiedType& = this.CompileType(_new->_type);
        let mut pointer: LLVMValueRef = null;

        if _new->size != null {
            let size: QualifiedValue = this.CompileExpression(_new->size, false);

            if LLVMGetTypeKind(size.Type().Value()) != LLVMTypeKind::LLVMIntegerTypeKind || LLVMGetIntTypeWidth(size.Type().Value()) != 64u32 || size.Type().IsSigned() {
                this.Error("Array size must be of type 'u64'.");
                ret QualifiedValue(null, null);
            }

            let mut _size: LLVMValueRef = LLVMConstInt(LLVMInt64TypeInContext(this.context), LLVMABISizeOfType(this.layout, _type.Value()), 0i32);
            _size = LLVMBuildAdd(this.builder, LLVMBuildMul(this.builder, _size, size.Value(), ""), LLVMConstInt(LLVMInt64TypeInContext(this.context), 8u64, 0i32), "");
            pointer = LLVMBuildArrayMalloc(this.builder, LLVMInt8TypeInContext(this.context), _size, "");
            LLVMBuildStore(this.builder, size.Value(), LLVMBuildBitCast(this.builder, pointer, LLVMPointerType(LLVMInt64TypeInContext(this.context), 0u32), ""));

            let indices[]: LLVMValueRef = { LLVMConstInt(LLVMInt64TypeInContext(this.context), 8u64, 0i32) };
            pointer = LLVMBuildGEP2(this.builder, LLVMInt8TypeInContext(this.context), pointer, indices, 1u32, "");
            pointer = LLVMBuildBitCast(this.builder, pointer, LLVMPointerType(_type.Value(), 0u32), "");

            if _type.IsClass() {
                let value: LLVMValueRef = LLVMBuildAlloca(this.builder, LLVMInt64TypeInContext(this.context), "");
                LLVMBuildStore(this.builder, LLVMConstInt(LLVMInt64TypeInContext(this.context), 0u64, 0i32), value);

                let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
                let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, compare_block);
                let index: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), value, "");
                LLVMBuildCondBr(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, index, size.Value(), ""), loop_block, end_block);

                let params: Vector<QualifiedValue>;
                let indices[]: LLVMValueRef = { index };
                LLVMPositionBuilderAtStart(this.builder, loop_block);
                this.CompileConstructor(_type, QualifiedValue(LLVMBuildGEP2(this.builder, _type.Value(), pointer, indices, 1u32, ""), this.type_manager.Pointer(_type, true)), params);
                LLVMBuildStore(this.builder, LLVMBuildAdd(this.builder, index, LLVMConstInt(LLVMInt64TypeInContext(this.context), 1u64, 0i32), ""), value);
                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, end_block);
            }
        } else {
            let mut values: Vector<QualifiedValue>;
            pointer = LLVMBuildMalloc(this.builder, _type.Value(), "");
            let mut i: u64 = 0u64;
            
            while _new->arguments.Size() > i {
                values.PushBack(this.CompileExpression(_new->arguments[i], false));
                i += 1u64;
            }

            if _type.IsClass() {
                this.CompileConstructor(_type, QualifiedValue(pointer, this.type_manager.Pointer(_type, true)), values);
            } else if values.Size() > 0u64 {
                this.Error("Cannot initialize non-class types with parameters.");
                ret QualifiedValue(null, null);
            }
        }

        ret QualifiedValue(pointer, this.type_manager.Pointer(_type, true));
    }

    priv CompileDelete(this: mut Compiler&, delete: DeleteNode*) -> QualifiedValue {
        let mut pointer: QualifiedValue = this.CompileExpression(delete->expression, false);

        if pointer.Type().IsReference() {
            pointer = QualifiedValue(LLVMBuildLoad2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), ""), pointer.Type().Pointee());
        }

        if !pointer.Type().IsPointer() {
            this.Error("Delete value must be a pointer.");
            ret QualifiedValue(null, null);
        }

        let mut _pointer: LLVMValueRef = pointer.Value();

        if LLVMGetTypeKind(pointer.Type().Pointee().Value()) != LLVMTypeKind::LLVMIntegerTypeKind || LLVMGetIntTypeWidth(pointer.Type().Pointee().Value()) != 8u32 {
            _pointer = LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(LLVMInt8TypeInContext(this.context), 0u32), "");
        }

        if delete->array {
            let indices[]: LLVMValueRef = { LLVMConstInt(LLVMInt64TypeInContext(this.context), -8i64 as u64, 0i32) };
            _pointer = LLVMBuildGEP2(this.builder, LLVMInt8TypeInContext(this.context), _pointer, indices, 1u32, "");

            if pointer.Type().Pointee().IsClass() {
                let count: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), LLVMBuildBitCast(this.builder, _pointer, LLVMPointerType(LLVMInt64TypeInContext(this.context), 0u32), ""), "");

                let value: LLVMValueRef = LLVMBuildAlloca(this.builder, LLVMInt64TypeInContext(this.context), "");
                LLVMBuildStore(this.builder, LLVMConstInt(LLVMInt64TypeInContext(this.context), 0u64, 0i32), value);

                let function: LLVMValueRef = LLVMGetBasicBlockParent(LLVMGetInsertBlock(this.builder));
                let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");
                let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, function, "");

                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, compare_block);
                let index: LLVMValueRef = LLVMBuildLoad2(this.builder, LLVMInt64TypeInContext(this.context), value, "");
                LLVMBuildCondBr(this.builder, LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, index, count, ""), loop_block, end_block);

                let indices[]: LLVMValueRef = { index };
                LLVMPositionBuilderAtStart(this.builder, loop_block);
                this.CompileDestructor(pointer.Type().Pointee(), QualifiedValue(LLVMBuildGEP2(this.builder, pointer.Type().Pointee().Value(), pointer.Value(), indices, 1u32, ""), pointer.Type()));
                LLVMBuildStore(this.builder, LLVMBuildAdd(this.builder, index, LLVMConstInt(LLVMInt64TypeInContext(this.context), 1u64, 0i32), ""), value);
                LLVMBuildBr(this.builder, compare_block);
                LLVMPositionBuilderAtStart(this.builder, end_block);
            }
        } else {
            if pointer.Type().Pointee().IsClass() {
                this.CompileDestructor(pointer.Type().Pointee(), pointer);
            }
        }

        LLVMBuildFree(this.builder, _pointer);
        ret QualifiedValue(null, null);
    }

    priv CompileCast(this: mut Compiler&, cast: CastNode*, pointer: bool) -> QualifiedValue {
        let mut target: QualifiedType* = this.CompileType(cast->target_type);

        if cast->expression->node_type != ASTNodeType::INITIALIZER_LIST {
            if pointer { target = this.type_manager.Pointer(target, target->IsMutable()); }
            ret this.CompileCast2(this.CompileExpression(cast->expression, pointer), target);
        } else {
            if !target->IsClass() {
                this.Error("Expected a class.");
                ret QualifiedValue(null, null);
            }

            let mut params: Vector<QualifiedValue>;
            let initializer_list: InitializerListNode* = cast->expression as InitializerListNode*;
            let mut i: u64 = 0u64;

            while i < initializer_list->expressions.Size() {
                params.PushBack(this.CompileExpression(initializer_list->expressions[i], false));
                i += 1u64;
            }

            let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
            LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
            let _pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, target->Value(), "");
            LLVMPositionBuilderAtEnd(this.builder, current);
            let instance: QualifiedValue = QualifiedValue(_pointer, this.type_manager.Pointer(target, false), false, true);
            this.CompileConstructor(target, instance, params);
            this.scope_manager.RegisterInstance(instance);

            if !pointer {
                ret QualifiedValue(LLVMBuildLoad2(this.builder, target->Value(), instance.Value(), ""), target);
            } else {
                ret instance;
            }
        }
    }

    priv CompileCast2(this: mut Compiler&, value: QualifiedValue, target: QualifiedType&) -> QualifiedValue {
        let target_kind: LLVMTypeKind = LLVMGetTypeKind(target.Value());
        let value_kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

        if value.Type() == target {
            this.Error((String("Redundant cast. ('") + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "')").Data());
            ret QualifiedValue(null, null);
        }

        if value.Type().IsPointer() && target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            ret QualifiedValue(LLVMBuildPtrToInt(this.builder, value.Value(), target.Value(), ""), target);
        } else if value_kind == LLVMTypeKind::LLVMFloatTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                ret QualifiedValue(LLVMBuildFPExt(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMDoubleTypeKind {
            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if target.IsSigned() {
                    ret QualifiedValue(LLVMBuildFPToSI(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildFPToUI(this.builder, value.Value(), target.Value(), ""), target);
                }
            }
            
            if target_kind == LLVMTypeKind::LLVMFloatTypeKind {
                ret QualifiedValue(LLVMBuildFPTrunc(this.builder, value.Value(), target.Value(), ""), target);
            }
        } else if value_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if target.IsPointer() {
                ret QualifiedValue(LLVMBuildIntToPtr(this.builder, value.Value(), target.Value(), ""), target);
            }

            if target_kind == LLVMTypeKind::LLVMFloatTypeKind || target_kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if value.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSIToFP(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(LLVMBuildUIToFP(this.builder, value.Value(), target.Value(), ""), target);
                }
            }

            if target_kind == LLVMTypeKind::LLVMIntegerTypeKind {
                let value_width: u32 = LLVMGetIntTypeWidth(value.Type().Value());
                let target_width: u32 = LLVMGetIntTypeWidth(target.Value());

                if target_width > value_width {
                    if value.Type().IsSigned() {
                        ret QualifiedValue(LLVMBuildSExt(this.builder, value.Value(), target.Value(), ""), target);
                    } else {
                        ret QualifiedValue(LLVMBuildZExt(this.builder, value.Value(), target.Value(), ""), target);
                    }
                } else if target_width < value_width {
                    ret QualifiedValue(LLVMBuildTrunc(this.builder, value.Value(), target.Value(), ""), target);
                } else {
                    ret QualifiedValue(value.Value(), target);
                }
            }
        }

        if value.Type().IsPointer() && target.IsPointer() {
            let mut pointer: LLVMValueRef = value.Value();

            if value.Type().Pointee().IsClass() && target.Pointee().IsClass() {
                let value_class: QualifiedType& = value.Type().Pointee();
                let target_class: QualifiedType& = target.Pointee();

                let value_fields: mut Map<String, Pair<Field, QualifiedType*>>& = value_class.Fields();
                let target_fields: mut Map<String, Pair<Field, QualifiedType*>>& = target_class.Fields();
                let (mut related: bool, mut index: u32) = (false, 0u32);
                let (mut i: u64, mut j: u64) = (0u64, 0u64);

                while value_fields.Size() > i && !related {
                    if value_fields[i].left == target_class.name {
                        (related, index) = (true, i as u32);
                        break;
                    } i += 1u64;
                }

                while target_fields.Size() > j && !related {
                    if target_fields[j].left == value_class.name {
                        (related, index) = (true, -(j as i64) as u32);
                        break;
                    } j += 1u64;
                }

                if !related {
                    this.Error((String("Cannot cast class '") + value_class.name + "' to unrelated class '" + target_class.name + "'.").Data());
                    ret QualifiedValue(null, null);
                }

                if index != 0u32 {
                    pointer = LLVMBuildStructGEP2(this.builder, value.Type().Pointee().Value(), value.Value(), index, "");
                }
            }

            ret QualifiedValue(LLVMBuildBitCast(this.builder, pointer, target.Value(), ""), target, false, value.binding);
        } else {
            this.Error((String("Cannot cast '") + LLVMTypeToString(value.Type().Value()) + "' to '" + LLVMTypeToString(target.Value()) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileUnaryOperation(this: mut Compiler&, unary_op: UnaryOpNode*, pointer: bool) -> QualifiedValue {
        if unary_op->operator == TokenType::BITWISE_AND {
            if !pointer {
                let _pointer: QualifiedValue = this.CompileExpression(unary_op->operand, true);

                if _pointer.Type().Pointee().IsReference() {
                    let _type: QualifiedType* = this.type_manager.Pointer(_pointer.Type().Pointee().Pointee(), _pointer.Type().Pointee().IsMutable());
                    ret QualifiedValue(LLVMBuildLoad2(this.builder, _pointer.Type().Pointee().Value(), _pointer.Value(), ""), _type);
                } else {
                    ret _pointer;
                }
            } else {
                this.Error("Invalid pointer unary operation.");
                ret QualifiedValue(null, null);
            }
        } else {
            let mut value: QualifiedValue = this.CompileExpression(unary_op->operand, false);

            if value.Type().IsReference() {
                value = QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
            }

            let kind: LLVMTypeKind = LLVMGetTypeKind(value.Type().Value());

            if unary_op->operator == TokenType::MUL {
                if value.Type().IsPointer() {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildLoad2(this.builder, value.Type().Pointee().Value(), value.Value(), ""), value.Type().Pointee());
                    } else {
                        ret value;
                    }
                } else {
                    this.Error((String("Cannot dereference non-pointer type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::MINUS {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if value.Type().IsSigned() {
                        if !pointer {
                            ret QualifiedValue(LLVMBuildNeg(this.builder, value.Value(), ""), value.Type());
                        } else {
                            this.Error("Invalid pointer unary operation.");
                            ret QualifiedValue(null, null);
                        }
                    } else {
                        this.Error((String("Cannot negate unsigned type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                        ret QualifiedValue(null, null);
                    }
                } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildFNeg(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot negate type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else if unary_op->operator == TokenType::NOT {
                if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                    if !pointer {
                        ret QualifiedValue(LLVMBuildNot(this.builder, value.Value(), ""), value.Type());
                    } else {
                        this.Error("Invalid pointer unary operation.");
                        ret QualifiedValue(null, null);
                    }
                } else {
                    this.Error((String("Cannot invert type '") + LLVMTypeToString(value.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid unary operation '") + TokenTypeToString(unary_op->operator) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        }
    }

    priv CompileBinaryOperation(this: mut Compiler&, binary_op: BinaryOpNode*, pointer: bool) -> QualifiedValue {
        ret this.CompileBinaryOperation2(this.CompileExpression(binary_op->left, false), this.CompileExpression(binary_op->right, false), binary_op->operator, pointer);
    }

    priv CompileBinaryOperation2(this: mut Compiler&, mut left: QualifiedValue, mut right: QualifiedValue, operator: TokenType, pointer: bool) -> QualifiedValue {
        if left.Type().IsReference() {
            left = QualifiedValue(LLVMBuildLoad2(this.builder, left.Type().Pointee().Value(), left.Value(), ""), left.Type().Pointee());
        }

        if right.Type().IsReference() {
            right = QualifiedValue(LLVMBuildLoad2(this.builder, right.Type().Pointee().Value(), right.Value(), ""), right.Type().Pointee());
        }

        if left.Type().IsClass() || right.Type().IsClass() {
            let value: QualifiedValue& = left.Type().IsClass() ? &right : &left;
            let instance: QualifiedValue& = left.Type().IsClass() ? &left : &right;

            let mut values: Vector<QualifiedValue>;
            values.PushBack(value);

            let mut method_name: String = "op";
            method_name += BinaryOperatorToString(operator);
            let param_types: Vector<QualifiedType*> = this.ValueToType(values);
            let _class: QualifiedType& = instance.Type();

            if _class.Has(method_name, param_types) {
                let method: Pair<Method, QualifiedType*>& = _class.Get(method_name, param_types);
                let _instance: QualifiedValue = QualifiedValue(LLVMAddressOf(instance.Value()), this.type_manager.Pointer(instance.Type(), instance.Type().IsMutable()));
                ret this.CompileCall2(QualifiedValue(method.left.value, method.right, _instance), values, pointer, false);
            }

            if left.Type() == right.Type() {
                if operator != TokenType::EQUAL && operator != TokenType::NOT_EQUAL {
                    this.Error((String("Invalid class binary operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(_class.Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }

                let fields: mut Map<String, Pair<Field, QualifiedType*>>& = _class.Fields();
                left = QualifiedValue(LLVMAddressOf(left.Value()), this.type_manager.Pointer(left.Type(), true));
                right = QualifiedValue(LLVMAddressOf(right.Value()), this.type_manager.Pointer(right.Type(), true));
                let mut result: LLVMValueRef = null;
                let mut i: u64 = 0u64;

                while i < fields.Size() {
                    let field: mut Pair<String, Pair<Field, QualifiedType*>>& = fields[i];
                    let left: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, field.right.right->Value(), LLVMBuildStructGEP2(this.builder, left.Type().Pointee().Value(), left.Value(), _class.Index(field.left) as u32, ""), ""), field.right.right);
                    let right: QualifiedValue = QualifiedValue(LLVMBuildLoad2(this.builder, field.right.right->Value(), LLVMBuildStructGEP2(this.builder, right.Type().Pointee().Value(), right.Value(), _class.Index(field.left) as u32, ""), ""), field.right.right);
                    let _result: LLVMValueRef = this.CompileBinaryOperation2(left, right, operator, pointer).Value();

                    if result != null {
                        result = LLVMBuildAnd(this.builder, result, _result, "");
                    } else {
                        result = _result;
                    } i += 1u64;
                }

                if operator == TokenType::NOT_EQUAL {
                    result = LLVMBuildNot(this.builder, result, "");
                }

                ret QualifiedValue(result, this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Incompatible class binary operation types. ('") + LLVMTypeToString(_class.Value()) + "' != '" + LLVMTypeToString(value.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }
        } else if pointer {
            this.Error("Invalid pointer binary operation.");
            ret QualifiedValue(null, null);
        }

        let (left_kind: LLVMTypeKind, right_kind: LLVMTypeKind) = (LLVMGetTypeKind(left.Type().Value()), LLVMGetTypeKind(right.Type().Value()));

        if left.Type().IsPointer() && right.Type().IsPointer() {
            if operator == TokenType::MINUS {
                let _type: QualifiedType& = this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), false);
                ret QualifiedValue(LLVMBuildSub(this.builder, LLVMBuildPtrToInt(this.builder, left.Value(), _type.Value(), ""), LLVMBuildPtrToInt(this.builder, right.Value(), _type.Value(), ""), ""), _type);
            } else if operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left.Type().IsPointer() && right_kind == LLVMTypeKind::LLVMIntegerTypeKind) || (left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right.Type().IsPointer()) {
            let ptr: QualifiedValue& = left.Type().IsPointer() ? &left : &right;
            let index: QualifiedValue& = left.Type().IsPointer() ? &right : &left;
            let width: u32 = LLVMGetIntTypeWidth(index.Type().Value());

            if width == 64u32 {
                if operator == TokenType::PLUS {
                    let indices[]: LLVMValueRef = { index.Value() };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Pointee().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else if operator == TokenType::MINUS {
                    let indices[]: LLVMValueRef = { LLVMBuildNeg(this.builder, index.Value(), "") };
                    ret QualifiedValue(LLVMBuildGEP2(this.builder, ptr.Type().Pointee().Value(), ptr.Value(), indices, 1u32, ""), ptr.Type());
                } else {
                    this.Error((String("Invalid pointer binary operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error((String("Invalid index type '") + LLVMTypeToString(index.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind && right_kind == LLVMTypeKind::LLVMIntegerTypeKind {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible binary operation types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::DIV {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildUDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if operator == TokenType::MOD {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildSRem(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildURem(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGT : LLVMIntPredicate::LLVMIntUGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSGE : LLVMIntPredicate::LLVMIntUGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLT : LLVMIntPredicate::LLVMIntULT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildICmp(this.builder, left.Type().IsSigned() ? LLVMIntPredicate::LLVMIntSLE : LLVMIntPredicate::LLVMIntULE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::AND || operator == TokenType::BITWISE_AND {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && operator == TokenType::AND {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildAnd(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if operator == TokenType::OR || operator == TokenType::BITWISE_OR {
                if LLVMGetIntTypeWidth(left.Type().Value()) != 1u32 && operator == TokenType::OR {
                    this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(operator) + "'.").Data());
                    ret QualifiedValue(null, null);
                } else {
                    ret QualifiedValue(LLVMBuildOr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else if operator == TokenType::BITWISE_XOR {
                ret QualifiedValue(LLVMBuildXor(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::LSHIFT {
                ret QualifiedValue(LLVMBuildShl(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::RSHIFT {
                if left.Type().IsSigned() {
                    ret QualifiedValue(LLVMBuildAShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                } else {
                    ret QualifiedValue(LLVMBuildLShr(this.builder, left.Value(), right.Value(), ""), left.Type());
                }
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else if (left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind) && (right_kind == LLVMTypeKind::LLVMFloatTypeKind || right_kind == LLVMTypeKind::LLVMDoubleTypeKind) {
            if left.Type() != right.Type() {
                this.Error((String("Incompatible binary operation types. ('") + LLVMTypeToString(left.Type().Value()) + "' != '" + LLVMTypeToString(right.Type().Value()) + "').").Data());
                ret QualifiedValue(null, null);
            }

            if operator == TokenType::PLUS {
                ret QualifiedValue(LLVMBuildFAdd(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::MINUS {
                ret QualifiedValue(LLVMBuildFSub(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::MUL {
                ret QualifiedValue(LLVMBuildFMul(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::DIV {
                ret QualifiedValue(LLVMBuildFDiv(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::MOD {
                ret QualifiedValue(LLVMBuildFRem(this.builder, left.Value(), right.Value(), ""), left.Type());
            } else if operator == TokenType::EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::NOT_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::GREATER_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else if operator == TokenType::LESS_EQUAL {
                ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.Value(), right.Value(), ""), this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false));
            } else {
                this.Error((String("Invalid binary operation '") + TokenTypeToString(operator) + "' for type '" + LLVMTypeToString(left.Type().Value()) + "'.").Data());
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Invalid type '") + LLVMTypeToString(left.Type().Value()) + "' for binary operation '" + TokenTypeToString(operator) + "'.").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileType(this: mut Compiler&, type_node: ASTNode*) -> QualifiedType& {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->name == "bool" {
                ret this.type_manager.Primitive(LLVMInt1TypeInContext(this.context), false);
            } else if primitive_type->name == "i8" || primitive_type->name == "u8" {
                ret this.type_manager.Primitive(LLVMInt8TypeInContext(this.context), primitive_type->name[0u64] != 'u' ? true : false);
            } else if primitive_type->name == "i16" || primitive_type->name == "u16" {
                ret this.type_manager.Primitive(LLVMInt16TypeInContext(this.context), primitive_type->name[0u64] != 'u' ? true : false);
            } else if primitive_type->name == "i32" || primitive_type->name == "u32" || primitive_type->name == "char" {
                ret this.type_manager.Primitive(LLVMInt32TypeInContext(this.context), primitive_type->name[0u64] != 'u' ? true : false);
            } else if primitive_type->name == "i64" || primitive_type->name == "u64" {
                ret this.type_manager.Primitive(LLVMInt64TypeInContext(this.context), primitive_type->name[0u64] != 'u' ? true : false);
            } else if primitive_type->name == "i128" || primitive_type->name == "u128" {
                ret this.type_manager.Primitive(LLVMInt128TypeInContext(this.context), primitive_type->name[0u64] != 'u' ? true : false);
            } else if primitive_type->name == "f32" {
                ret this.type_manager.Primitive(LLVMFloatTypeInContext(this.context), false);
            } else if primitive_type->name == "f64" {
                ret this.type_manager.Primitive(LLVMDoubleTypeInContext(this.context), false);
            } else if primitive_type->name == "void" {
                ret this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
            } else {
                if this.scope_manager.Has(primitive_type->name, SymbolKind::Type) {
                    ret this.scope_manager.Get(primitive_type->name, SymbolKind::Type)->value.Type();
                } else if this.scope_manager.Has(primitive_type->name, SymbolKind::Class) {
                    ret this.scope_manager.Get(primitive_type->name, SymbolKind::Class)->value.Type();
                } else if this.scope_manager.Has(primitive_type->name, SymbolKind::Generic) {
                    if primitive_type->generic {
                        let mut types: Vector<QualifiedType*>;
                        let mut i: u64 = 0u64;

                        while i < primitive_type->types.Size() {
                            types.PushBack(this.CompileType(primitive_type->types[i]));
                            i += 1u64;
                        }

                        ret (this.scope_manager.Get(primitive_type->name, SymbolKind::Generic)->pointer as mut Generic*)->Get(types);
                    } else {
                        this.Error((String("Generic type '") + primitive_type->name + "' requires parameters.").Data());
                        ret null;
                    }
                } else {
                    this.Error((String("Type '") + primitive_type->name + "' not found.").Data());
                    ret null;
                }
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(pointer_type->base_type), pointer_type->mutable);
        } else if type_node->node_type == ASTNodeType::REFERENCE_TYPE {
            let reference_type: ReferenceTypeNode* = type_node as ReferenceTypeNode*;
            ret this.type_manager.Reference(this.CompileType(reference_type->base_type), reference_type->mutable);
        } else if type_node->node_type == ASTNodeType::ARRAY_TYPE {
            let array_type: ArrayTypeNode* = type_node as ArrayTypeNode*;
            let _type: QualifiedType* = this.CompileType(array_type->element_type);

            if array_type->size == null {
                ret this.type_manager.Pointer(_type, _type->IsMutable());
            } else {
                let size: QualifiedValue = this.CompileExpression(array_type->size, false);

                if LLVMGetTypeKind(size.Type().Value()) != LLVMTypeKind::LLVMIntegerTypeKind || LLVMGetIntTypeWidth(size.Type().Value()) != 64u32 || size.Type().IsSigned() {
                    this.Error("Array size must be of type 'u64'.");
                    ret null;
                }

                ret this.type_manager.Array(_type, LLVMConstIntGetZExtValue(size.Value()), _type->IsMutable());
            }
        } else if type_node->node_type == ASTNodeType::FUNCTION_TYPE {
            let function_type: FunctionTypeNode* = type_node as FunctionTypeNode*;
            let (mut params: Vector<QualifiedType*>, mut param_types: Vector<LLVMTypeRef>);
            let mut return_type: QualifiedType* = this.CompileType(function_type->return_type);

            if LLVMGetTypeKind(return_type->Value()) == LLVMTypeKind::LLVMStructTypeKind {
                let processed_type: mut QualifiedType& = this.ProcessType(return_type);

                if LLVMGetTypeKind(processed_type.Value()) != LLVMTypeKind::LLVMPointerTypeKind {
                    return_type = processed_type;
                } else {
                    params.PushBack(processed_type);
                    param_types.PushBack(processed_type.Value());
                    return_type = this.type_manager.Primitive(LLVMVoidTypeInContext(this.context), false);
                    processed_type.sret = return_type;
                }
            }

            let mut i: u64 = 0u64;

            while i < function_type->parameters.Size() {
                let param: ParameterNode* = function_type->parameters[i];
                let real_type: QualifiedType& = this.CompileType(param->param_type);
                let processed_type: mut QualifiedType& = this.ProcessType(real_type);
                param_types.PushBack(processed_type.Value());
                params.PushBack(processed_type);

                if real_type != processed_type {
                    processed_type.byval = real_type;
                } i += 1u64;
            }

            ret this.type_manager.Pointer(this.type_manager.Function(LLVMFunctionType(return_type->Value(), param_types.Data(), param_types.Size() as u32, function_type->var_arg ? 1i32 : 0i32), params, return_type), false);
        } else {
            this.Error((String("Unknown type '") + ASTNodeTypeToString(type_node->node_type) + "'.").Data());
            ret null;
        }
    }

    priv Error(this: Compiler&, message: i8*) {
        printf("Compiler error: %s\n", message);
        exit(1i32);
    }
};