include "divio", "divstr", "divvec", "divmap", "divwin", "_lexer.div" : *;

enum ASTNodeType {
    LITERAL, IDENTIFIER, SCOPE_RESOLUTION, BINARY_OP, UNARY_OP, TERNARY,
    CALL, MEMBER_ACCESS, INDEX_ACCESS, CAST, INITIALIZER_LIST, NEW, DELETE,

    EXPRESSION_STMT, VARIABLE_DECL, CONSTANT_DECL, ASSIGNMENT, IF_STMT, WHILE_STMT, 
    RETURN_STMT, BREAK_STMT, CONTINUE_STMT, BLOCK_STMT,

    FUNCTION_DECL, CLASS_DECL, ENUM_DECL, EXTERN_BLOCK, TYPE_DECL,
    IMPL_BLOCK, PARAMETER, FIELD,

    PRIMITIVE_TYPE, POINTER_TYPE, REFERENCE_TYPE, ARRAY_TYPE, FUNCTION_TYPE,

    ROOT
};

func ASTNodeTypeToString(_type: ASTNodeType) -> String {
    if _type == ASTNodeType::LITERAL { ret { "LITERAL" } as String; }
    else if _type == ASTNodeType::IDENTIFIER { ret { "IDENTIFIER" } as String; }
    else if _type == ASTNodeType::SCOPE_RESOLUTION { ret { "SCOPE_RESOLUTION" } as String; }
    else if _type == ASTNodeType::BINARY_OP { ret { "BINARY_OP" } as String; }
    else if _type == ASTNodeType::UNARY_OP { ret { "UNARY_OP" } as String; }
    else if _type == ASTNodeType::TERNARY { ret { "TERNARY" } as String; }
    else if _type == ASTNodeType::CALL { ret { "CALL" } as String; }
    else if _type == ASTNodeType::MEMBER_ACCESS { ret { "MEMBER_ACCESS" } as String; }
    else if _type == ASTNodeType::INDEX_ACCESS { ret { "INDEX_ACCESS" } as String; }
    else if _type == ASTNodeType::CAST { ret { "CAST" } as String; }
    else if _type == ASTNodeType::INITIALIZER_LIST { ret { "INITIALIZER_LIST" } as String; }
    else if _type == ASTNodeType::NEW { ret { "NEW" } as String; }
    else if _type == ASTNodeType::DELETE { ret { "DELETE" } as String; }
    else if _type == ASTNodeType::EXPRESSION_STMT { ret { "EXPRESSION_STMT" } as String; }
    else if _type == ASTNodeType::VARIABLE_DECL { ret { "VARIABLE_DECL" } as String; }
    else if _type == ASTNodeType::CONSTANT_DECL { ret { "CONSTANT_DECL" } as String; }
    else if _type == ASTNodeType::ASSIGNMENT { ret { "ASSIGNMENT" } as String; }
    else if _type == ASTNodeType::IF_STMT { ret { "IF_STMT" } as String; }
    else if _type == ASTNodeType::WHILE_STMT { ret { "WHILE_STMT" } as String; }
    else if _type == ASTNodeType::RETURN_STMT { ret { "RETURN_STMT" } as String; }
    else if _type == ASTNodeType::BREAK_STMT { ret { "BREAK_STMT" } as String; }
    else if _type == ASTNodeType::CONTINUE_STMT { ret { "CONTINUE_STMT" } as String; }
    else if _type == ASTNodeType::BLOCK_STMT { ret { "BLOCK_STMT" } as String; }
    else if _type == ASTNodeType::FUNCTION_DECL { ret { "FUNCTION_DECL" } as String; }
    else if _type == ASTNodeType::CLASS_DECL { ret { "CLASS_DECL" } as String; }
    else if _type == ASTNodeType::ENUM_DECL { ret { "ENUM_DECL" } as String; }
    else if _type == ASTNodeType::EXTERN_BLOCK { ret { "EXTERN_BLOCK" } as String; }
    else if _type == ASTNodeType::TYPE_DECL { ret { "TYPE_DECL" } as String; }
    else if _type == ASTNodeType::IMPL_BLOCK { ret { "IMPL_BLOCK" } as String; }
    else if _type == ASTNodeType::PARAMETER { ret { "PARAMETER" } as String; }
    else if _type == ASTNodeType::FIELD { ret { "FIELD" } as String; }
    else if _type == ASTNodeType::PRIMITIVE_TYPE { ret { "PRIMITIVE_TYPE" } as String; }
    else if _type == ASTNodeType::POINTER_TYPE { ret { "POINTER_TYPE" } as String; }
    else if _type == ASTNodeType::REFERENCE_TYPE { ret { "REFERENCE_TYPE" } as String; }
    else if _type == ASTNodeType::ARRAY_TYPE { ret { "ARRAY_TYPE" } as String; }
    else if _type == ASTNodeType::FUNCTION_TYPE { ret { "FUNCTION_TYPE" } as String; }
    else if _type == ASTNodeType::ROOT { ret { "ROOT" } as String; }
    else { ret { "UNKNOWN" } as String; }
}

class ASTNode {
    pub node_type: ASTNodeType,
    pub lineno: u64,
    pub column: u64
} impl {
    ASTNode(this: mut ASTNode&, _type: ASTNodeType, line: u64, col: u64) {
        (this.node_type, this.lineno, this.column) = (_type, line, col);
    }
};

class PrimitiveTypeNode : ASTNode {
    pub type_name: mut String,
    pub mutable: bool = false,
    pub generic: bool = false,
    pub types: mut Vector<ASTNode*>
} impl {
    PrimitiveTypeNode(this: mut PrimitiveTypeNode&, type_name: String, mutable: bool, line: u64, col: u64) : ASTNode(ASTNodeType::PRIMITIVE_TYPE, line, col) {
        (this.type_name, this.mutable) = (type_name, mutable);
    }
};

class PointerTypeNode : ASTNode {
    pub base_type: ASTNode*,
    pub mutable: bool = false
} impl {
    PointerTypeNode(this: mut PointerTypeNode&, base_type: ASTNode*, mutable: bool, line: u64, col: u64) : ASTNode(ASTNodeType::POINTER_TYPE, line, col) {
        (this.base_type, this.mutable) = (base_type, mutable);
    }
};

class ReferenceTypeNode : ASTNode {
    pub base_type: ASTNode*,
    pub mutable: bool = false
} impl {
    ReferenceTypeNode(this: mut ReferenceTypeNode&, base_type: ASTNode*, mutable: bool, line: u64, col: u64) : ASTNode(ASTNodeType::REFERENCE_TYPE, line, col) {
        (this.base_type, this.mutable) = (base_type, mutable);
    }
};

class ArrayTypeNode : ASTNode {
    pub element_type: ASTNode*,
    pub size: ASTNode*
} impl {
    ArrayTypeNode(this: mut ArrayTypeNode&, element_type: ASTNode*, size: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::ARRAY_TYPE, line, col) {
        (this.element_type, this.size) = (element_type, size);
    }
};

class ParameterNode : ASTNode {
    pub name: mut String,
    pub param_type: ASTNode*,
    pub is_mutable: bool
} impl {
    ParameterNode(this: mut ParameterNode&, name: String, param_type: ASTNode*, is_mutable: bool, line: u64, col: u64) : ASTNode(ASTNodeType::PARAMETER, line, col) {
        (this.name, this.param_type, this.is_mutable) = (name, param_type, is_mutable);
    }
};

class FunctionTypeNode : ASTNode {
    pub parameters: mut Vector<ParameterNode*>,
    pub return_type: ASTNode*,
    pub var_arg: bool = false
} impl {
    FunctionTypeNode(this: mut FunctionTypeNode&, line: u64, col: u64) : ASTNode(ASTNodeType::FUNCTION_TYPE, line, col) {}
};

class LiteralNode : ASTNode {
    pub value: mut String,
    pub literal_type: TokenType
} impl {
    LiteralNode(this: mut LiteralNode&, value: String, literal_type: TokenType, line: u64, col: u64) : ASTNode(ASTNodeType::LITERAL, line, col) {
        (this.value, this.literal_type) = (value, literal_type);
    }
};

class IdentifierNode : ASTNode {
    pub name: mut String
} impl {
    IdentifierNode(this: mut IdentifierNode&, name: String, line: u64, col: u64) : ASTNode(ASTNodeType::IDENTIFIER, line, col) {
        this.name = name;
    }
};

class ScopeResolutionNode : ASTNode {
    pub scope: ASTNode*,
    pub identifier: IdentifierNode*
} impl {
    ScopeResolutionNode(this: mut ScopeResolutionNode&, scope: ASTNode*, identifier: IdentifierNode*, line: u64, col: u64) : ASTNode(ASTNodeType::SCOPE_RESOLUTION, line, col) {
        (this.scope, this.identifier) = (scope, identifier);
    }
};

class BinaryOpNode : ASTNode {
    pub left: ASTNode*,
    pub right: ASTNode*,
    pub operator: TokenType
} impl {
    BinaryOpNode(this: mut BinaryOpNode&, left: ASTNode*, right: ASTNode*, operator: TokenType, line: u64, col: u64) : ASTNode(ASTNodeType::BINARY_OP, line, col) {
        (this.left, this.right, this.operator) = (left, right, operator);
    }
};

class UnaryOpNode : ASTNode {
    pub operand: ASTNode*,
    pub operator: TokenType
} impl {
    UnaryOpNode(this: mut UnaryOpNode&, operand: ASTNode*, operator: TokenType, line: u64, col: u64) : ASTNode(ASTNodeType::UNARY_OP, line, col) {
        (this.operand, this.operator) = (operand, operator);
    }
};

class TernaryNode : ASTNode {
    pub condition: ASTNode*,
    pub then_expr: ASTNode*,
    pub else_expr: ASTNode*
} impl {
    TernaryNode(this: mut TernaryNode&, condition: ASTNode*, then_expr: ASTNode*, else_expr: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::TERNARY, line, col) {
        (this.condition, this.then_expr, this.else_expr) = (condition, then_expr, else_expr);
    }
};

class CallNode : ASTNode {
    pub expression: ASTNode*,
    pub arguments: mut Vector<ASTNode*>
} impl {
    CallNode(this: mut CallNode&, expression: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::CALL, line, col) {
        this.expression = expression;
    }
};

class MemberAccessNode : ASTNode {
    pub expression: ASTNode*,
    pub member: mut String,
    pub arrow: bool
} impl {
    MemberAccessNode(this: mut MemberAccessNode&, expression: ASTNode*, arrow: bool, line: u64, col: u64) : ASTNode(ASTNodeType::MEMBER_ACCESS, line, col) {
        (this.expression, this.arrow) = (expression, arrow);
    }
};

class IndexAccessNode : ASTNode {
    pub expression: ASTNode*,
    pub index: ASTNode*
} impl {
    IndexAccessNode(this: mut IndexAccessNode&, expression: ASTNode*, index: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::INDEX_ACCESS, line, col) {
        (this.expression, this.index) = (expression, index);
    }
};

class CastNode : ASTNode {
    pub expression: ASTNode*,
    pub target_type: ASTNode*
} impl {
    CastNode(this: mut CastNode&, expression: ASTNode*, target_type: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::CAST, line, col) {
        (this.expression, this.target_type) = (expression, target_type);
    }
};

class InitializerListNode : ASTNode {
    pub expressions: mut Vector<ASTNode*>
} impl {
    InitializerListNode(this: mut InitializerListNode&, line: u64, col: u64) : ASTNode(ASTNodeType::INITIALIZER_LIST, line, col) {}
};

class NewNode : ASTNode {
    pub _type: ASTNode*,
    pub arguments: mut Vector<ASTNode*>,
    pub size: ASTNode* = null
} impl {
    NewNode(this: mut NewNode&, _type: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::NEW, line, col) {
        this._type = _type;
    }
};

class DeleteNode : ASTNode {
    pub expression: ASTNode*,
    pub array: bool = false
} impl {
    DeleteNode(this: mut DeleteNode&, line: u64, col: u64) : ASTNode(ASTNodeType::DELETE, line, col) {}
};

class ExpressionStmtNode : ASTNode {
    pub expression: ASTNode*
} impl {
    ExpressionStmtNode(this: mut ExpressionStmtNode&, expression: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::EXPRESSION_STMT, line, col) {
        this.expression = expression;
    }
};

class VariableDeclNode : ASTNode {
    pub name: mut String,
    pub var_type: ASTNode*,
    pub initializer: ASTNode*,
    pub is_mutable: bool,
    pub next: VariableDeclNode* = null
} impl {
    VariableDeclNode(this: mut VariableDeclNode&, name: String, var_type: ASTNode*, initializer: ASTNode*, is_mutable: bool, line: u64, col: u64) : ASTNode(ASTNodeType::VARIABLE_DECL, line, col) {
        (this.name, this.var_type, this.initializer, this.is_mutable) = (name, var_type, initializer, is_mutable);
    }
};

class ConstantDeclNode : ASTNode {
    pub name: mut String,
    pub var_type: ASTNode*,
    pub initializer: ASTNode*
} impl {
    ConstantDeclNode(this: mut ConstantDeclNode&, name: String, var_type: ASTNode*, initializer: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::CONSTANT_DECL, line, col) {
        (this.name, this.var_type, this.initializer) = (name, var_type, initializer);
    }
};

class AssignmentNode : ASTNode {
    pub left: ASTNode*,
    pub right: ASTNode*,
    pub operator: TokenType,
    pub next: AssignmentNode* = null
} impl {
    AssignmentNode(this: mut AssignmentNode&, left: ASTNode*, right: ASTNode*, operator: TokenType, line: u64, col: u64) : ASTNode(ASTNodeType::ASSIGNMENT, line, col) {
        (this.left, this.right, this.operator) = (left, right, operator);
    }
};

class IfStmtNode : ASTNode {
    pub condition: ASTNode*,
    pub then_stmt: ASTNode*,
    pub else_stmt: ASTNode*
} impl {
    IfStmtNode(this: mut IfStmtNode&, condition: ASTNode*, then_stmt: ASTNode*, else_stmt: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::IF_STMT, line, col) {
        (this.condition, this.then_stmt, this.else_stmt) = (condition, then_stmt, else_stmt);
    }
};

class WhileStmtNode : ASTNode {
    pub condition: ASTNode*,
    pub body: ASTNode*
} impl {
    WhileStmtNode(this: mut WhileStmtNode&, condition: ASTNode*, body: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::WHILE_STMT, line, col) {
        (this.condition, this.body) = (condition, body);
    }
};

class ReturnStmtNode : ASTNode {
    pub value: ASTNode*
} impl {
    ReturnStmtNode(this: mut ReturnStmtNode&, value: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::RETURN_STMT, line, col) {
        this.value = value;
    }
};

class BreakStmtNode : ASTNode {} impl {
    BreakStmtNode(this: mut BreakStmtNode&, line: u64, col: u64) : ASTNode(ASTNodeType::BREAK_STMT, line, col) {}
};

class ContinueStmtNode : ASTNode {} impl {
    ContinueStmtNode(this: mut ContinueStmtNode&, line: u64, col: u64) : ASTNode(ASTNodeType::CONTINUE_STMT, line, col) {}
};

class BlockStmtNode : ASTNode {
    pub statements: mut Vector<ASTNode*>
} impl {
    BlockStmtNode(this: mut BlockStmtNode&, line: u64, col: u64) : ASTNode(ASTNodeType::BLOCK_STMT, line, col) {}
};

class FunctionDeclNode : ASTNode {
    pub name: mut String,
    pub _type: FunctionTypeNode*,
    pub body: BlockStmtNode*,
    pub generic: bool = false,
    pub types: mut Vector<String>,
    pub constructors: mut Vector<CallNode*>
} impl {
    FunctionDeclNode(this: mut FunctionDeclNode&, name: String, _type: FunctionTypeNode*, body: BlockStmtNode*, line: u64, col: u64) : ASTNode(ASTNodeType::FUNCTION_DECL, line, col) {
        (this.name, this._type, this.body) = (name, _type, body);
    }
};

class TypeDeclNode : ASTNode {
    pub name: mut String,
    pub _type: ASTNode*
} impl {
    TypeDeclNode(this: mut TypeDeclNode&, name: String, _type: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::TYPE_DECL, line, col) {
        (this.name, this._type) = (name, _type);
    }
};

class FieldNode : ASTNode {
    pub name: mut String,
    pub field_type: ASTNode*,
    pub initializer: ASTNode*
} impl {
    FieldNode(this: mut FieldNode&, name: String, field_type: ASTNode*, initializer: ASTNode*, line: u64, col: u64) : ASTNode(ASTNodeType::FIELD, line, col) {
        (this.name, this.field_type, this.initializer) = (name, field_type, initializer);
    }
};

class ClassDeclNode : ASTNode {
    pub name: mut String,
    pub fields: mut Vector<Pair<TokenType, FieldNode*>>,
    pub methods: mut Vector<Pair<TokenType, FunctionDeclNode*>>,
    pub constructors: mut Vector<FunctionDeclNode*>,
    pub destructor: FunctionDeclNode* = null,
    pub parents: mut Vector<ASTNode*>,
    pub generic: bool = false,
    pub types: mut Vector<String>
} impl {
    ClassDeclNode(this: mut ClassDeclNode&, name: String, line: u64, col: u64) : ASTNode(ASTNodeType::CLASS_DECL, line, col) {
        this.name = name;
    }
};

class EnumDeclNode : ASTNode {
    pub name: mut String,
    pub values: mut Map<String, ASTNode*>,
    pub underlying_type: ASTNode*
} impl {
    EnumDeclNode(this: mut EnumDeclNode&, name: String, line: u64, col: u64) : ASTNode(ASTNodeType::ENUM_DECL, line, col) {
        this.name = name;
    }
};

class ExternBlockNode : ASTNode {
    pub linkage: mut String,
    pub declarations: mut Vector<ASTNode*>
} impl {
    ExternBlockNode(this: mut ExternBlockNode&, linkage: String, line: u64, col: u64) : ASTNode(ASTNodeType::EXTERN_BLOCK, line, col) {
        this.linkage = linkage;
    }
};

class RootNode : ASTNode {
    pub declarations: mut Vector<ASTNode*>
} impl {
    RootNode(this: mut RootNode&) : ASTNode(ASTNodeType::ROOT, 1u64, 1u64) {}
};

func PrintIndent(depth: i32) {
    let mut i: i32 = 0i32;

    while i < depth {
        printf("    ");
        i += 1i32;
    }
}

func PrintAST(node: ASTNode*, depth: i32) {
    if node == null {
        printf("null");
        ret;
    }

    if node->node_type != ASTNodeType::BLOCK_STMT {
        PrintIndent(depth);
        printf("%s", ASTNodeTypeToString(node->node_type).Data());
    }

    if node->node_type == ASTNodeType::LITERAL {
        let literal: LiteralNode* = node as LiteralNode*;
        printf("(value: %s, _type: %s)", literal->value.Escape().Data(), TokenTypeToString(literal->literal_type).Data());
    } else if node->node_type == ASTNodeType::IDENTIFIER {
        let identifier: IdentifierNode* = node as IdentifierNode*;
        printf("(name: %s)", identifier->name.Data());
    } else if node->node_type == ASTNodeType::BINARY_OP {
        let binary: BinaryOpNode* = node as BinaryOpNode*;
        printf("(operator: %s, left: ", TokenTypeToString(binary->operator).Data());
        PrintAST(binary->left, 0i32);
        printf(", right: ");
        PrintAST(binary->right, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::UNARY_OP {
        let unary: UnaryOpNode* = node as UnaryOpNode*;
        printf("(operator: %s, operand: ", TokenTypeToString(unary->operator).Data());
        PrintAST(unary->operand, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::CAST {
        let cast: CastNode* = node as CastNode*;
        printf("(value: ");
        PrintAST(cast->expression, 0i32);
        printf(", target: ");
        PrintAST(cast->target_type, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::VARIABLE_DECL {
        let var_decl: VariableDeclNode* = node as VariableDeclNode*;
        printf("(name: %s, mutable: %s, value: ", var_decl->name.Data(), var_decl->is_mutable ? "true" : "false");
        PrintAST(var_decl->initializer, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::RETURN_STMT {
        let ret_stmt: ReturnStmtNode* = node as ReturnStmtNode*;
        printf("(value: ");
        PrintAST(ret_stmt->value, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::EXPRESSION_STMT {
        let expr_stmt: ExpressionStmtNode* = node as ExpressionStmtNode*;
        printf("(expression: ");
        PrintAST(expr_stmt->expression, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::ASSIGNMENT {
        let assignment: AssignmentNode* = node as AssignmentNode*;
        printf("(operator: %s, left: ", TokenTypeToString(assignment->operator).Data());
        PrintAST(assignment->left, 0i32);
        printf(", right: ");
        PrintAST(assignment->right, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::IF_STMT {
        let if_stmt: IfStmtNode* = node as IfStmtNode*;
        printf("(condition: ");
        PrintAST(if_stmt->condition, 0i32);
        printf(", then: ");
        PrintAST(if_stmt->then_stmt, depth);
        printf(", else: ");
        PrintAST(if_stmt->else_stmt, depth);
        printf(")");
    } else if node->node_type == ASTNodeType::WHILE_STMT {
        let while_stmt: WhileStmtNode* = node as WhileStmtNode*;
        printf("(condition: ");
        PrintAST(while_stmt->condition, 0i32);
        printf(", body: ");
        PrintAST(while_stmt->body, depth);
        printf(")");
    } else if node->node_type == ASTNodeType::PARAMETER {
        let param: ParameterNode* = node as ParameterNode*;
        printf("(name: %s, mutable: %s, _type: ", param->name.Data(), param->is_mutable ? "true" : "false");
        PrintAST(param->param_type, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::FUNCTION_DECL {
        let func_decl: FunctionDeclNode* = node as FunctionDeclNode*;
        printf("(name: %s, return: ", func_decl->name.Data());
        PrintAST(func_decl->_type->return_type, 0i32);
        printf(", parameters: [");
        let mut i: u64 = 0u64;

        while i < func_decl->_type->parameters.Size() {
            PrintAST(func_decl->_type->parameters[i] as ASTNode*, 0i32);
            i += 1u64;

            if i < func_decl->_type->parameters.Size() {
                printf(", ");
            }
        }

        printf("])");
        PrintAST(func_decl->body as ASTNode*, depth);
    } else if node->node_type == ASTNodeType::CLASS_DECL {
        let class_decl: ClassDeclNode* = node as ClassDeclNode*;
        printf("(name: %s)", class_decl->name.Data());
    } else if node->node_type == ASTNodeType::ENUM_DECL {
        let enum_decl: EnumDeclNode* = node as EnumDeclNode*;
        printf("(name: %s)", enum_decl->name.Data());
    } else if node->node_type == ASTNodeType::PRIMITIVE_TYPE {
        let type_node: PrimitiveTypeNode* = node as PrimitiveTypeNode*;
        printf("(_type: %s, mutable: %s)", type_node->type_name.Data(), type_node->mutable ? "true" : "false");
    } else if node->node_type == ASTNodeType::POINTER_TYPE {
        let pointer_type: PointerTypeNode* = node as PointerTypeNode*;
        printf("(base_type: ");
        PrintAST(pointer_type->base_type, 0i32);
        printf(", mutable: %s)", pointer_type->mutable ? "true" : "false");
    } else if node->node_type == ASTNodeType::REFERENCE_TYPE {
        let reference_type: ReferenceTypeNode* = node as ReferenceTypeNode*;
        printf("(base_type: ");
        PrintAST(reference_type->base_type, 0i32);
        printf(", mutable: %s)", reference_type->mutable ? "true" : "false");
    } else if node->node_type == ASTNodeType::ARRAY_TYPE {
        let array_type: ArrayTypeNode* = node as ArrayTypeNode*;
        printf("(element_type: ");
        PrintAST(array_type->element_type, 0i32);
        printf(", size: ");
        PrintAST(array_type->size, 0i32);
        printf(")");
    } else if node->node_type == ASTNodeType::CALL {
        let call: CallNode* = node as CallNode*;
        printf("(expression: ");
        PrintAST(call->expression, 0i32);
        printf(", arguments: [");
        let mut i: u64 = 0u64;

        while i < call->arguments.Size() {
            PrintAST(call->arguments[i], 0i32);
            i += 1u64;

            if i < call->arguments.Size() {
                printf(", ");
            }
        }

        printf("])");
    } else if node->node_type == ASTNodeType::BLOCK_STMT {
        let block: BlockStmtNode* = node as BlockStmtNode*;
        let mut i: u64 = 0u64;
        printf("{\n");

        while i < block->statements.Size() {
            PrintAST(block->statements[i], depth + 1i32);
            printf("\n");
            i += 1u64;
        }

        PrintIndent(depth);
        printf("}");
    } else if node->node_type == ASTNodeType::ROOT {
        let root: RootNode* = node as RootNode*;
        let mut i: u64 = 0u64;
        printf(" {\n");

        while i < root->declarations.Size() {
            PrintAST(root->declarations[i], depth + 1i32);
            printf("\n");
            i += 1u64;

            if i < root->declarations.Size() {
                printf("\n");
            }
        }

        PrintIndent(depth);
        printf("}\n");
    } else {
        printf("(undefined)");
    }
}

class Parser {
    priv root: mut RootNode* = null,
    pub types: mut Vector<String>,
    pub include_paths: mut Vector<String>,
    priv included_paths: mut Vector<String>,
    priv tokens: mut Vector<Token>,
    priv current: u64 = 0u64,
    priv file: mut String
} impl {
    Parser(this: Parser&) {}
    ~Parser(this: Parser&) {}

    priv CurrentToken(this: Parser&) -> Token {
        if this.current >= this.tokens.Size() {
            ret { TokenType::EOF, "", 0u64, 0u64 } as Token;
        } else {
            ret this.tokens.Data()[this.current];
        }
    }

    priv PeekToken(this: Parser&, offset: u64) -> Token {
        let pos: u64 = this.current + offset;

        if pos >= this.tokens.Size() {
            ret { TokenType::EOF, "", 0u64, 0u64 } as Token;
        } else {
            ret this.tokens.Data()[pos];
        }
    }

    priv Advance(this: mut Parser&) -> Token {
        let token: Token = this.CurrentToken();

        if this.current < this.tokens.Size() {
            this.current += 1u64;
        } ret token;
    }

    priv Match(this: mut Parser&, _type: TokenType) -> bool {
        if this.CurrentToken()._type == _type {
            this.Advance();
            ret true;
        } else {
            ret false;
        }
    }

    priv Expect(this: mut Parser&, _type: TokenType) -> Token {
        let token: Token = this.CurrentToken();

        if token._type != _type {
            this.Error((String("Expected '") + TokenTypeToString(_type) + "' but got '" + TokenTypeToString(token._type) + "'").Data(), token.lineno, token.column);
        } else {
            this.Advance();
        } ret token;
    }

    priv GetBinaryOpPrecedence(this: Parser&, _type: TokenType) -> i32 {
        if _type == TokenType::OR { ret 1i32; }
        else if _type == TokenType::AND { ret 2i32; }
        else if _type == TokenType::BITWISE_OR { ret 3i32; }
        else if _type == TokenType::BITWISE_XOR { ret 4i32; }
        else if _type == TokenType::BITWISE_AND { ret 5i32; }
        else if _type == TokenType::EQUAL || _type == TokenType::NOT_EQUAL { ret 6i32; }
        else if _type == TokenType::LESS || _type == TokenType::LESS_EQUAL || _type == TokenType::GREATER || _type == TokenType::GREATER_EQUAL { ret 7i32; }
        else if _type == TokenType::LSHIFT || _type == TokenType::RSHIFT { ret 8i32; }
        else if _type == TokenType::PLUS || _type == TokenType::MINUS { ret 9i32; }
        else if _type == TokenType::MUL || _type == TokenType::DIV || _type == TokenType::MOD { ret 10i32; }
        else if _type == TokenType::AS { ret 11i32; }
        else { ret -1i32; }
    }

    priv IsBinaryOperator(this: Parser&, _type: TokenType) -> bool {
        let precedence: i32 = this.GetBinaryOpPrecedence(_type);
        ret precedence >= 0i32 && precedence != 11i32;
    }

    priv IsUnaryOperator(this: Parser&, _type: TokenType) -> bool {
        ret _type == TokenType::NOT || _type == TokenType::MINUS || _type == TokenType::BITWISE_AND || _type == TokenType::MUL;
    }

    priv IsAssignmentOperator(this: Parser&, _type: TokenType) -> bool {
        ret _type == TokenType::ASSIGN || _type == TokenType::PLUS_ASSIGN || _type == TokenType::MINUS_ASSIGN || _type == TokenType::MUL_ASSIGN || _type == TokenType::DIV_ASSIGN || _type == TokenType::MOD_ASSIGN
           || _type == TokenType::LSHIFT_ASSIGN || _type == TokenType::RSHIFT_ASSIGN || _type == TokenType::AND_ASSIGN || _type == TokenType::OR_ASSIGN || _type == TokenType::XOR_ASSIGN;
    }

    priv ParsePrimary(this: mut Parser&) -> ASTNode* {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::INTEGER || token._type == TokenType::FLOAT || token._type == TokenType::STRING || token._type == TokenType::CHAR || token._type == TokenType::TRUE || token._type == TokenType::FALSE || token._type == TokenType::NULL {
            this.Advance();
            ret new LiteralNode(token.value, token._type, token.lineno, token.column) as ASTNode*;
        } else if token._type == TokenType::NAME || token._type == TokenType::OPERATOR || token._type == TokenType::DOUBLE_COLON {
            let mut node: ASTNode* = null;

            if token._type != TokenType::DOUBLE_COLON {
                if this.types.Index(token.value) != -1i64 && this.PeekToken(1u64)._type != TokenType::DOUBLE_COLON {
                    node = this.ParseType();
                } else {
                    if this.Match(TokenType::OPERATOR) {
                        let identifier: mut String = "op";

                        while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                            identifier += this.CurrentToken().value;
                            this.Advance();
                        }

                        node = new IdentifierNode(identifier, token.lineno, token.column) as ASTNode*;
                    } else {
                        node = new IdentifierNode(this.Expect(TokenType::NAME).value, token.lineno, token.column) as ASTNode*;
                    }
                }
            }

            while this.Match(TokenType::DOUBLE_COLON) {
                let mut id_node: IdentifierNode* = null;

                if this.Match(TokenType::OPERATOR) {
                    let identifier: mut String = "op";

                    while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                        identifier += this.CurrentToken().value;
                        this.Advance();
                    }

                    id_node = new IdentifierNode(identifier, token.lineno, token.column);
                } else {
                    id_node = new IdentifierNode(this.Expect(TokenType::NAME).value, token.lineno, token.column);
                } node = new ScopeResolutionNode(node, id_node, token.lineno, token.column) as ASTNode*;
            } ret node;
        } else if token._type == TokenType::LBRACE {
            this.Advance();
            let initializer_list: mut InitializerListNode* = new InitializerListNode(token.lineno, token.column);

            if !this.Match(TokenType::RBRACE) {
                initializer_list->expressions.PushBack(this.ParseExpression());

                while this.Match(TokenType::COMMA) {
                    initializer_list->expressions.PushBack(this.ParseExpression());
                } this.Expect(TokenType::RBRACE);
            } ret initializer_list as ASTNode*;
        } else if token._type == TokenType::LPAREN {
            this.Advance();
            let expr: ASTNode* = this.ParseExpression();
            this.Expect(TokenType::RPAREN);
            ret expr;
        } else {
            this.Error((String("Unexpected token '") + token.value + "'").Data(), token.lineno, token.column);
            ret null;
        }
    }

    priv ParsePostfix(this: mut Parser&) -> ASTNode* {
        let mut expr: ASTNode* = this.ParsePrimary();

        while true {
            let token: Token = this.CurrentToken();

            if token._type == TokenType::LPAREN {
                this.Advance();
                let call: mut CallNode* = new CallNode(expr, token.lineno, token.column);

                if !this.Match(TokenType::RPAREN) {
                    call->arguments.PushBack(this.ParseExpression());

                    while this.Match(TokenType::COMMA) {
                        call->arguments.PushBack(this.ParseExpression());
                    } this.Expect(TokenType::RPAREN);
                } expr = call as ASTNode*;
            } else if token._type == TokenType::DOT || token._type == TokenType::ARROW {
                this.Advance();
                let member_access: mut MemberAccessNode* = new MemberAccessNode(expr, token._type == TokenType::ARROW, token.lineno, token.column);

                if this.Match(TokenType::OPERATOR) {
                    member_access->member += "op";

                    while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                        member_access->member += this.CurrentToken().value;
                        this.Advance();
                    }
                } else {
                    member_access->member += this.Expect(TokenType::NAME).value;
                } expr = member_access as ASTNode*;
            } else if token._type == TokenType::LBRACKET {
                this.Advance();
                let index_access: IndexAccessNode* = new IndexAccessNode(expr, this.ParseExpression(), token.lineno, token.column);
                this.Expect(TokenType::RBRACKET);
                expr = index_access as ASTNode*;
            } else {
                break;
            }
        } ret expr;
    }

    priv ParseUnary(this: mut Parser&) -> ASTNode* {
        let token: Token = this.CurrentToken();

        if this.IsUnaryOperator(token._type) {
            this.Advance();
            ret new UnaryOpNode(this.ParseUnary(), token._type, token.lineno, token.column) as ASTNode*;
        } else if token._type == TokenType::NEW {
            this.Advance();
            let _new: mut NewNode* = new NewNode(this.ParseType(), token.lineno, token.column);

            if this.Match(TokenType::LBRACKET) {
                _new->size = this.ParseExpression();
                this.Expect(TokenType::RBRACKET);
            } else if this.Match(TokenType::LPAREN) {
                if !this.Match(TokenType::RPAREN) {
                    _new->arguments.PushBack(this.ParseExpression());

                    while this.Match(TokenType::COMMA) {
                        _new->arguments.PushBack(this.ParseExpression());
                    } this.Expect(TokenType::RPAREN);
                }
            } ret _new as ASTNode*;
        } else if token._type == TokenType::DELETE {
            this.Advance();
            let delete: mut DeleteNode* = new DeleteNode(token.lineno, token.column);

            if this.Match(TokenType::LBRACKET) {
                delete->array = true;
                this.Expect(TokenType::RBRACKET);
            }

            delete->expression = this.ParseExpression();
            ret delete as ASTNode*;
        } else {
            ret this.ParsePostfix();
        }
    }

    priv ParseBinaryExpression(this: mut Parser&, min_precedence: i32) -> ASTNode* {
        let mut left: ASTNode* = this.ParseUnary();

        while true {
            let token: mut Token = this.CurrentToken();

            if this.PeekToken(1u64)._type == token._type {
                if token._type == TokenType::GREATER {
                    token._type = TokenType::RSHIFT;
                    this.Advance();
                }

                if token._type == TokenType::LESS {
                    token._type = TokenType::LSHIFT;
                    this.Advance();
                }
            }

            let precedence: i32 = this.GetBinaryOpPrecedence(token._type);
            if precedence < min_precedence { break; }
            this.Advance();

            if token._type == TokenType::AS {
                left = new CastNode(left, this.ParseType(), token.lineno, token.column) as ASTNode*;
            } else {
                left = new BinaryOpNode(left, this.ParseBinaryExpression(precedence + 1i32), token._type, token.lineno, token.column) as ASTNode*;
            }
        } ret left;
    }

    pub ParseExpression(this: mut Parser&) -> ASTNode* {
        let mut condition: ASTNode* = this.ParseBinaryExpression(0i32);
        let token: Token = this.CurrentToken();

        if token._type == TokenType::QUESTION_MARK {
            this.Advance();
            let then_expr: ASTNode* = this.ParseExpression();
            this.Expect(TokenType::COLON);
            let else_expr: ASTNode* = this.ParseExpression();
            condition = new TernaryNode(condition, then_expr, else_expr, token.lineno, token.column) as ASTNode*;
        } ret condition;
    }

    pub ParseType(this: mut Parser&) -> ASTNode* {
        let mutable: bool = this.Match(TokenType::MUT);
        let token: Token = this.CurrentToken();
        let mut node: ASTNode* = null;

        if this.Match(TokenType::FUNC) {
            this.Expect(TokenType::LPAREN);
            let func_type: mut FunctionTypeNode* = new FunctionTypeNode(token.lineno, token.column);

            if this.CurrentToken()._type != TokenType::RPAREN {
                let mut param: ParameterNode* = this.ParseParameter(func_type);
                if param != null { func_type->parameters.PushBack(param); }

                while this.Match(TokenType::COMMA) {
                    param = this.ParseParameter(func_type);
                    if param != null { func_type->parameters.PushBack(param); }
                }
            }

            this.Expect(TokenType::RPAREN);

            if this.Match(TokenType::ARROW) {
                func_type->return_type = this.ParseType();
            } else {
                func_type->return_type = new PrimitiveTypeNode({ "void" } as String, false, token.lineno, token.column) as ASTNode*;
            } node = func_type as ASTNode*;
        } else {
            if token._type != TokenType::NAME {
                this.Error("Expected type name", token.lineno, token.column);
                ret null;
            }

            let primitive: mut PrimitiveTypeNode* = new PrimitiveTypeNode(token.value, mutable, token.lineno, token.column);
            this.Advance();

            if this.Match(TokenType::LESS) {
                primitive->types.PushBack(this.ParseType());

                while this.Match(TokenType::COMMA) {
                    primitive->types.PushBack(this.ParseType());
                }

                this.Expect(TokenType::GREATER);
                primitive->generic = true;
            } node = primitive as ASTNode*;
        }

        while this.Match(TokenType::MUL) {
            node = new PointerTypeNode(node, mutable, token.lineno, token.column) as ASTNode*;
        }

        if this.Match(TokenType::BITWISE_AND) {
            node = new ReferenceTypeNode(node, mutable, token.lineno, token.column) as ASTNode*;
        } ret node;
    }

    pub ParseStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::LET {
            ret this.ParseVariableDeclaration();
        } else if token._type == TokenType::IF {
            ret this.ParseIfStatement();
        } else if token._type == TokenType::WHILE {
            ret this.ParseWhileStatement();
        } else if token._type == TokenType::RETURN {
            ret this.ParseReturnStatement();
        } else if token._type == TokenType::BREAK {
            this.Advance();
            this.Expect(TokenType::SEMICOLON);
            ret new BreakStmtNode(token.lineno, token.column) as ASTNode*;
        } else if token._type == TokenType::CONTINUE {
            this.Advance();
            this.Expect(TokenType::SEMICOLON);
            ret new ContinueStmtNode(token.lineno, token.column) as ASTNode*;
        } else if token._type == TokenType::LBRACE {
            ret this.ParseBlockStatement();
        } else {
            if this.Match(TokenType::LPAREN) {
                let mut current: mut AssignmentNode* = null;
                let mut root: AssignmentNode* = null;

                while root == null || this.Match(TokenType::COMMA) {
                    let assignment: AssignmentNode* = new AssignmentNode(this.ParseExpression(), null, TokenType::ASSIGN, token.lineno, token.column);

                    if root != null {
                        current->next = assignment;
                    } else {
                        root = assignment;
                    } current = assignment;
                }

                this.Expect(TokenType::RPAREN);
                this.Expect(TokenType::ASSIGN);
                this.Expect(TokenType::LPAREN);
                current = root;

                while current != null {
                    current->right = this.ParseExpression();

                    if current->next != null {
                        this.Expect(TokenType::COMMA);
                    } current = current->next;
                }

                this.Expect(TokenType::RPAREN);
                this.Expect(TokenType::SEMICOLON);
                ret root as ASTNode*;
            } else {
                let expr: ASTNode* = this.ParseExpression();

                if this.IsAssignmentOperator(this.CurrentToken()._type) {
                    let token: Token = this.Advance();
                    let assignment: AssignmentNode* = new AssignmentNode(expr, this.ParseExpression(), token._type, token.lineno, token.column);
                    this.Expect(TokenType::SEMICOLON);
                    ret assignment as ASTNode*;
                } else {
                    this.Expect(TokenType::SEMICOLON);
                    ret new ExpressionStmtNode(expr, token.lineno, token.column) as ASTNode*;
                }
            }
        }
    }

    priv ParseConstantDeclaration(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::CONST);
        let name_token: Token = this.Expect(TokenType::NAME);
        let sizes: mut Vector<ASTNode*>;

        while this.Match(TokenType::LBRACKET) {
            if this.Match(TokenType::RBRACKET) {
                sizes.PushBack(null);
            } else {
                sizes.PushBack(this.ParseExpression());
                this.Expect(TokenType::RBRACKET);
            }
        }

        this.Expect(TokenType::COLON);
        let mut var_type: ASTNode* = this.ParseType();
        let mut i: u64 = 0u64;

        while i < sizes.Size() {
            var_type = new ArrayTypeNode(var_type, sizes[i], token.lineno, token.column) as ASTNode*;
            i += 1u64;
        }

        this.Expect(TokenType::ASSIGN);
        let initializer: ASTNode* = this.ParseExpression();
        this.Expect(TokenType::SEMICOLON);
        ret new ConstantDeclNode(name_token.value, var_type, initializer, token.lineno, token.column) as ASTNode*;
    }

    priv ParseVariableDeclaration(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::LET);
        let multiple: bool = this.Match(TokenType::LPAREN);
        let mut current: mut VariableDeclNode* = null;
        let mut root: VariableDeclNode* = null;

        while root == null || (multiple && root != null && this.Match(TokenType::COMMA)) {
            let is_mutable: bool = this.Match(TokenType::MUT);
            let name_token: Token = this.Expect(TokenType::NAME);
            let sizes: mut Vector<ASTNode*>;

            while this.Match(TokenType::LBRACKET) {
                if this.Match(TokenType::RBRACKET) {
                    sizes.PushBack(null);
                } else {
                    sizes.PushBack(this.ParseExpression());
                    this.Expect(TokenType::RBRACKET);
                }
            }

            this.Expect(TokenType::COLON);
            let mut var_type: ASTNode* = this.ParseType();
            let mut i: u64 = 0u64;

            while i < sizes.Size() {
                var_type = new ArrayTypeNode(var_type, sizes[i], token.lineno, token.column) as ASTNode*;
                i += 1u64;
            }

            let decl: VariableDeclNode* = new VariableDeclNode(name_token.value, var_type, null, is_mutable, token.lineno, token.column);

            if root != null {
                current->next = decl;
            } else {
                root = decl;
            } current = decl;
        }

        if multiple {
            this.Expect(TokenType::RPAREN);
        }

        if this.Match(TokenType::ASSIGN) {
            if multiple {
                this.Expect(TokenType::LPAREN);
            } current = root;

            while current != null {
                current->initializer = this.ParseExpression();

                if current->next != null {
                    this.Expect(TokenType::COMMA);
                } current = current->next;
            }

            if multiple {
                this.Expect(TokenType::RPAREN);
            }
        }

        this.Expect(TokenType::SEMICOLON);
        ret root as ASTNode*;
    }

    priv ParseIfStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::IF);
        let condition: ASTNode* = this.ParseExpression();
        let then_stmt: ASTNode* = this.ParseStatement();
        let mut else_stmt: ASTNode* = null;

        if this.Match(TokenType::ELSE) {
            else_stmt = this.ParseStatement();
        }

        ret new IfStmtNode(condition, then_stmt, else_stmt, token.lineno, token.column) as ASTNode*;
    }

    priv ParseWhileStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::WHILE);
        ret new WhileStmtNode(this.ParseExpression(), this.ParseStatement(), token.lineno, token.column) as ASTNode*;
    }

    priv ParseReturnStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::RETURN);
        let mut value: ASTNode* = null;

        if this.CurrentToken()._type != TokenType::SEMICOLON {
            value = this.ParseExpression();
        }

        this.Expect(TokenType::SEMICOLON);
        ret new ReturnStmtNode(value, token.lineno, token.column) as ASTNode*;
    }

    priv ParseBlockStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::LBRACE);
        let block: mut BlockStmtNode* = new BlockStmtNode(token.lineno, token.column);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            let stmt: ASTNode* = this.ParseStatement();

            if stmt != null {
                block->statements.PushBack(stmt);
            }
        }

        this.Expect(TokenType::RBRACE);
        ret block as ASTNode*;
    }

    pub ParseDeclaration(this: mut Parser&) -> ASTNode* {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::FUNC {
            ret this.ParseFunctionDeclaration();
        } else if token._type == TokenType::CLASS {
            ret this.ParseClassDeclaration();
        } else if token._type == TokenType::ENUM {
            ret this.ParseEnumDeclaration();
        } else if token._type == TokenType::EXTERN {
            ret this.ParseExternBlock();
        } else if token._type == TokenType::INCLUDE {
            ret this.ParseIncludeStatement();
        } else if token._type == TokenType::CONST {
            ret this.ParseConstantDeclaration();
        } else if token._type == TokenType::TYPE {
            ret this.ParseTypeDeclaration();
        } else {
            this.Error("Expected declaration", token.lineno, token.column);
            ret null;
        }
    }

    priv ParseTypeDeclaration(this: mut Parser&) -> ASTNode* {
        let type_token: Token = this.Expect(TokenType::TYPE);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), type_token.lineno, type_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        this.Expect(TokenType::ASSIGN);
        let type_decl: TypeDeclNode* = new TypeDeclNode(name_token.value, this.ParseType(), type_token.lineno, type_token.column);
        this.Expect(TokenType::SEMICOLON);
        ret type_decl as ASTNode*;
    }

    priv ParseFunctionDeclaration(this: mut Parser&) -> ASTNode* {
        let token: Token = this.CurrentToken();
        let name: mut String;

        if token._type == TokenType::TILDE || token._type == TokenType::FUNC || token._type == TokenType::PUBLIC || token._type == TokenType::PRIVATE {
            this.Advance();

            if token._type == TokenType::TILDE {
                name += token.value;
            }
        }

        if this.Match(TokenType::OPERATOR) {
            name += "op";

            while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                name += this.CurrentToken().value;
                this.Advance();
            }
        } else {
            name += this.Expect(TokenType::NAME).value;
        }

        let func_type: mut FunctionTypeNode* = new FunctionTypeNode(token.lineno, token.column);
        let func_decl: mut FunctionDeclNode* = new FunctionDeclNode(name, func_type, null, token.lineno, token.column);

        if this.Match(TokenType::LESS) {
            func_decl->types.PushBack(this.Expect(TokenType::NAME).value);

            while this.Match(TokenType::COMMA) {
                func_decl->types.PushBack(this.Expect(TokenType::NAME).value);
            }

            this.Expect(TokenType::GREATER);
            func_decl->generic = true;
        }

        this.Expect(TokenType::LPAREN);

        if this.CurrentToken()._type != TokenType::RPAREN {
            let mut param: ParameterNode* = this.ParseParameter(func_type);
            if param != null { func_type->parameters.PushBack(param); }

            while this.Match(TokenType::COMMA) {
                param = this.ParseParameter(func_type);
                if param != null { func_type->parameters.PushBack(param); }
            }
        }

        this.Expect(TokenType::RPAREN);

        if this.Match(TokenType::ARROW) {
            func_type->return_type = this.ParseType();
        } else {
            func_type->return_type = new PrimitiveTypeNode({ "void" } as String, false, token.lineno, token.column) as ASTNode*;

            if token._type != TokenType::FUNC && token._type != TokenType::PUBLIC && token._type != TokenType::PRIVATE {
                while (this.Match(TokenType::COLON) && func_decl->constructors.Size() == 0u64) || (this.Match(TokenType::COMMA) && func_decl->constructors.Size() > 0u64) {
                    let expression: ASTNode* = this.ParseExpression();

                    if expression->node_type == ASTNodeType::CALL {
                        func_decl->constructors.PushBack(expression as CallNode*);
                    } else {
                        this.Error("Expected a function call", token.lineno, token.column);
                        break;
                    }
                }
            }
        }

        if this.CurrentToken()._type == TokenType::LBRACE {
            func_decl->body = this.ParseBlockStatement() as BlockStmtNode*;
        } else {
            this.Expect(TokenType::SEMICOLON);
        } ret func_decl as ASTNode*;
    }

    priv ParseParameter(this: mut Parser&, func_type: mut FunctionTypeNode*) -> ParameterNode* {
        func_type->var_arg = this.Match(TokenType::THREE_DOT);
        if func_type->var_arg { ret null; }

        let is_mutable: bool = this.Match(TokenType::MUT);

        if this.PeekToken(1u64)._type == TokenType::COLON || this.PeekToken(1u64)._type == TokenType::LBRACKET {
            let token: Token = this.Expect(TokenType::NAME);
            let sizes: mut Vector<ASTNode*>;

            while this.Match(TokenType::LBRACKET) {
                if this.Match(TokenType::RBRACKET) {
                    sizes.PushBack(null);
                } else {
                    sizes.PushBack(this.ParseExpression());
                    this.Expect(TokenType::RBRACKET);
                }
            }

            this.Expect(TokenType::COLON);
            let mut param_type: ASTNode* = this.ParseType();
            let mut i: u64 = 0u64;

            while i < sizes.Size() {
                param_type = new ArrayTypeNode(param_type, sizes[i], token.lineno, token.column) as ASTNode*;
                i += 1u64;
            }

            ret new ParameterNode(token.value, param_type, is_mutable, token.lineno, token.column);
        } else {
            let token: Token = this.CurrentToken();
            ret new ParameterNode(String(""), this.ParseType(), is_mutable, token.lineno, token.column);
        }
    }

    priv ParseClassDeclaration(this: mut Parser&) -> ASTNode* {
        let class_token: Token = this.Expect(TokenType::CLASS);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), class_token.lineno, class_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        let class_decl: mut ClassDeclNode* = new ClassDeclNode(name_token.value, class_token.lineno, class_token.column);

        if this.Match(TokenType::LESS) {
            class_decl->types.PushBack(this.Expect(TokenType::NAME).value);

            while this.Match(TokenType::COMMA) {
                class_decl->types.PushBack(this.Expect(TokenType::NAME).value);
            }

            this.Expect(TokenType::GREATER);
            class_decl->generic = true;
        }

        if this.Match(TokenType::COLON) {
            class_decl->parents.PushBack(this.ParseType());

            while this.Match(TokenType::COMMA) {
                class_decl->parents.PushBack(this.ParseType());
            }
        }

        this.Expect(TokenType::LBRACE);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            let visibility_token: Token = this.CurrentToken();

            if visibility_token._type == TokenType::PUBLIC || visibility_token._type == TokenType::PRIVATE {
                this.Advance();
            } else {
                this.Error("Expected visibility modifier", visibility_token.lineno, visibility_token.column);
                break;
            }

            let member_token: Token = this.CurrentToken();

            if member_token._type == TokenType::NAME {
                class_decl->fields.PushBack(Pair<TokenType, FieldNode*>(visibility_token._type, this.ParseField()));
            } else {
                this.Error("Expected field declaration", member_token.lineno, member_token.column);
                break;
            }
        }

        this.Expect(TokenType::RBRACE);

        if this.Match(TokenType::IMPL) {
            this.Expect(TokenType::LBRACE);

            while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
                let visibility_token: Token = this.CurrentToken();

                if visibility_token._type == TokenType::PUBLIC || visibility_token._type == TokenType::PRIVATE {
                    class_decl->methods.PushBack(Pair<TokenType, FunctionDeclNode*>(visibility_token._type, this.ParseFunctionDeclaration() as FunctionDeclNode*));
                } else {
                    if this.CurrentToken()._type == TokenType::TILDE {
                        if class_decl->destructor != null {
                            this.Error("Multiple destructor declarations are not allowed", visibility_token.lineno, visibility_token.column);
                            break;
                        }

                        class_decl->destructor = this.ParseFunctionDeclaration() as FunctionDeclNode*;
                    } else {
                        class_decl->constructors.PushBack(this.ParseFunctionDeclaration() as FunctionDeclNode*);
                    }
                }
            }

            this.Expect(TokenType::RBRACE);
        }

        this.Expect(TokenType::SEMICOLON);
        ret class_decl as ASTNode*;
    }

    priv ParseField(this: mut Parser&) -> FieldNode* {
        let token: Token = this.Expect(TokenType::NAME);
        let sizes: mut Vector<ASTNode*>;

        while this.Match(TokenType::LBRACKET) {
            if this.Match(TokenType::RBRACKET) {
                sizes.PushBack(null);
            } else {
                sizes.PushBack(this.ParseExpression());
                this.Expect(TokenType::RBRACKET);
            }
        }

        this.Expect(TokenType::COLON);
        let mut field_type: ASTNode* = this.ParseType();
        let mut initializer: ASTNode* = null;
        let mut i: u64 = 0u64;

        while i < sizes.Size() {
            field_type = new ArrayTypeNode(field_type, sizes[i], token.lineno, token.column) as ASTNode*;
            i += 1u64;
        }

        if this.Match(TokenType::ASSIGN) {
            initializer = this.ParseExpression();
        }

        if this.CurrentToken()._type == TokenType::SEMICOLON {
            this.Advance();
        } else if this.CurrentToken()._type == TokenType::COMMA {
            this.Advance();
        }

        ret new FieldNode(token.value, field_type, initializer, token.lineno, token.column);
    }

    priv ParseEnumDeclaration(this: mut Parser&) -> ASTNode* {
        let enum_token: Token = this.Expect(TokenType::ENUM);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), enum_token.lineno, enum_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        let enum_decl: mut EnumDeclNode* = new EnumDeclNode(name_token.value, enum_token.lineno, enum_token.column);

        if this.Match(TokenType::COLON) {
            let _type: ASTNode* = this.ParseType();
            enum_decl->underlying_type = _type;
        } else {
            enum_decl->underlying_type = new PrimitiveTypeNode({ "i32" } as String, false, enum_token.lineno, enum_token.column) as ASTNode*;
        }

        this.Expect(TokenType::LBRACE);

        if this.CurrentToken()._type != TokenType::RBRACE {
            let mut name_token: Token = this.Expect(TokenType::NAME);

            if this.Match(TokenType::ASSIGN) {
                enum_decl->values[name_token.value] = this.ParseExpression();
            } else {
                enum_decl->values[name_token.value] = null;
            }

            while this.Match(TokenType::COMMA) {
                name_token = this.Expect(TokenType::NAME);

                if this.Match(TokenType::ASSIGN) {
                    enum_decl->values[name_token.value] = this.ParseExpression();
                } else {
                    enum_decl->values[name_token.value] = null;
                }
            }
        }

        this.Expect(TokenType::RBRACE);
        this.Match(TokenType::SEMICOLON);
        ret enum_decl as ASTNode*;
    }

    priv ParseExternBlock(this: mut Parser&) -> ASTNode* {
        let extern_token: Token = this.Expect(TokenType::EXTERN);
        let linkage_token: Token = this.Expect(TokenType::STRING);
        let extern_block: mut ExternBlockNode* = new ExternBlockNode(linkage_token.value, extern_token.lineno, extern_token.column);
        this.Expect(TokenType::LBRACE);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            if this.CurrentToken()._type == TokenType::FUNC {
                extern_block->declarations.PushBack(this.ParseFunctionDeclaration());
            } else {
                this.Error("Only function declarations allowed in extern block", this.CurrentToken().lineno, this.CurrentToken().column);
            }
        }

        this.Expect(TokenType::RBRACE);
        ret extern_block as ASTNode*;
    }

    priv ParseIncludeStatement(this: mut Parser&) -> ASTNode* {
        let token: Token = this.Expect(TokenType::INCLUDE);
        let modules: mut Vector<String>;

        while this.Match(TokenType::COMMA) || modules.Size() == 0u64 {
            modules.PushBack(this.Expect(TokenType::STRING).value);
        }

        this.Expect(TokenType::COLON);
        this.Expect(TokenType::MUL);
        this.Expect(TokenType::SEMICOLON);
        let mut i: u64 = 0u64;

        while i < modules.Size() {
            let (mut found: bool, mut j: u64) = (false, 0u64);
            let module: String = modules[i];

            while j < this.include_paths.Size() {
                let path: mut String = this.include_paths[j] + "\\" + modules[i];
                let attr: DWORD = GetFileAttributesA(path.Data());
                j += 1u64;

                if attr == INVALID_FILE_ATTRIBUTES {
                    continue;
                }

                if (attr & FILE_ATTRIBUTE_DIRECTORY) != 0u32{
                    path += "\\Entry.div";

                    if GetFileAttributesA(path.Data()) == INVALID_FILE_ATTRIBUTES {
                        this.Error((String("Module '") + module + "' entry point not found").Data(), token.lineno, token.column);
                        ret null;
                    }
                }

                if this.included_paths.Index(path) != -1i64 {
                    found = true;
                    break;
                }

                let lexer: mut Lexer;
                let source: String = ReadFile(path.Data());
                let (tokens: Vector<Token>, current: u64, file: String) = (this.tokens, this.current, this.file);
                (this.tokens, this.current, this.file) = (lexer.Lex(source), 0u64, path);

                while this.CurrentToken()._type != TokenType::EOF {
                    let declaration: ASTNode* = this.ParseDeclaration();

                    if declaration != null {
                        this.root->declarations.PushBack(declaration);
                    }
                }

                (this.tokens, this.current, this.file, found) = (tokens, current, file, true);
                this.included_paths.PushBack(path);
                break;
            }

            if found {
                i += 1u64;
            } else {
                this.Error((String("Module '") + module + "' not found").Data(), token.lineno, token.column);
                ret null;
            }
        } ret null;
    }

    pub Parse(this: mut Parser&, tokens: Vector<Token>, file: String) -> RootNode* {
        (this.tokens, this.file, this.root) = (tokens, file, new RootNode());

        while this.CurrentToken()._type != TokenType::EOF {
            let declaration: ASTNode* = this.ParseDeclaration();

            if declaration != null {
                this.root->declarations.PushBack(declaration);
            }
        } ret this.root;
    }

    priv Error(this: mut Parser&, message: i8*, line: u64, col: u64) {
        printf("Parser error: %s at line %d, column %d. (%s)\n", message, line, col, this.file.Data());
        exit(1i32);
    }
};