include "divio", "divllvm", "lexer.div", "parser.div", "compiler.div" : *;

type BOOL = i32;
type BYTE = u8;
type LPBYTE = u8*;
type WORD = u16;
type DWORD = u32;
type LPDWORD = u32*;
type QWORD = u64;
type LARGE_INTEGER = i64;
type LONGLONG = i64;
type ULONGLONG = u64;
type ULONG_PTR = u64;
type HANDLE = void*;
type LPCSTR = i8*;
type LPSTR = i8*;
type LPVOID = void*;

class STARTUPINFOA {
    pub cb: DWORD,
    pub lpReserved: LPSTR,
    pub lpDesktop: LPSTR,
    pub lpTitle: LPSTR,
    pub dwX: DWORD,
    pub dwY: DWORD,
    pub dwXSize: DWORD,
    pub dwYSize: DWORD,
    pub dwXCountChars: DWORD,
    pub dwYCountChars: DWORD,
    pub dwFillAttribute: DWORD,
    pub dwFlags: DWORD,
    pub wShowWindow: WORD,
    pub cbReserved2: WORD,
    pub lpReserved2: LPBYTE,
    pub hStdInput: HANDLE,
    pub hStdOutput: HANDLE,
    pub hStdError: HANDLE
};

type LPSTARTUPINFOA = STARTUPINFOA*;

class PROCESS_INFORMATION {
    pub hProcess: HANDLE,
    pub hThread: HANDLE,
    pub dwProcessId: DWORD,
    pub dwThreadId: DWORD
};

type LPPROCESS_INFORMATION = PROCESS_INFORMATION*;

extern "C" {
    func QueryPerformanceCounter(lpPerformanceCount: LARGE_INTEGER*) -> BOOL;
    func QueryPerformanceFrequency(lpFrequency: LARGE_INTEGER*) -> BOOL;

    func CreateProcessA(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPVOID, lpThreadAttributes: LPVOID, bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION) -> BOOL;
    func WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
    func GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) -> BOOL;
    func CloseHandle(hObject: HANDLE) -> BOOL;
    func GetLastError() -> DWORD;
}

class Timer {
    priv frequency: LARGE_INTEGER,
    priv counter: LARGE_INTEGER
} impl {
    Timer(this: Timer&) {
        QueryPerformanceFrequency(&this.frequency);
    }

    ~Timer(this: Timer&) {}

    pub Get(this: Timer&) -> f64 {
        QueryPerformanceCounter(&this.counter);
        ret (this.counter as f64) / (this.frequency as f64);
    }
};

const STARTF_USESTDHANDLES: u32 = 0x00000100u32;
const INFINITE: u32 = 0xFFFFFFFFu32;

func Execute(command: i8*, output: bool) -> DWORD {
    let mut startup_info: STARTUPINFOA;
    memset(&startup_info as void*, 0i32, sizeof(startup_info));
    startup_info.cb = sizeof(startup_info) as DWORD;
    let mut process_info: PROCESS_INFORMATION;

    if output != true {
        (startup_info.hStdOutput, startup_info.hStdError, startup_info.hStdInput) = (null, null, null);
        startup_info.dwFlags |= STARTF_USESTDHANDLES;
    }

    if CreateProcessA(null, command, null, null, 0i32, 0u32, null, null, &startup_info, &process_info) == 0i32 {
        printf("Failed to create process: %lu.\n", GetLastError());
        exit(1i32);
    }

    let exit_code: DWORD;
    WaitForSingleObject(process_info.hProcess, INFINITE);

    if GetExitCodeProcess(process_info.hProcess, &exit_code) == 0i32 {
        printf("Failed to get process exit code: %lu.\n", GetLastError());
    }

    CloseHandle(process_info.hProcess);
    CloseHandle(process_info.hThread);
    ret exit_code;
}

func ReadFile(path: i8*) -> String {
    let file: FILE* = fopen(path, "r");

    if file == null {
        printf("Failed to open file: '%s'.\n", path);
        exit(1i32);
    }

    let buffer[256u64]: i8;
    let mut content: String;

    while fgets(buffer, sizeof(buffer) as i32, file) != null {
        content += buffer;
    }

    fclose(file);
    ret content;
}

func ErrorHandler(reason: i8*) {
    printf("LLVM fatal error: %s\n", reason);
    exit(1i32);
}

func main(argc: i32, argv[]: i8*) -> i32 {
    let timer: Timer;
    let start: f64 = timer.Get();

    LLVMEnablePrettyStackTrace();
    LLVMInstallFatalErrorHandler(ErrorHandler);

    if argc < 2i32 {
        printf("Usage: .\\parser.exe <source_file>\n");
        ret 1i32;
    }

    let mut lexer: Lexer;
    let source: String = ReadFile(argv[1u64]);
    let tokens: Vector<Token> = lexer.Lex(source);
    let mut index: u64 = 0u64;

    while tokens.Size() > index {
        let token: Token = tokens.Data()[index];
        printf("Token: %s '%s' (Line: %d, Col: %d)\n", TokenTypeToString(token._type).Data(), token.value.Escape().Data(), token.lineno, token.column);
        index += 1u64;
    }

    let mut parser: Parser;
    let ast: RootNode* = parser.Parse(tokens);

    if parser.HasError() {
        printf("Parser encountered errors.\n");
        ret 1i32;
    }

    if ast == null {
        printf("Failed to parse program.\n");
        ret 1i32;
    }

    printf("\n");
    PrintAST(ast as ASTNode*, 0i32);

    let mut compiler: Compiler;
    let module: LLVMModuleRef = compiler.Compile(ast);

    printf("\n");
    LLVMDumpModule(module);
    let err: i8* = null;

    if (LLVMVerifyModule(module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0i32) {
        printf("Module verification failed: %s.\n", err);
        LLVMDisposeMessage(err);
        ret 1i32;
    }

    LLVMDisposeMessage(err);
    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    // LLVMInitializeNativeAsmParser();
    // LLVMInitializeNativeDisassembler();

    if false {
        let engine: LLVMExecutionEngineRef;
        let mut options: LLVMMCJITCompilerOptions;
        LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));
        options.OptLevel = 0u32;
        let err: i8* = null;

        if LLVMCreateMCJITCompilerForModule(&engine, module, &options, sizeof(options), &err) != 0i32 {
            printf("Failed to create execution engine: %s.\n", err);
            LLVMDisposeMessage(err);
            ret 1i32;
        }

        LLVMDisposeMessage(err);
        printf("\nProgram compiled in %f seconds.\n", timer.Get() - start);
        let addr: u64 = LLVMGetFunctionAddress(engine, "main");

        if addr == 0u64 {
            printf("Couldn't get function address.\n");
            ret 1i32;
        }

        printf("Program finished with exit code: %d.\n", (addr as func() -> i32)());
        LLVMDisposeExecutionEngine(engine);
    } else {
        let target: LLVMTargetRef;
        let triple: i8* = LLVMGetDefaultTargetTriple();
        LLVMGetTargetFromTriple(triple, &target, null);
        let target_machine: LLVMTargetMachineRef = LLVMCreateTargetMachine(target, triple, "generic", "", LLVMCodeGenOptLevel::LLVMCodeGenLevelDefault, LLVMRelocMode::LLVMRelocDefault, LLVMCodeModel::LLVMCodeModelDefault);

        let err: i8* = null;
        LLVMSetTarget(module, triple);

        if LLVMTargetMachineEmitToFile(target_machine, module, "out.obj", LLVMCodeGenFileType::LLVMObjectFile, &err) != 0i32 {
            printf("Failed to emit object to file: %s.\n", err);
            LLVMDisposeMessage(err);
            ret 1i32;
        }

        LLVMDisposeMessage(err);
        printf("\nProgram compiled in %f seconds.\n", timer.Get() - start);
        LLVMDisposeTargetMachine(target_machine);

        let sdk_path: String = "C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.26100.0";
        let vs_path: String = "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207";
        let command: String = String("\"") + vs_path + "\\bin\\Hostx64\\x64\\link.exe\" /NOLOGO /DEBUG out.obj /OUT:out.exe \"/LIBPATH:" + vs_path + "\\lib\\x64\" \"/LIBPATH:" + sdk_path + "\\um\\x64\" \"/LIBPATH:" + sdk_path + "\\ucrt\\x64\" legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib";        
        Execute(command.Data(), true);

        printf("Program finished with exit code: %d.\n", Execute("out.exe", true));
    } ret 0i32;
}