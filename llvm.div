include "divio", "divstr", "divvec", "divllvm" : *;

class ASTNode {
    pub a: f64
} impl {
    ASTNode(mut this: ASTNode&, a: f64) {
        this.a = a;
    }
};

class TypeNode : ASTNode {
    pub b: i64
} impl {
    TypeNode(mut this: TypeNode&, a: f64, b: i64) : ASTNode(a) {
        this.b = b;
    }
};

func main() -> i32 {
    let test: TypeNode = { 1.23f64, 42i64 };
    printf("test.b = %d\n", test.b);
    let mut nodes: Vector<ASTNode*>;
    nodes.PushBack((&test) as (ASTNode*));
    printf("test2.a = %f\n", nodes[0i64]->a);
    let test3: TypeNode& = nodes[0i64] as (TypeNode*);
    printf("test3.b = %d\n", test3.b);

    let context: LLVMContextRef = LLVMContextCreate();
    let module: LLVMModuleRef = LLVMModuleCreateWithNameInContext("my_module", context);
    let builder: LLVMBuilderRef = LLVMCreateBuilderInContext(context);

    let printf_params[]: LLVMTypeRef = { LLVMPointerType(LLVMInt8TypeInContext(context), 0u32) };
    let printf_type: LLVMTypeRef = LLVMFunctionType(LLVMInt32TypeInContext(context), printf_params, 1u32, 1i32);
    let printf_func: LLVMValueRef = LLVMAddFunction(module, "printf", printf_type);

    let add_params[]: LLVMTypeRef = { LLVMInt32TypeInContext(context), LLVMInt32TypeInContext(context) };
    let add_type: LLVMTypeRef = LLVMFunctionType(LLVMInt32TypeInContext(context), add_params, 2u32, 0i32);
    let add_func: LLVMValueRef = LLVMAddFunction(module, "add", add_type);

    let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(context, add_func, "entry");
    LLVMPositionBuilderAtEnd(builder, entry);

    let global_str: LLVMValueRef = LLVMBuildGlobalStringPtr(builder, "Hello from sum: %d\n", "fmt");
    let call_params[]: LLVMValueRef = { global_str, LLVMConstInt(LLVMInt32TypeInContext(context), 42u64, 0i32) };
    let return: LLVMValueRef = LLVMBuildCall2(builder, printf_type, printf_func, call_params, 2u32, "call");

    let a: LLVMValueRef = LLVMGetParam(add_func, 0u32);
    let b: LLVMValueRef = LLVMGetParam(add_func, 1u32);
    LLVMSetValueName2(a, "a", 1u64);
    LLVMSetValueName2(b, "b", 1u64);

    let sum: LLVMValueRef = LLVMBuildAdd(builder, a, b, "sum");
    LLVMBuildRet(builder, sum);

    let string: i8* = LLVMPrintModuleToString(module);
    printf("%s\n", string);
    LLVMDisposeMessage(string);

    let mut err: i8* = null;

    if (LLVMVerifyModule(module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0) {
        printf("Module verification failed: '%s'.\n", err);
        LLVMDisposeMessage(err);
        ret 1;
    }

    LLVMDisposeMessage(err);

    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    LLVMInitializeNativeAsmParser();

    let mut options: LLVMMCJITCompilerOptions;
    LLVMInitializeMCJITCompilerOptions(&options, sizeof(options) as u64);
    options.OptLevel = 2u32;

    let engine: LLVMExecutionEngineRef = null;
    err = null;

    if (LLVMCreateMCJITCompilerForModule(&engine, module, &options, sizeof(options) as u64, &err) != 0) {
        printf("Failed to create execution engine: '%s'.\n", err);
        LLVMDisposeMessage(err);
        ret 1;
    }

    LLVMDisposeMessage(err);

    let addr: u64 = LLVMGetFunctionAddress(engine, "add");

    if (addr == 0u64) {
        printf("Couldn't get function address.\n");
        ret 1;
    }

    printf("sum(4, 3) = %d\n", (addr as func(i32, i32) -> i32)(4, 3));

    LLVMDisposeBuilder(builder);
    LLVMDisposeExecutionEngine(engine);
    LLVMContextDispose(context);
    ret 0i32;
}