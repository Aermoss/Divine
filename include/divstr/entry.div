include "divmem" : *;

extern "C" {
    func strlen(str: i8*) -> i64;
    func strcmp(str1: i8*, str2: i8*) -> i32;
}

class String {
    priv data: i8* = null,
    priv size: i64 = 0i64
} impl {
    String() {
        Allocate(1i64);
        data[0i64] = '\0';
    }

    String(other: String&) {
        this->String(other.Data());
    }

    String(string: i8*) {
        if string == null { ret; }
        Allocate(strlen(string) + 1i64);
        memcpy(data, string, size);
    }

    ~String() {
        Release();
    }

    pub Data() -> i8* { ret data; }
    pub Size() -> i64 { ret size; }

    priv Allocate(newSize: i64) {
        (data, size) = (malloc(newSize), newSize);
    }

    priv Release() {
        if data != null { free(data); }
        (data, size) = (null, 0i64);
    }

    pub op=(other: String&) -> String& {
        ret this->op=(other.Data());
    }

    pub op=(string: i8*) -> String& {
        if string == null { ret *this; }
        if data != null { free(data); }
        this->Allocate(strlen(string) + 1i64);
        memcpy(data, string, size);
        ret *this;
    }

    pub op=(character: i8) -> String& {
        if data != null { free(data); }
        this->Allocate(2i64);
        data[0i64] = character;
        data[1i64] = '\0';
        ret *this;
    }

    pub op+=(other: String&) -> String& {
        ret this->op+=(other.Data());
    }

    pub op+=(string: i8*) -> String& {
        if string == null { ret *this; }
        let (oldData: i8*, oldSize: i64) = (data, strlen(data));
        this->Allocate(oldSize + strlen(string) + 1i64);

        if oldData != null {
            memcpy(data, oldData, oldSize);
            free(oldData);
        }

        memcpy(data + oldSize, string, strlen(string) + 1i64);
        ret *this;
    }

    pub op+=(character: i8) -> String& {
        let (oldData: i8*, oldSize: i64) = (data, strlen(data));
        this->Allocate(oldSize + 2i64);

        if oldData != null {
            memcpy(data, oldData, oldSize);
            free(oldData);
        }

        data[oldSize] = character;
        data[oldSize + 1i64] = '\0';
        ret *this;
    }

    pub op+(other: String&) -> String {
        ret this->op+(other.Data());
    }

    pub op+(string: i8*) -> String {
        let mut result: String = data;
        result += string;
        ret result;
    }

    pub op+(character: i8) -> String {
        let mut result: String = data;
        result += character;
        ret result;
    }

    pub op*=(count: i64) -> String& {
        if count <= 0i64 {
            this->Release();
            this->Allocate(1i64);
            data[0i64] = '\0';
            ret *this;
        } else {
            let temp: String = data;
            let mut i: i64 = 0i64;

            while i < count - 1i64 {
                this->op+=(temp.Data());
                i += 1i64;
            } ret *this;
        }
    }

    pub op*(count: i64) -> String {
        let mut result: String = data;
        result *= count;
        ret result;
    }

    pub op==(other: String&) -> bool {
        ret this->op==(other.Data());
    }

    pub op==(string: i8*) -> bool {
        if size - 1i64 != strlen(string) { ret false; }
        if data == null || string == null { ret false; }
        ret strcmp(data, string) == 0i32;
    }

    pub op==(character: i8) -> bool {
        if size - 1i64 != 1i64 { ret false; }
        if data == null { ret false; }
        ret data[0i64] == character;
    }

    pub op!=(other: String&) -> bool {
        ret !this->op==(other.Data());
    }

    pub op!=(string: i8*) -> bool {
        ret !this->op==(string);
    }

    pub op!=(character: i8) -> bool {
        ret !this->op==(character);
    }

    pub op[](index: i64) -> i8& {
        ret data[index];
    }
};