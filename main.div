include "divio", "divwin", "divfile", "divllvm", "lexer.div", "parser.div", "compiler.div" : *;

class Timer {
    priv frequency: LARGE_INTEGER,
    priv counter: LARGE_INTEGER
} impl {
    Timer(this: Timer&) {
        QueryPerformanceFrequency(&this.frequency);
    }

    ~Timer(this: Timer&) {}

    pub Get(this: Timer&) -> f64 {
        QueryPerformanceCounter(&this.counter);
        ret (this.counter as f64) / (this.frequency as f64);
    }
};

func Execute(command: i8*, output: bool) -> DWORD {
    let mut startup_info: STARTUPINFOA;
    memset(&startup_info as void*, 0i32, sizeof(startup_info));
    startup_info.cb = sizeof(startup_info) as DWORD;
    let mut process_info: PROCESS_INFORMATION;

    if output != true {
        (startup_info.hStdOutput, startup_info.hStdError, startup_info.hStdInput) = (null, null, null);
        startup_info.dwFlags |= STARTF_USESTDHANDLES;
    }

    if CreateProcessA(null, command, null, null, 0i32, 0u32, null, null, &startup_info, &process_info) == 0i32 {
        printf("Failed to create process: %lu.\n", GetLastError());
        exit(1i32);
    }

    let exit_code: DWORD;
    WaitForSingleObject(process_info.hProcess, INFINITE);

    if GetExitCodeProcess(process_info.hProcess, &exit_code) == 0i32 {
        printf("Failed to get process exit code: %lu.\n", GetLastError());
    }

    CloseHandle(process_info.hProcess);
    CloseHandle(process_info.hThread);
    ret exit_code;
}

func ErrorHandler(reason: i8*) {
    printf("LLVM fatal error: %s\n", reason);
    exit(1i32);
}

func main(argc: i32, argv[]: i8*) -> i32 {
    let timer: Timer;
    let start: f64 = timer.Get();

    LLVMEnablePrettyStackTrace();
    LLVMInstallFatalErrorHandler(ErrorHandler);

    if argc < 2i32 {
        printf("Usage: .\\parser.exe <source_file>\n");
        ret 1i32;
    }

    let mut lexer: Lexer;
    let source: String = ReadFile(argv[1u64]);
    let tokens: Vector<Token> = lexer.Lex(source);
    let mut index: u64 = 0u64;

    while tokens.Size() > index {
        let token: Token = tokens.Data()[index];
        printf("Token: %s '%s' (Line: %d, Col: %d)\n", TokenTypeToString(token._type).Data(), token.value.Escape().Data(), token.lineno, token.column);
        index += 1u64;
    }

    let mut parser: Parser;
    let ast: RootNode* = parser.Parse(tokens);

    printf("\n");
    PrintAST(ast as ASTNode*, 0i32);

    let mut compiler: Compiler;
    let module: LLVMModuleRef = compiler.Compile(ast);

    printf("\n");
    LLVMDumpModule(module);
    let err: i8* = null;

    if LLVMVerifyModule(module, LLVMVerifierFailureAction::LLVMAbortProcessAction, &err) != 0i32 {
        printf("Module verification failed: %s.\n", err);
        LLVMDisposeMessage(err);
        ret 1i32;
    }

    LLVMDisposeMessage(err);
    LLVMInitializeNativeTarget();
    LLVMInitializeNativeAsmPrinter();
    // LLVMInitializeNativeAsmParser();
    // LLVMInitializeNativeDisassembler();

    if true {
        let engine: LLVMExecutionEngineRef;
        let mut options: LLVMMCJITCompilerOptions;
        LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));
        options.OptLevel = 0u32;
        let err: i8* = null;

        if LLVMCreateMCJITCompilerForModule(&engine, module, &options, sizeof(options), &err) != 0i32 {
            printf("Failed to create execution engine: %s.\n", err);
            LLVMDisposeMessage(err);
            ret 1i32;
        }

        LLVMDisposeMessage(err);
        printf("\nProgram compiled in %f seconds.\n", timer.Get() - start);
        let addr: u64 = LLVMGetFunctionAddress(engine, "main");

        if addr == 0u64 {
            printf("Couldn't get function address.\n");
            ret 1i32;
        }

        printf("Program finished with exit code: %d.\n", (addr as func() -> i32)());
        LLVMDisposeExecutionEngine(engine);
        compiler.Forget();
    } else {
        let target: LLVMTargetRef;
        let triple: i8* = LLVMGetDefaultTargetTriple();
        LLVMGetTargetFromTriple(triple, &target, null);
        let target_machine: LLVMTargetMachineRef = LLVMCreateTargetMachine(target, triple, "generic", "", LLVMCodeGenOptLevel::LLVMCodeGenLevelDefault, LLVMRelocMode::LLVMRelocDefault, LLVMCodeModel::LLVMCodeModelDefault);

        let err: i8* = null;
        LLVMSetTarget(module, triple);

        if LLVMTargetMachineEmitToFile(target_machine, module, "out.obj", LLVMCodeGenFileType::LLVMObjectFile, &err) != 0i32 {
            printf("Failed to emit object to file: %s.\n", err);
            LLVMDisposeMessage(err);
            ret 1i32;
        }

        LLVMDisposeMessage(err);
        printf("\nProgram compiled in %f seconds.\n", timer.Get() - start);
        LLVMDisposeTargetMachine(target_machine);

        let sdk_path: String = "C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.26100.0";
        let vs_path: String = "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.44.35207";
        let command: String = String("\"") + vs_path + "\\bin\\Hostx64\\x64\\link.exe\" /NOLOGO /DEBUG out.obj /OUT:out.exe \"/LIBPATH:" + vs_path + "\\lib\\x64\" \"/LIBPATH:" + sdk_path + "\\um\\x64\" \"/LIBPATH:" + sdk_path + "\\ucrt\\x64\" legacy_stdio_definitions.lib msvcrt.lib vcruntime.lib";        
        Execute(command.Data(), true);

        printf("Program finished with exit code: %d.\n", Execute("out.exe", true));
    } ret 0i32;
}