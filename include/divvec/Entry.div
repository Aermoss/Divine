include "divmem" : *;

class Vector<T> {
    priv data: T* = null,
    priv capacity: u64 = 0u64,
    priv size: u64 = 0u64
} impl {
    Vector(mut this: Vector<T>&) {}

    Vector(mut this: Vector<T>&, other: Vector<T>&) {
        if other.data == null { ret; }
        this.Allocate(other.capacity);

        while this.size < other.size {
            this.data[this.size] = other.data[this.size];
            this.size += 1u64;
        }
    }

    ~Vector(mut this: Vector<T>&) {
        this.Release();
    }

    pub Data(this: Vector<T>&) -> T* { ret this.data; }
    pub Size(this: Vector<T>&) -> u64 { ret this.size; }

    priv Allocate(mut this: Vector<T>&, capacity: u64) {
        (this.data, this.capacity) = (new T[capacity], capacity);
    }

    priv Release(mut this: Vector<T>&) {
        if this.data != null { del[] this.data; }
        (this.data, this.capacity, this.size) = (null, 0u64, 0u64);
    }

    pub PushBack(mut this: Vector<T>&, value: T) {
        if this.capacity < this.size + 1u64 {
            let temp: T* = this.data;
            this.Allocate(this.capacity != 0u64 ? this.capacity * 2u64 : 1u64);

            if temp != null {
                let mut i: u64 = 0u64;

                while i < this.size {
                    this.data[i] = temp[i];
                    i += 1u64;
                }

                del[] temp;
            }
        }

        this.data[this.size] = value;
        this.size += 1u64;
    }

    pub PopBack(mut this: Vector<T>&) -> T {
        this.size -= 1u64;
        ret this.data[this.size];
    }

    pub Pop(mut this: Vector<T>&, index: u64) -> T {
        let mut i: u64 = index + 1u64;

        while i < this.size {
            this.data[i - 1u64] = this.data[i];
            i += 1u64;
        }

        this.size -= 1u64;
        ret this.data[index];
    }

    pub Clear(mut this: Vector<T>&) {
        this.Release();
    }

    pub Remove(mut this: Vector<T>&, value: T) {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this.data[i] == value {
                this.Pop(i);
                i -= 1u64;
            } i += 1u64;
        }
    }

    pub Index(mut this: Vector<T>&, value: T) -> i64 {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this.data[i] == value {
                ret i as i64;
            } i += 1u64;
        } ret -1i64;
    }

    pub op=(mut this: Vector<T>&, other: Vector<T>&) -> Vector<T>& {
        this.Release();
        if other.data == null { ret this; }
        this.Allocate(other.capacity);

        while this.size < other.size {
            this.data[this.size] = other.data[this.size];
            this.size += 1u64;
        } ret this;
    }

    pub op[](this: Vector<T>&, index: u64) -> T& {
        ret this.data[index];
    }
};