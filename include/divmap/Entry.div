/*
 * Copyright 2025 Yusuf Ren√ßber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divvec", "divpair" : *;

class Map<K, V> {
    priv vector: Vector<Pair<K, V>>
} impl {
    Map(this: mut Map<K, V>&) {}

    Map(this: mut Map<K, V>&, other: Map<K, V>&) {
        this.vector = other.vector;
    }

    ~Map(this: mut Map<K, V>&) {}

    pub Data(this: Map<K, V>&) -> Pair<K, V>* { ret this.vector.Data(); }
    pub Size(this: Map<K, V>&) -> u64 { ret this.vector.Size(); }

    pub Keys(this: Map<K, V>&) -> Vector<K> {
        let mut keys: Vector<K>;
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            keys.PushBack(this.vector[i].left);
            i += 1u64;
        } ret keys;
    }

    pub Values(this: Map<K, V>&) -> Vector<V> {
        let mut values: Vector<V>;
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            values.PushBack(this.vector[i].right);
            i += 1u64;
        } ret values;
    }

    pub Has(this: Map<K, V>&, key: K) -> bool {
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            let pair: Pair<K, V>& = this.vector[i];
            if pair.left == key { ret true; }
            i += 1u64;
        } ret false;
    }

    pub op=(this: mut Map<K, V>&, other: Map<K, V>&) -> Map<K, V>& {
        this.vector = other.vector;
        ret this;
    }

    pub op[](this: mut Map<K, V>&, key: K) -> mut V& {
        let mut i: u64 = 0u64;

        while i < this.vector.Size() {
            let pair: Pair<K, V>& = this.vector[i];
            if pair.left == key { ret pair.right; }
            i += 1u64;
        }

        this.vector.PushBack(Pair<K, V>(key));
        ret this.vector[i].right;
    }

    pub op[](this: mut Map<K, V>&, index: u64) -> mut Pair<K, V>& {
        ret this.vector[index];
    }
};