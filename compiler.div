include "divio", "divstr", "divvec", "divpair", "divptr", "divllvm", "lexer.div", "parser.div" : *;

enum SymbolKind {
    Variable, Function, Parameter
};

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: LLVMValueRef,
    pub _type: LLVMTypeRef
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub name: String
} impl {
    Scope(mut this: Scope&, parent: Scope*, name: String, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(mut this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(mut this: Scope&, name: String) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(mut this: Scope&, name: String, kind: SymbolKind, value: LLVMValueRef, _type: LLVMTypeRef) {
        if this.Has(name) {
            this.Error("Symbol already exists.");
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value, _type);
            this.symbols.PushBack(symbol);
        }
    }

    pub Get(mut this: Scope&, name: String) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(mut this: Scope&, string: i8*) {
        printf("Scope error: %s\n", string);
        exit(1i32);
    }
};

class ScopeManager {
    pub scopes: Vector<Scope*>,
    pub current: Scope* = null
} impl {
    ScopeManager(mut this: ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(mut this: ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(mut this: ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(mut this: ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub Has(mut this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret true; }
            scope = scope->parent;
        } ret false;
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, value: LLVMValueRef, _type: LLVMTypeRef) {
        this.current->Set(name, kind, value, _type);
    }

    pub Get(mut this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret scope->Get(name); }
            scope = scope->parent;
        } ret null;
    }

    priv Error(mut this: ScopeManager&, string: i8*) {
        printf("Scope manager error: %s\n", string);
        exit(1i32);
    }
};

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right { ret true; }
    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMElementTypeOf(value: LLVMValueRef) -> LLVMTypeRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMAlloca {
        ret LLVMGetAllocatedType(value);
    } else {
        ret LLVMGetElementType(LLVMTypeOf(value));
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

class QualifiedType {
    pub mutable: bool, pub signed: bool, pub pointer: bool,
    pub _type: LLVMTypeRef, pub pointee: QualifiedType* = null
} impl {
    pub AsPointer(this: QualifiedType&) -> QualifiedType {
        ret { this.mutable, this.signed, true, LLVMPointerType(this._type, 0u32), &this } as QualifiedType;
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret this.mutable == other.mutable && this.signed == other.signed && this.pointer == other.pointer && LLVMIsTypeEqual(this._type, other._type) && this.pointee == other.pointee;
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }
};

class QualifiedValue {
    pub value: LLVMValueRef,
    pub _type: QualifiedType
};

class Compiler {
    priv scope_manager: ScopeManager,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv function: LLVMValueRef = null,
    priv number: u64
} impl {
    Compiler(mut this: Compiler&) {
        this.context = LLVMContextCreate();
    }

    ~Compiler(mut this: Compiler&) {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        if this.context != null {
            LLVMContextDispose(this.context);
            this.context = null;
        }
    }

    pub GetUniqueName(mut this: Compiler&) -> String {
        let buffer[256]: i8;
        sprintf(buffer, "%llu", this.number);
        this.number += 1u64;
        ret String(".") + buffer;
    }

    pub Compile(mut this: Compiler&, ast: RootNode*) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        LLVMSetSourceFileName(this.module, "hello.div", 9u64);
        LLVMSetTarget(this.module, LLVMGetDefaultTargetTriple());
        this.builder = LLVMCreateBuilderInContext(this.context);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        ret this.module;
    }

    priv CompileDeclaration(mut this: Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else {
            this.Error((String("Unknown declaration: ") + ASTNodeTypeToString(decl->node_type) + ".").Data());
        }
    }

    priv CompileExtern(mut this: Compiler&, extern_block: ExternBlockNode*) {
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }
    }

    priv CompileFunction(mut this: Compiler&, func_decl: FunctionDeclNode*) {
        this.number = 0u64;
        let func_name: i8* = func_decl->name.Data();
        let mut param_types: Vector<LLVMTypeRef>;
        let mut i: u64 = 0u64;

        while i < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[i];
            param_types.PushBack(this.CompileType(param->param_type));
            i += 1u64;
        }

        let return_type: LLVMTypeRef = this.CompileType(func_decl->return_type);
        let func_type: LLVMTypeRef = LLVMFunctionType(return_type, param_types.Data(), param_types.Size() as u32, func_decl->var_arg ? 1i32 : 0i32);
        this.function = LLVMAddFunction(this.module, func_name, func_type);
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, this.function, func_type);
        let mut j: u64 = 0u64;

        while j < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[j];
            let name: String = this.GetUniqueName().Data();
            LLVMSetValueName2(LLVMGetParam(this.function, j as u32), name.Data(), name.Size() - 1u64);
            j += 1u64;
        }

        if func_decl->body != null {
            this.scope_manager.PushScope(func_decl->name, false);
            let mut k: u64 = 0u64;

            while k < func_decl->parameters.Size() {
                let param: ParameterNode* = func_decl->parameters[k];
                this.scope_manager.Set(param->name, SymbolKind::Parameter, LLVMGetParam(this.function, k as u32), param_types[k]);
                k += 1u64;
            }

            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            LLVMPositionBuilderAtEnd(this.builder, entry);
            this.CompileBlock(func_decl->body);
            this.scope_manager.PopScope();
        } this.function = null;
    }

    priv CompileBlock(mut this: Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(mut this: Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            let ret_stmt: ReturnStmtNode* = stmt as ReturnStmtNode*;
            LLVMBuildRet(this.builder, this.CompileExpression(ret_stmt->value).left);
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement: ") + ASTNodeTypeToString(stmt->node_type) + ".").Data());
        }
    }

    priv CompileIf(mut this: Compiler&, if_stmt: IfStmtNode*) {
        if this.function == null {
            this.Error("If statement outside of function.");
            ret;
        }

        let mut current: IfStmtNode* = if_stmt;
        let mut end_block: LLVMBasicBlockRef = null;

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement: ") + ASTNodeTypeToString(else_stmt->node_type) + ".").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;
            let mut else_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } then_block = end_block;
            }

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } else_block = end_block;
            }

            let condition: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(current->condition);
            LLVMBuildCondBr(this.builder, condition.left, then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(mut this: Compiler&, while_stmt: WhileStmtNode*) {
        if this.function == null {
            this.Error("While statement outside of function.");
            ret;
        }

        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));

        LLVMBuildBr(this.builder, compare_block);
        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(while_stmt->condition);
        LLVMBuildCondBr(this.builder, condition.left, loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->body as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(mut this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(mut this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(mut this: Compiler&, variable: VariableDeclNode*) {
        let initializer: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(variable->initializer);
        let _type: LLVMTypeRef = this.CompileType(variable->var_type);

        if !LLVMIsTypeEqual(initializer.right, _type) {
            this.Error((String("Incompatible types: ") + LLVMTypeToString(initializer.right) + " and " + LLVMTypeToString(_type) + ".").Data());
            ret;
        }

        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
        let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, _type, this.GetUniqueName().Data());
        this.scope_manager.Set(variable->name, SymbolKind::Variable, pointer, LLVMTypeOf(pointer));
        LLVMBuildStore(this.builder, initializer.left, pointer);
        LLVMPositionBuilderAtEnd(this.builder, current);
    }

    priv CompileAssignment(mut this: Compiler&, assignment: AssignmentNode*) {
        let pointer: Pair<LLVMValueRef, LLVMTypeRef> = this.CompilePointerExpression(assignment->left);
        let value: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(assignment->right);

        if !LLVMIsTypeEqual(value.right, LLVMElementTypeOf(pointer.left)) {
            this.Error((String("Incompatible types: ") + LLVMTypeToString(value.right) + " and " + LLVMTypeToString(LLVMElementTypeOf(pointer.left)) + ".").Data());
            ret;
        }

        LLVMBuildStore(this.builder, value.left, pointer.left);
    }

    priv CompilePointerExpression(mut this: Compiler&, expr: ASTNode*) -> Pair<LLVMValueRef, LLVMTypeRef> {
        if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }

            let symbol: Symbol* = this.scope_manager.Get(identifier->name);
            ret Pair<LLVMValueRef, LLVMTypeRef>(symbol->value, symbol->_type);
        } else {
            this.Error((String("Unknown pointer expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
        }
    }

    priv CompileExpression(mut this: Compiler&, expr: ASTNode*) -> Pair<LLVMValueRef, LLVMTypeRef> {
        if expr->node_type == ASTNodeType::LITERAL {
            let literal: LiteralNode* = expr as LiteralNode*;

            if literal->literal_type == TokenType::INTEGER {
                let (mut state: bool, mut i: u64) = (false, 0u64);
                let (mut signed: bool, mut width: u64) = (true, 32u64);
                let (mut value: String, mut size: String);

                while i < literal->value.Size() {
                    if !state {
                        if literal->value[i] == 'u' {
                            (signed, state) = (false, true);
                        } else if literal->value[i] == 'i' {
                            (signed, state) = (true, true);
                        } else {
                            value += literal->value[i];
                        }
                    } else {
                        size += literal->value[i];
                    } i += 1u64;
                }

                let mut _type: LLVMTypeRef;
                width = size.ToInteger() as u64;

                if width == 128u64 {
                    _type = LLVMInt128TypeInContext(this.context);
                } else if width == 64u64 {
                    _type = LLVMInt64TypeInContext(this.context);
                } else if width == 32u64 {
                    _type = LLVMInt32TypeInContext(this.context);
                } else if width == 16u64 {
                    _type = LLVMInt16TypeInContext(this.context);
                } else if width == 8u64 {
                    _type = LLVMInt8TypeInContext(this.context);
                } else {
                    this.Error("Invalid integer size.");
                    ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
                }

                ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMConstInt(_type, value.ToInteger() as u64, 1i32), _type);
            } else if literal->literal_type == TokenType::FLOAT {
                let (mut state: bool, mut i: u64) = (false, 0u64);
                let (mut value: String, mut size: String);
                let mut width: u64 = 32u64;

                while i < literal->value.Size() {
                    if !state {
                        if literal->value[i] == 'f' {
                            state = true;
                        } else {
                            value += literal->value[i];
                        }
                    } else {
                        size += literal->value[i];
                    } i += 1u64;
                }

                let mut _type: LLVMTypeRef;
                width = size.ToInteger() as u64;

                if width == 64u64 {
                    _type = LLVMDoubleTypeInContext(this.context);
                } else if width == 32u64 {
                    _type = LLVMFloatTypeInContext(this.context);
                } else {
                    this.Error("Invalid float size.");
                    ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
                }

                ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMConstReal(_type, value.ToFloat()), _type);
            } else if literal->literal_type == TokenType::STRING {
                let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "fmt");
                ret Pair<LLVMValueRef, LLVMTypeRef>(value, LLVMTypeOf(value));
            } else {
                this.Error((String("Unknown literal type: ") + TokenTypeToString(literal->literal_type) + ".").Data());
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }
        } else if expr->node_type == ASTNodeType::CALL {
            let call: CallNode* = expr as CallNode*;
            let mut args: Vector<LLVMValueRef>;
            let mut i: u64 = 0u64;

            while i < call->arguments.Size() {
                let arg: ASTNode* = call->arguments[i];
                args.PushBack(this.CompileExpression(arg).left);
                i += 1u64;
            }

            let _func: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(call->function);
            let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.right, _func.left, args.Data(), args.Size() as u32, this.GetUniqueName().Data());
            ret Pair<LLVMValueRef, LLVMTypeRef>(value, LLVMGetReturnType(_func.right));
        } else if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }

            let symbol: Symbol* = this.scope_manager.Get(identifier->name);

            if symbol->kind == SymbolKind::Variable {
                let _type: LLVMTypeRef = LLVMElementTypeOf(symbol->value);
                ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildLoad2(this.builder, _type, symbol->value, this.GetUniqueName().Data()), _type);
            } else if symbol->kind == SymbolKind::Function || symbol->kind == SymbolKind::Parameter {
                ret Pair<LLVMValueRef, LLVMTypeRef>(symbol->value, symbol->_type);
            } else {
                this.Error("Unknown symbol kind.");
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            let binary_op: BinaryOpNode* = expr as BinaryOpNode*;
            let left: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(binary_op->left);
            let right: Pair<LLVMValueRef, LLVMTypeRef> = this.CompileExpression(binary_op->right);

            if !LLVMIsTypeEqual(left.right, right.right) {
                this.Error((String("Incompatible types: ") + LLVMTypeToString(left.right) + " and " + LLVMTypeToString(right.right) + ".").Data());
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }

            let kind: LLVMTypeKind = LLVMGetTypeKind(left.right);

            if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if binary_op->operator == TokenType::PLUS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildAdd(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MINUS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildSub(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MUL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildMul(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::DIV {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildSDiv(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MOD {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildSRem(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::NOT_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::GREATER {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::GREATER_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::LESS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::LESS_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::AND || binary_op->operator == TokenType::BITWISE_AND {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildAnd(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::OR || binary_op->operator == TokenType::BITWISE_OR {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildOr(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::BITWISE_XOR {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildXor(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::LSHIFT {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildShl(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::RSHIFT {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildAShr(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else {
                    this.Error((String("Invalid operator for integers: ") + TokenTypeToString(binary_op->operator) + ".").Data());
                    ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
                }
            } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if binary_op->operator == TokenType::PLUS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFAdd(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MINUS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFSub(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MUL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFMul(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::DIV {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFDiv(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::MOD {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFRem(this.builder, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::NOT_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::GREATER {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::GREATER_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::LESS {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else if binary_op->operator == TokenType::LESS_EQUAL {
                    ret Pair<LLVMValueRef, LLVMTypeRef>(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.left, right.left, this.GetUniqueName().Data()), left.right);
                } else {
                    this.Error((String("Invalid operator for floats: ") + TokenTypeToString(binary_op->operator) + ".").Data());
                    ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
                }
            } else {
                this.Error("Invalid type.");
                ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
            }
        } else {
            this.Error((String("Unknown expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret Pair<LLVMValueRef, LLVMTypeRef>(null, null);
        }
    }

    priv CompileType(mut this: Compiler&, type_node: ASTNode*) -> LLVMTypeRef {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->type_name == "i8" || primitive_type->type_name == "u8" {
                ret LLVMInt8TypeInContext(this.context);
            } else if primitive_type->type_name == "i16" || primitive_type->type_name == "u16" {
                ret LLVMInt16TypeInContext(this.context);
            } else if primitive_type->type_name == "i32" || primitive_type->type_name == "u32" || primitive_type->type_name == "char" {
                ret LLVMInt32TypeInContext(this.context);
            } else if primitive_type->type_name == "i64" || primitive_type->type_name == "u64" {
                ret LLVMInt64TypeInContext(this.context);
            } else if primitive_type->type_name == "i128" || primitive_type->type_name == "u128" {
                ret LLVMInt128TypeInContext(this.context);
            } else if primitive_type->type_name == "f32" {
                ret LLVMFloatTypeInContext(this.context);
            } else if primitive_type->type_name == "f64" {
                ret LLVMDoubleTypeInContext(this.context);
            } else if primitive_type->type_name == "void" {
                ret LLVMVoidTypeInContext(this.context);
            } else {
                this.Error("Unknown primitive type.");
                ret null;
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            let result: LLVMTypeRef = LLVMPointerType(this.CompileType(pointer_type->base_type), 0u32);

            if result == null {
                this.Error("Failed to create pointer type.");
            }

            ret result;
        } else {
            this.Error("Unknown type.");
            ret null;
        }
    }

    priv Error(mut this: Compiler&, string: i8*) {
        printf("Compiler error: %s\n", string);
        exit(1i32);
    }
};