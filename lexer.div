/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divio", "divstr", "divvec", "divmem", "divstd" : *;

enum TokenType {
    THREE_DOT, FLOAT, INTEGER, STRING, CHAR, NAME,

    IF, ELSE, FOR, WHILE, FUNC, CLASS, RETURN, BREAK, CONTINUE, CONST, OPERATOR, PUBLIC, PRIVATE,
    INCLUDE, USE, MOD, TYPE, LET, MUT, TRUE, FALSE, NULL, IMPL, NEW, DELETE, EXTERN, ENUM, AS,

    PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, AND_ASSIGN, OR_ASSIGN, XOR_ASSIGN,

    QUESTION_MARK, LSHIFT, RSHIFT, AND, BITWISE_AND, OR, BITWISE_OR, BITWISE_XOR, EQUAL, NOT_EQUAL, ARROW, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS, ASSIGN,
    LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN, PLUS, MINUS, COMMA, MUL, DIV, BACKSLASH, MOD, COLON, DOUBLE_COLON, SEMICOLON, NOT, TILDE, DOT,

    EOF, ERROR
};

func TokenTypeToString(_type: TokenType) -> String {
    if _type == TokenType::THREE_DOT { ret { "THREE_DOT" } as String; }
    else if _type == TokenType::FLOAT { ret { "FLOAT" } as String; }
    else if _type == TokenType::INTEGER { ret { "INTEGER" } as String; }
    else if _type == TokenType::STRING { ret { "STRING" } as String; }
    else if _type == TokenType::CHAR { ret { "CHAR" } as String; }
    else if _type == TokenType::NAME { ret { "NAME" } as String; }
    else if _type == TokenType::IF { ret { "IF" } as String; }
    else if _type == TokenType::ELSE { ret { "ELSE" } as String; }
    else if _type == TokenType::FOR { ret { "FOR" } as String; }
    else if _type == TokenType::WHILE { ret { "WHILE" } as String; }
    else if _type == TokenType::FUNC { ret { "FUNC" } as String; }
    else if _type == TokenType::CLASS { ret { "CLASS" } as String; }
    else if _type == TokenType::RETURN { ret { "RETURN" } as String; }
    else if _type == TokenType::BREAK { ret { "BREAK" } as String; }
    else if _type == TokenType::CONTINUE { ret { "CONTINUE" } as String; }
    else if _type == TokenType::CONST { ret { "CONST" } as String; }
    else if _type == TokenType::OPERATOR { ret { "OPERATOR" } as String; }
    else if _type == TokenType::PUBLIC { ret { "PUBLIC" } as String; }
    else if _type == TokenType::PRIVATE { ret { "PRIVATE" } as String; }
    else if _type == TokenType::INCLUDE { ret { "INCLUDE" } as String; }
    else if _type == TokenType::USE { ret { "USE" } as String; }
    else if _type == TokenType::MOD { ret { "MOD" } as String; }
    else if _type == TokenType::TYPE { ret { "TYPE" } as String; }
    else if _type == TokenType::LET { ret { "LET" } as String; }
    else if _type == TokenType::MUT { ret { "MUT" } as String; }
    else if _type == TokenType::TRUE { ret { "TRUE" } as String; }
    else if _type == TokenType::FALSE { ret { "FALSE" } as String; }
    else if _type == TokenType::NULL { ret { "NULL" } as String; }
    else if _type == TokenType::IMPL { ret { "IMPL" } as String; }
    else if _type == TokenType::NEW { ret { "NEW" } as String; }
    else if _type == TokenType::DELETE { ret { "DELETE" } as String; }
    else if _type == TokenType::EXTERN { ret { "EXTERN" } as String; }
    else if _type == TokenType::ENUM { ret { "ENUM" } as String; }
    else if _type == TokenType::AS { ret { "AS" } as String; }
    else if _type == TokenType::PLUS_ASSIGN { ret { "PLUS_ASSIGN" } as String; }
    else if _type == TokenType::MINUS_ASSIGN { ret { "MINUS_ASSIGN" } as String; }
    else if _type == TokenType::MUL_ASSIGN { ret { "MUL_ASSIGN" } as String; }
    else if _type == TokenType::DIV_ASSIGN { ret { "DIV_ASSIGN" } as String; }
    else if _type == TokenType::MOD_ASSIGN { ret { "MOD_ASSIGN" } as String; }
    else if _type == TokenType::LSHIFT_ASSIGN { ret { "LSHIFT_ASSIGN" } as String; }
    else if _type == TokenType::RSHIFT_ASSIGN { ret { "RSHIFT_ASSIGN" } as String; }
    else if _type == TokenType::AND_ASSIGN { ret { "AND_ASSIGN" } as String; }
    else if _type == TokenType::OR_ASSIGN { ret { "OR_ASSIGN" } as String; }
    else if _type == TokenType::XOR_ASSIGN { ret { "XOR_ASSIGN" } as String; }
    else if _type == TokenType::QUESTION_MARK { ret { "QUESTION_MARK" } as String; }
    else if _type == TokenType::LSHIFT { ret { "LSHIFT" } as String; }
    else if _type == TokenType::RSHIFT { ret { "RSHIFT" } as String; }
    else if _type == TokenType::AND { ret { "AND" } as String; }
    else if _type == TokenType::BITWISE_AND { ret { "BITWISE_AND" } as String; }
    else if _type == TokenType::OR { ret { "OR" } as String; }
    else if _type == TokenType::BITWISE_OR { ret { "BITWISE_OR" } as String; }
    else if _type == TokenType::BITWISE_XOR { ret { "BITWISE_XOR" } as String; }
    else if _type == TokenType::EQUAL { ret { "EQUAL" } as String; }
    else if _type == TokenType::NOT_EQUAL { ret { "NOT_EQUAL" } as String; }
    else if _type == TokenType::ARROW { ret { "ARROW" } as String; }
    else if _type == TokenType::GREATER_EQUAL { ret { "GREATER_EQUAL" } as String; }
    else if _type == TokenType::LESS_EQUAL { ret { "LESS_EQUAL" } as String; }
    else if _type == TokenType::GREATER { ret { "GREATER" } as String; }
    else if _type == TokenType::LESS { ret { "LESS" } as String; }
    else if _type == TokenType::ASSIGN { ret { "ASSIGN" } as String; }
    else if _type == TokenType::LBRACKET { ret { "LBRACKET" } as String; }
    else if _type == TokenType::RBRACKET { ret { "RBRACKET" } as String; }
    else if _type == TokenType::LBRACE { ret { "LBRACE" } as String; }
    else if _type == TokenType::RBRACE { ret { "RBRACE" } as String; }
    else if _type == TokenType::LPAREN { ret { "LPAREN" } as String; }
    else if _type == TokenType::RPAREN { ret { "RPAREN" } as String; }
    else if _type == TokenType::PLUS { ret { "PLUS" } as String; }
    else if _type == TokenType::MINUS { ret { "MINUS" } as String; }
    else if _type == TokenType::COMMA { ret { "COMMA" } as String; }
    else if _type == TokenType::MUL { ret { "MUL" } as String; }
    else if _type == TokenType::DIV { ret { "DIV" } as String; }
    else if _type == TokenType::BACKSLASH { ret { "BACKSLASH" } as String; }
    else if _type == TokenType::MOD { ret { "MOD" } as String; }
    else if _type == TokenType::COLON { ret { "COLON" } as String; }
    else if _type == TokenType::DOUBLE_COLON { ret { "DOUBLE_COLON" } as String; }
    else if _type == TokenType::SEMICOLON { ret { "SEMICOLON" } as String; }
    else if _type == TokenType::NOT { ret { "NOT" } as String; }
    else if _type == TokenType::TILDE { ret { "TILDE" } as String; }
    else if _type == TokenType::DOT { ret { "DOT" } as String; }
    else if _type == TokenType::EOF { ret { "EOF" } as String; }
    else if _type == TokenType::ERROR { ret { "ERROR" } as String; }
    else { ret { "UNKNOWN" } as String; }
}

func AssignmentOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::PLUS_ASSIGN { ret { "+=" } as String; }
    else if operator == TokenType::MINUS_ASSIGN { ret { "-=" } as String; }
    else if operator == TokenType::MUL_ASSIGN { ret { "*=" } as String; }
    else if operator == TokenType::DIV_ASSIGN { ret { "/=" } as String; }
    else if operator == TokenType::MOD_ASSIGN { ret { "%=" } as String; }
    else if operator == TokenType::LSHIFT_ASSIGN { ret { "<<=" } as String; }
    else if operator == TokenType::RSHIFT_ASSIGN { ret { ">>=" } as String; }
    else if operator == TokenType::AND_ASSIGN { ret { "&=" } as String; }
    else if operator == TokenType::OR_ASSIGN { ret { "|=" } as String; }
    else if operator == TokenType::XOR_ASSIGN { ret { "^=" } as String; }
    else if operator == TokenType::ASSIGN { ret { "=" } as String; }
    else { ret { "unknown" } as String; }
}

func BinaryOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::PLUS { ret { "+" } as String; }
    else if operator == TokenType::MINUS { ret { "-" } as String; }
    else if operator == TokenType::MUL { ret { "*" } as String; }
    else if operator == TokenType::DIV { ret { "/" } as String; }
    else if operator == TokenType::MOD { ret { "%" } as String; }
    else if operator == TokenType::LSHIFT { ret { "<<" } as String; }
    else if operator == TokenType::RSHIFT { ret { ">>" } as String; }
    else if operator == TokenType::AND { ret { "&&" } as String; }
    else if operator == TokenType::BITWISE_AND { ret { "&" } as String; }
    else if operator == TokenType::OR { ret { "||" } as String; }
    else if operator == TokenType::BITWISE_OR { ret { "|" } as String; }
    else if operator == TokenType::BITWISE_XOR { ret { "^" } as String; }
    else if operator == TokenType::EQUAL { ret { "==" } as String; }
    else if operator == TokenType::NOT_EQUAL { ret { "!=" } as String; }
    else if operator == TokenType::GREATER_EQUAL { ret { ">=" } as String; }
    else if operator == TokenType::LESS_EQUAL { ret { "<=" } as String; }
    else if operator == TokenType::GREATER { ret { ">" } as String; }
    else if operator == TokenType::LESS { ret { "<" } as String; }
    else { ret { "unknown" } as String; }
}

func UnaryOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::NOT { ret { "!" } as String; }
    else if operator == TokenType::MINUS { ret { "-" } as String; }
    else if operator == TokenType::BITWISE_AND { ret { "&" } as String; }
    else if operator == TokenType::MUL { ret { "*" } as String; }
    else { ret { "unknown" } as String; }
}

class Token {
    pub _type: TokenType,
    pub value: String,
    pub lineno: u64,
    pub column: u64
};

class Lexer {
    priv text: mut String,
    priv pos: u64 = 0u64,
    priv lineno: u64 = 1u64,
    priv column: u64 = 1u64,
    priv length: u64 = 0u64
} impl {
    Lexer(this: Lexer&) {}
    ~Lexer(this: Lexer&) {}

    pub IsDigit(this: Lexer&, c: i8) -> bool {
        ret c >= '0' && c <= '9';
    }

    pub IsHexDigit(this: Lexer&, c: i8) -> bool {
        ret (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    }

    pub IsBinDigit(this: Lexer&, c: i8) -> bool {
        ret c == '0' || c == '1';
    }

    pub IsOctDigit(this: Lexer&, c: i8) -> bool {
        ret c >= '0' && c <= '7';
    }

    pub IsAlpha(this: Lexer&, c: i8) -> bool {
        ret (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
    }

    pub IsAlphaNum(this: Lexer&, c: i8) -> bool {
        ret this.IsAlpha(c) || this.IsDigit(c);
    }

    pub CurrentChar(this: Lexer&) -> i8 {
        if this.pos >= this.length { ret '\0'; }
        ret this.text.Data()[this.pos];
    }

    pub PeekChar(this: Lexer&, offset: u64) -> i8 {
        let peek_pos: u64 = this.pos + offset;
        if peek_pos >= this.length { ret '\0'; }
        ret this.text.Data()[peek_pos];
    }

    pub Advance(this: mut Lexer&) {
        if this.pos < this.length {
            if this.CurrentChar() == '\n' {
                this.lineno += 1u64;
                this.column = 1u64;
            } else {
                this.column += 1u64;
            } this.pos += 1u64;
        }
    }

    pub SkipWhitespace(this: mut Lexer&) {
        while this.CurrentChar() == ' ' || this.CurrentChar() == '\t' || this.CurrentChar() == '\r' {
            this.Advance();
        }
    }

    pub SkipComment(this: mut Lexer&) -> bool {
        if this.CurrentChar() == '/' {
            if this.PeekChar(1u64) == '/' {
                while this.CurrentChar() != '\n' && this.CurrentChar() != '\0' {
                    this.Advance();
                } ret true;
            } else if this.PeekChar(1u64) == '*' {
                this.Advance();
                this.Advance();

                while this.CurrentChar() != '\0' {
                    if this.CurrentChar() == '*' && this.PeekChar(1u64) == '/' {
                        this.Advance();
                        this.Advance();
                        break;
                    }

                    this.Advance();
                } ret true;
            }
        }

        ret false;
    }

    pub ReadString(this: mut Lexer&) -> Token {
        let start_pos: u64 = this.pos;
        let start_col: u64 = this.column;
        let quote_char: i8 = this.CurrentChar();
        let value: mut String;
        this.Advance();

        while this.CurrentChar() != quote_char && this.CurrentChar() != '\0' {
            if this.CurrentChar() == '\\' {
                this.Advance();

                if this.CurrentChar() != '\0' {
                    let escaped: i8 = this.CurrentChar();

                    if escaped == 'n' {
                        value += "\n";
                    } else if escaped == 't' {
                        value += "\t";
                    } else if escaped == 'r' {
                        value += "\r";
                    } else if escaped == 'a' {
                        value += "\a";
                    } else if escaped == 'b' {
                        value += "\b";
                    } else if escaped == 'f' {
                        value += "\f";
                    } else if escaped == 'v' {
                        value += "\v";
                    } else if escaped == '0' {
                        value += "\0";
                    } else if escaped == '\\' {
                        value += "\\";
                    } else if escaped == '\'' {
                        value += "'";
                    } else if escaped == '"' {
                        value += "\"";
                    } else {
                        value += escaped;
                    }

                    this.Advance();
                }
            } else {
                value += this.CurrentChar();
                this.Advance();
            }
        }

        if this.CurrentChar() == quote_char {
            this.Advance();
        }

        if quote_char == '"' {
            ret { TokenType::STRING, value, this.lineno, start_col } as Token;
        } else {
            ret { TokenType::CHAR, value, this.lineno, start_col } as Token;
        }
    }

    pub ReadNumber(this: mut Lexer&) -> Token {
        let mut is_float: bool = false;
        let start_col: u64 = this.column;
        let value: mut String;

        if this.CurrentChar() == '0' {
            value += this.CurrentChar();
            this.Advance();
            
            if this.CurrentChar() == 'x' || this.CurrentChar() == 'X' {
                value += this.CurrentChar();
                this.Advance();

                while this.IsHexDigit(this.CurrentChar()) {
                    value += this.CurrentChar();
                    this.Advance();
                }
            } else if this.CurrentChar() == 'b' || this.CurrentChar() == 'B' {
                value += this.CurrentChar();
                this.Advance();

                while this.IsBinDigit(this.CurrentChar()) {
                    value += this.CurrentChar();
                    this.Advance();
                }
            } else if this.CurrentChar() == 'o' || this.CurrentChar() == 'O' {
                value += this.CurrentChar();
                this.Advance();

                while this.IsOctDigit(this.CurrentChar()) {
                    value += this.CurrentChar();
                    this.Advance();
                }
            } else {
                while this.IsDigit(this.CurrentChar()) {
                    value += this.CurrentChar();
                    this.Advance();
                }
            }
        } else {
            while this.IsDigit(this.CurrentChar()) {
                value += this.CurrentChar();
                this.Advance();
            }
        }

        if this.CurrentChar() == '.' && this.IsDigit(this.PeekChar(1u64)) {
            is_float = true;
            value += this.CurrentChar();
            this.Advance();

            while this.IsDigit(this.CurrentChar()) {
                value += this.CurrentChar();
                this.Advance();
            }
        }

        if this.CurrentChar() == 'e' || this.CurrentChar() == 'E' {
            is_float = true;
            value += this.CurrentChar();
            this.Advance();

            if this.CurrentChar() == '+' || this.CurrentChar() == '-' {
                value += this.CurrentChar();
                this.Advance();
            }

            while this.IsDigit(this.CurrentChar()) {
                value += this.CurrentChar();
                this.Advance();
            }
        }

        if this.CurrentChar() == 'i' || this.CurrentChar() == 'u' {
            value += this.CurrentChar();
            this.Advance();

            while this.IsDigit(this.CurrentChar()) {
                value += this.CurrentChar();
                this.Advance();
            }
        } else if this.CurrentChar() == 'f' {
            is_float = true;
            value += this.CurrentChar();
            this.Advance();

            while this.IsDigit(this.CurrentChar()) {
                value += this.CurrentChar();
                this.Advance();
            }
        }

        if is_float {
            ret { TokenType::FLOAT, value, this.lineno, start_col } as Token;
        } else {
            ret { TokenType::INTEGER, value, this.lineno, start_col } as Token;
        }
    }

    pub ReadIdentifier(this: mut Lexer&) -> Token {
        let mut token_type: TokenType;
        let start_col: u64 = this.column;
        let value: mut String;

        while this.IsAlphaNum(this.CurrentChar()) {
            value += this.CurrentChar();
            this.Advance();
        }

        if value == "if" { token_type = TokenType::IF; }
        else if value == "else" { token_type = TokenType::ELSE; }
        else if value == "for" { token_type = TokenType::FOR; }
        else if value == "while" { token_type = TokenType::WHILE; }
        else if value == "func" { token_type = TokenType::FUNC; }
        else if value == "class" { token_type = TokenType::CLASS; }
        else if value == "ret" { token_type = TokenType::RETURN; }
        else if value == "break" { token_type = TokenType::BREAK; }
        else if value == "continue" { token_type = TokenType::CONTINUE; }
        else if value == "const" { token_type = TokenType::CONST; }
        else if value == "op" { token_type = TokenType::OPERATOR; }
        else if value == "pub" { token_type = TokenType::PUBLIC; }
        else if value == "priv" { token_type = TokenType::PRIVATE; }
        else if value == "include" { token_type = TokenType::INCLUDE; }
        else if value == "use" { token_type = TokenType::USE; }
        else if value == "mod" { token_type = TokenType::MOD; }
        else if value == "type" { token_type = TokenType::TYPE; }
        else if value == "let" { token_type = TokenType::LET; }
        else if value == "mut" { token_type = TokenType::MUT; }
        else if value == "true" { token_type = TokenType::TRUE; }
        else if value == "false" { token_type = TokenType::FALSE; }
        else if value == "null" { token_type = TokenType::NULL; }
        else if value == "impl" { token_type = TokenType::IMPL; }
        else if value == "new" { token_type = TokenType::NEW; }
        else if value == "del" { token_type = TokenType::DELETE; }
        else if value == "extern" { token_type = TokenType::EXTERN; }
        else if value == "enum" { token_type = TokenType::ENUM; }
        else if value == "as" { token_type = TokenType::AS; }
        else { token_type = TokenType::NAME; }

        ret { token_type, value, this.lineno, start_col } as Token;
    }

    pub ReadOperator(this: mut Lexer&) -> Token {
        let c: i8 = this.CurrentChar();
        let next: i8 = this.PeekChar(1u64);
        let start_col: u64 = this.column;
        let mut token_type: TokenType;
        let value: mut String;

        if c == '.' && next == '.' && this.PeekChar(2u64) == '.' {
            value = "...";
            token_type = TokenType::THREE_DOT;
            this.Advance(); this.Advance(); this.Advance();
        } else if c == '+' {
            if next == '=' {
                value = "+=";
                token_type = TokenType::PLUS_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "+";
                token_type = TokenType::PLUS;
                this.Advance();
            }
        } else if c == '-' {
            if next == '=' {
                value = "-=";
                token_type = TokenType::MINUS_ASSIGN;
                this.Advance(); this.Advance();
            } else if next == '>' {
                value = "->";
                token_type = TokenType::ARROW;
                this.Advance(); this.Advance();
            } else {
                value = "-";
                token_type = TokenType::MINUS;
                this.Advance();
            }
        } else if c == '*' {
            if next == '=' {
                value = "*=";
                token_type = TokenType::MUL_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "*";
                token_type = TokenType::MUL;
                this.Advance();
            }
        } else if c == '/' {
            if next == '=' {
                value = "/=";
                token_type = TokenType::DIV_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "/";
                token_type = TokenType::DIV;
                this.Advance();
            }
        } else if c == '%' {
            if next == '=' {
                value = "%=";
                token_type = TokenType::MOD_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "%";
                token_type = TokenType::MOD;
                this.Advance();
            }
        } else if c == '<' {
            if next == '<' && this.PeekChar(2u64) == '=' {
                value = "<<=";
                token_type = TokenType::LSHIFT_ASSIGN;
                this.Advance(); this.Advance(); this.Advance();
            } else if next == '=' {
                value = "<=";
                token_type = TokenType::LESS_EQUAL;
                this.Advance(); this.Advance();
            } else {
                value = "<";
                token_type = TokenType::LESS;
                this.Advance();
            }
        } else if c == '>' {
            if next == '>' && this.PeekChar(2u64) == '=' {
                value = ">>=";
                token_type = TokenType::RSHIFT_ASSIGN;
                this.Advance(); this.Advance(); this.Advance();
            } else if next == '=' {
                value = ">=";
                token_type = TokenType::GREATER_EQUAL;
                this.Advance(); this.Advance();
            } else {
                value = ">";
                token_type = TokenType::GREATER;
                this.Advance();
            }
        } else if c == '&' {
            if next == '&' {
                value = "&&";
                token_type = TokenType::AND;
                this.Advance(); this.Advance();
            } else if next == '=' {
                value = "&=";
                token_type = TokenType::AND_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "&";
                token_type = TokenType::BITWISE_AND;
                this.Advance();
            }
        } else if c == '|' {
            if next == '|' {
                value = "||";
                token_type = TokenType::OR;
                this.Advance(); this.Advance();
            } else if next == '=' {
                value = "|=";
                token_type = TokenType::OR_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "|";
                token_type = TokenType::BITWISE_OR;
                this.Advance();
            }
        } else if c == '^' {
            if next == '=' {
                value = "^=";
                token_type = TokenType::XOR_ASSIGN;
                this.Advance(); this.Advance();
            } else {
                value = "^";
                token_type = TokenType::BITWISE_XOR;
                this.Advance();
            }
        } else if c == '=' {
            if next == '=' {
                value = "==";
                token_type = TokenType::EQUAL;
                this.Advance(); this.Advance();
            } else {
                value = "=";
                token_type = TokenType::ASSIGN;
                this.Advance();
            }
        } else if c == '!' {
            if next == '=' {
                value = "!=";
                token_type = TokenType::NOT_EQUAL;
                this.Advance(); this.Advance();
            } else {
                value = "!";
                token_type = TokenType::NOT;
                this.Advance();
            }
        } else if c == '?' {
            value = "?";
            token_type = TokenType::QUESTION_MARK;
            this.Advance();
        } else if c == '~' {
            value = "~";
            token_type = TokenType::TILDE;
            this.Advance();
        } else if c == '.' {
            value = ".";
            token_type = TokenType::DOT;
            this.Advance();
        } else if c == ',' {
            value = ",";
            token_type = TokenType::COMMA;
            this.Advance();
        } else if c == ':' {
            if next == ':' {
                value = "::";
                token_type = TokenType::DOUBLE_COLON;
                this.Advance(); this.Advance();
            } else {
                value = ":";
                token_type = TokenType::COLON;
                this.Advance();
            }
        } else if c == ';' {
            value = ";";
            token_type = TokenType::SEMICOLON;
            this.Advance();
        } else if c == '(' {
            value = "(";
            token_type = TokenType::LPAREN;
            this.Advance();
        } else if c == ')' {
            value = ")";
            token_type = TokenType::RPAREN;
            this.Advance();
        } else if c == '[' {
            value = "[";
            token_type = TokenType::LBRACKET;
            this.Advance();
        } else if c == ']' {
            value = "]";
            token_type = TokenType::RBRACKET;
            this.Advance();
        } else if c == '{' {
            value = "{";
            token_type = TokenType::LBRACE;
            this.Advance();
        } else if c == '}' {
            value = "}";
            token_type = TokenType::RBRACE;
            this.Advance();
        } else if c == '\\' {
            value = "\\";
            token_type = TokenType::BACKSLASH;
            this.Advance();
        } else {
            value = c;
            token_type = TokenType::ERROR;
            this.Advance();
        }

        ret { token_type, value, this.lineno, start_col } as Token;
    }

    pub NextToken(this: mut Lexer&) -> Token {
        while this.CurrentChar() != '\0' {
            this.SkipWhitespace();

            if this.CurrentChar() == '\0' {
                break;
            }

            if this.CurrentChar() == '\n' {
                this.Advance();
                continue;
            }

            if this.SkipComment() {
                continue;
            }

            if this.CurrentChar() == '"' || this.CurrentChar() == '\'' {
                ret this.ReadString();
            }

            if this.IsDigit(this.CurrentChar()) || (this.CurrentChar() == '.' && this.IsDigit(this.PeekChar(1u64))) {
                ret this.ReadNumber();
            }

            if this.IsAlpha(this.CurrentChar()) {
                ret this.ReadIdentifier();
            }

            ret this.ReadOperator();
        }

        ret { TokenType::EOF, "", this.lineno, this.column } as Token;
    }

    pub Lex(this: mut Lexer&, text: String) -> Vector<Token> {
        (this.text, this.length) = (text, text.Size());
        (this.pos, this.lineno, this.column) = (0u64, 1u64, 1u64);

        let tokens: mut Vector<Token>;
        let mut token: Token = this.NextToken();

        while token._type != TokenType::EOF && token._type != TokenType::ERROR {
            tokens.PushBack(token);
            token = this.NextToken();
        } ret tokens;
    }
};