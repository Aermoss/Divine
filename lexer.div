include "divio", "divstr", "divvec", "divmem", "divstd" : *;

enum TokenType {
    THREE_DOT, FLOAT, INTEGER, STRING, CHAR, NAME,
    
    IF, ELSE, FOR, WHILE, FUNC, CLASS, RETURN, BREAK, CONTINUE, CONST, OPERATOR, PUBLIC, PRIVATE,
    INCLUDE, USE, MOD, TYPE, LET, MUT, TRUE, FALSE, NULL, IMPL, NEW, DELETE, EXTERN, ENUM, AS,
    
    PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, AND_ASSIGN, OR_ASSIGN, XOR_ASSIGN,
    
    QUESTION_MARK, LSHIFT, RSHIFT, AND, BITWISE_AND, OR, BITWISE_OR, BITWISE_XOR, EQUAL, NOT_EQUAL, ARROW, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS, ASSIGN,
    LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN, PLUS, MINUS, COMMA, MUL, DIV, BACKSLASH, MOD_TOKEN, COLON, SEMICOLON, NOT, BITWISE_NOT, DOT,
    
    EOF, ERROR
};

func TokenTypeToString(t: TokenType) -> String {
    if t == TokenType::THREE_DOT { ret { "THREE_DOT" } as String; }
    else if t == TokenType::FLOAT { ret { "FLOAT" } as String; }
    else if t == TokenType::INTEGER { ret { "INTEGER" } as String; }
    else if t == TokenType::STRING { ret { "STRING" } as String; }
    else if t == TokenType::CHAR { ret { "CHAR" } as String; }
    else if t == TokenType::NAME { ret { "NAME" } as String; }
    else if t == TokenType::IF { ret { "IF" } as String; }
    else if t == TokenType::ELSE { ret { "ELSE" } as String; }
    else if t == TokenType::FOR { ret { "FOR" } as String; }
    else if t == TokenType::WHILE { ret { "WHILE" } as String; }
    else if t == TokenType::FUNC { ret { "FUNC" } as String; }
    else if t == TokenType::CLASS { ret { "CLASS" } as String; }
    else if t == TokenType::RETURN { ret { "RETURN" } as String; }
    else if t == TokenType::BREAK { ret { "BREAK" } as String; }
    else if t == TokenType::CONTINUE { ret { "CONTINUE" } as String; }
    else if t == TokenType::CONST { ret { "CONST" } as String; }
    else if t == TokenType::OPERATOR { ret { "OPERATOR" } as String; }
    else if t == TokenType::PUBLIC { ret { "PUBLIC" } as String; }
    else if t == TokenType::PRIVATE { ret { "PRIVATE" } as String; }
    else if t == TokenType::INCLUDE { ret { "INCLUDE" } as String; }
    else if t == TokenType::USE { ret { "USE" } as String; }
    else if t == TokenType::MOD { ret { "MOD" } as String; }
    else if t == TokenType::TYPE { ret { "TYPE" } as String; }
    else if t == TokenType::LET { ret { "LET" } as String; }
    else if t == TokenType::MUT { ret { "MUT" } as String; }
    else if t == TokenType::TRUE { ret { "TRUE" } as String; }
    else if t == TokenType::FALSE { ret { "FALSE" } as String; }
    else if t == TokenType::NULL { ret { "NULL" } as String; }
    else if t == TokenType::IMPL { ret { "IMPL" } as String; }
    else if t == TokenType::NEW { ret { "NEW" } as String; }
    else if t == TokenType::DELETE { ret { "DELETE" } as String; }
    else if t == TokenType::EXTERN { ret { "EXTERN" } as String; }
    else if t == TokenType::ENUM { ret { "ENUM" } as String; }
    else if t == TokenType::AS { ret { "AS" } as String; }
    else if t == TokenType::PLUS_ASSIGN { ret { "PLUS_ASSIGN" } as String; }
    else if t == TokenType::MINUS_ASSIGN { ret { "MINUS_ASSIGN" } as String; }
    else if t == TokenType::MUL_ASSIGN { ret { "MUL_ASSIGN" } as String; }
    else if t == TokenType::DIV_ASSIGN { ret { "DIV_ASSIGN" } as String; }
    else if t == TokenType::MOD_ASSIGN { ret { "MOD_ASSIGN" } as String; }
    else if t == TokenType::LSHIFT_ASSIGN { ret { "LSHIFT_ASSIGN" } as String; }
    else if t == TokenType::RSHIFT_ASSIGN { ret { "RSHIFT_ASSIGN" } as String; }
    else if t == TokenType::AND_ASSIGN { ret { "AND_ASSIGN" } as String; }
    else if t == TokenType::OR_ASSIGN { ret { "OR_ASSIGN" } as String; }
    else if t == TokenType::XOR_ASSIGN { ret { "XOR_ASSIGN" } as String; }
    else if t == TokenType::QUESTION_MARK { ret { "QUESTION_MARK" } as String; }
    else if t == TokenType::LSHIFT { ret { "LSHIFT" } as String; }
    else if t == TokenType::RSHIFT { ret { "RSHIFT" } as String; }
    else if t == TokenType::AND { ret { "AND" } as String; }
    else if t == TokenType::BITWISE_AND { ret { "BITWISE_AND" } as String; }
    else if t == TokenType::OR { ret { "OR" } as String; }
    else if t == TokenType::BITWISE_OR { ret { "BITWISE_OR" } as String; }
    else if t == TokenType::BITWISE_XOR { ret { "BITWISE_XOR" } as String; }
    else if t == TokenType::EQUAL { ret { "EQUAL" } as String; }
    else if t == TokenType::NOT_EQUAL { ret { "NOT_EQUAL" } as String; }
    else if t == TokenType::ARROW { ret { "ARROW" } as String; }
    else if t == TokenType::GREATER_EQUAL { ret { "GREATER_EQUAL" } as String; }
    else if t == TokenType::LESS_EQUAL { ret { "LESS_EQUAL" } as String; }
    else if t == TokenType::GREATER { ret { "GREATER" } as String; }
    else if t == TokenType::LESS { ret { "LESS" } as String; }
    else if t == TokenType::ASSIGN { ret { "ASSIGN" } as String; }
    else if t == TokenType::LBRACKET { ret { "LBRACKET" } as String; }
    else if t == TokenType::RBRACKET { ret { "RBRACKET" } as String; }
    else if t == TokenType::LBRACE { ret { "LBRACE" } as String; }
    else if t == TokenType::RBRACE { ret { "RBRACE" } as String; }
    else if t == TokenType::LPAREN { ret { "LPAREN" } as String; }
    else if t == TokenType::RPAREN { ret { "RPAREN" } as String; }
    else if t == TokenType::PLUS { ret { "PLUS" } as String; }
    else if t == TokenType::MINUS { ret { "MINUS" } as String; }
    else if t == TokenType::COMMA { ret { "COMMA" } as String; }
    else if t == TokenType::MUL { ret { "MUL" } as String; }
    else if t == TokenType::DIV { ret { "DIV" } as String; }
    else if t == TokenType::BACKSLASH { ret { "BACKSLASH" } as String; }
    else if t == TokenType::MOD_TOKEN { ret { "MOD_TOKEN" } as String; }
    else if t == TokenType::COLON { ret { "COLON" } as String; }
    else if t == TokenType::SEMICOLON { ret { "SEMICOLON" } as String; }
    else if t == TokenType::NOT { ret { "NOT" } as String; }
    else if t == TokenType::BITWISE_NOT { ret { "BITWISE_NOT" } as String; }
    else if t == TokenType::DOT { ret { "DOT" } as String; }
    else if t == TokenType::EOF { ret { "EOF" } as String; }
    else if t == TokenType::ERROR { ret { "ERROR" } as String; }
    else { ret { "UNKNOWN" } as String; }
}

class Token {
    pub _type: TokenType,
    pub value: String,
    pub lineno: i64,
    pub column: i64
};

class Lexer {
    priv text: String,
    priv pos: i64 = 0i64,
    priv lineno: i64 = 1i64,
    priv column: i64 = 1i64,
    priv length: i64 = 0i64
} impl {
    pub IsDigit(c: i8) -> bool {
        ret c >= '0' && c <= '9';
    }

    pub IsHexDigit(c: i8) -> bool {
        ret (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    }

    pub IsBinDigit(c: i8) -> bool {
        ret c == '0' || c == '1';
    }

    pub IsOctDigit(c: i8) -> bool {
        ret c >= '0' && c <= '7';
    }

    pub IsAlpha(c: i8) -> bool {
        ret (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
    }

    pub IsAlphaNum(c: i8) -> bool {
        ret IsAlpha(c) || IsDigit(c);
    }

    pub CurrentChar() -> i8 {
        if this->pos >= this->length { ret '\0'; }
        ret this->text.Data()[this->pos];
    }

    pub PeekChar(offset: i64) -> i8 {
        let peek_pos: i64 = this->pos + offset;
        if peek_pos >= this->length { ret '\0'; }
        ret this->text.Data()[peek_pos];
    }

    pub Advance() {
        if this->pos < this->length {
            if CurrentChar() == '\n' {
                this->lineno += 1i64;
                this->column = 1i64;
            } else {
                this->column += 1i64;
            }

            this->pos += 1i64;
        }
    }

    pub SkipWhitespace() {
        while CurrentChar() == ' ' || CurrentChar() == '\t' || CurrentChar() == '\r' {
            Advance();
        }
    }

    pub SkipComment() -> bool {
        if CurrentChar() == '/' {
            if PeekChar(1i64) == '/' {
                while CurrentChar() != '\n' && CurrentChar() != '\0' {
                    Advance();
                } ret true;
            } else if PeekChar(1i64) == '*' {
                Advance();
                Advance();

                while CurrentChar() != '\0' {
                    if CurrentChar() == '*' && PeekChar(1i64) == '/' {
                        Advance();
                        Advance();
                        break;
                    }

                    Advance();
                } ret true;
            }
        }

        ret false;
    }

    pub ReadString() -> Token {
        let start_pos: i64 = this->pos;
        let start_col: i64 = this->column;
        let quote_char: i8 = CurrentChar();
        let value: String;
        Advance();

        while CurrentChar() != quote_char && CurrentChar() != '\0' {
            if CurrentChar() == '\\' {
                Advance();

                if CurrentChar() != '\0' {
                    let escaped: i8 = CurrentChar();

                    if escaped == 'n' {
                        value += "\n";
                    } else if escaped == 't' {
                        value += "\t";
                    } else if escaped == 'r' {
                        value += "\r";
                    } else if escaped == '\\' {
                        value += "\\";
                    } else if escaped == '\'' {
                        value += "'";
                    } else if escaped == '"' {
                        value += "\"";
                    } else {
                        value += escaped;
                    }

                    Advance();
                }
            } else {
                value += CurrentChar();
                Advance();
            }
        }

        if CurrentChar() == quote_char {
            Advance();
        }

        if quote_char == '"' {
            ret { TokenType::STRING, value, this->lineno, start_col } as Token;
        } else {
            ret { TokenType::CHAR, value, this->lineno, start_col } as Token;
        }
    }

    pub ReadNumber() -> Token {
        let is_float: bool = false;
        let start_col: i64 = this->column;
        let value: String;

        if CurrentChar() == '0' {
            value += CurrentChar();
            Advance();
            
            if CurrentChar() == 'x' || CurrentChar() == 'X' {
                value += CurrentChar();
                Advance();

                while IsHexDigit(CurrentChar()) {
                    value += CurrentChar();
                    Advance();
                }
            } else if CurrentChar() == 'b' || CurrentChar() == 'B' {
                value += CurrentChar();
                Advance();

                while IsBinDigit(CurrentChar()) {
                    value += CurrentChar();
                    Advance();
                }
            } else if CurrentChar() == 'o' || CurrentChar() == 'O' {
                value += CurrentChar();
                Advance();

                while IsOctDigit(CurrentChar()) {
                    value += CurrentChar();
                    Advance();
                }
            } else {
                while IsDigit(CurrentChar()) {
                    value += CurrentChar();
                    Advance();
                }
            }
        } else {
            while IsDigit(CurrentChar()) {
                value += CurrentChar();
                Advance();
            }
        }

        if CurrentChar() == '.' && IsDigit(PeekChar(1i64)) {
            is_float = true;
            value += CurrentChar();
            Advance();

            while IsDigit(CurrentChar()) {
                value += CurrentChar();
                Advance();
            }
        }

        if CurrentChar() == 'e' || CurrentChar() == 'E' {
            is_float = true;
            value += CurrentChar();
            Advance();

            if CurrentChar() == '+' || CurrentChar() == '-' {
                value += CurrentChar();
                Advance();
            }

            while IsDigit(CurrentChar()) {
                value += CurrentChar();
                Advance();
            }
        }

        if CurrentChar() == 'i' || CurrentChar() == 'u' {
            value += CurrentChar();
            Advance();

            while IsDigit(CurrentChar()) {
                value += CurrentChar();
                Advance();
            }
        } else if CurrentChar() == 'f' {
            is_float = true;
            value += CurrentChar();
            Advance();

            while IsDigit(CurrentChar()) {
                value += CurrentChar();
                Advance();
            }
        }

        if is_float {
            ret { TokenType::FLOAT, value, this->lineno, start_col } as Token;
        } else {
            ret { TokenType::INTEGER, value, this->lineno, start_col } as Token;
        }
    }

    pub ReadIdentifier() -> Token {
        let token_type: TokenType;
        let start_col: i64 = this->column;
        let value: String;

        while IsAlphaNum(CurrentChar()) {
            value += CurrentChar();
            Advance();
        }

        if value == "if" { token_type = TokenType::IF; }
        else if value == "else" { token_type = TokenType::ELSE; }
        else if value == "for" { token_type = TokenType::FOR; }
        else if value == "while" { token_type = TokenType::WHILE; }
        else if value == "func" { token_type = TokenType::FUNC; }
        else if value == "class" { token_type = TokenType::CLASS; }
        else if value == "ret" { token_type = TokenType::RETURN; }
        else if value == "break" { token_type = TokenType::BREAK; }
        else if value == "continue" { token_type = TokenType::CONTINUE; }
        else if value == "const" { token_type = TokenType::CONST; }
        else if value == "op" { token_type = TokenType::OPERATOR; }
        else if value == "pub" { token_type = TokenType::PUBLIC; }
        else if value == "priv" { token_type = TokenType::PRIVATE; }
        else if value == "include" { token_type = TokenType::INCLUDE; }
        else if value == "use" { token_type = TokenType::USE; }
        else if value == "mod" { token_type = TokenType::MOD; }
        else if value == "type" { token_type = TokenType::TYPE; }
        else if value == "let" { token_type = TokenType::LET; }
        else if value == "mut" { token_type = TokenType::MUT; }
        else if value == "true" { token_type = TokenType::TRUE; }
        else if value == "false" { token_type = TokenType::FALSE; }
        else if value == "null" { token_type = TokenType::NULL; }
        else if value == "impl" { token_type = TokenType::IMPL; }
        else if value == "new" { token_type = TokenType::NEW; }
        else if value == "delete" { token_type = TokenType::DELETE; }
        else if value == "extern" { token_type = TokenType::EXTERN; }
        else if value == "enum" { token_type = TokenType::ENUM; }
        else if value == "as" { token_type = TokenType::AS; }
        else { token_type = TokenType::NAME; }

        ret { token_type, value, this->lineno, start_col } as Token;
    }

    pub ReadOperator() -> Token {
        let c: i8 = CurrentChar();
        let next: i8 = PeekChar(1i64);
        let start_col: i64 = this->column;
        let token_type: TokenType;
        let value: String = "";

        if c == '.' && next == '.' && PeekChar(2i64) == '.' {
            value = "...";
            token_type = TokenType::THREE_DOT;
            Advance(); Advance(); Advance();
        } else if c == '+' {
            if next == '=' {
                value = "+=";
                token_type = TokenType::PLUS_ASSIGN;
                Advance(); Advance();
            } else {
                value = "+";
                token_type = TokenType::PLUS;
                Advance();
            }
        } else if c == '-' {
            if next == '=' {
                value = "-=";
                token_type = TokenType::MINUS_ASSIGN;
                Advance(); Advance();
            } else if next == '>' {
                value = "->";
                token_type = TokenType::ARROW;
                Advance(); Advance();
            } else {
                value = "-";
                token_type = TokenType::MINUS;
                Advance();
            }
        } else if c == '*' {
            if next == '=' {
                value = "*=";
                token_type = TokenType::MUL_ASSIGN;
                Advance(); Advance();
            } else {
                value = "*";
                token_type = TokenType::MUL;
                Advance();
            }
        } else if c == '/' {
            if next == '=' {
                value = "/=";
                token_type = TokenType::DIV_ASSIGN;
                Advance(); Advance();
            } else {
                value = "/";
                token_type = TokenType::DIV;
                Advance();
            }
        } else if c == '%' {
            if next == '=' {
                value = "%=";
                token_type = TokenType::MOD_ASSIGN;
                Advance(); Advance();
            } else {
                value = "%";
                token_type = TokenType::MOD_TOKEN;
                Advance();
            }
        } else if c == '<' {
            if next == '<' {
                if PeekChar(2i64) == '=' {
                    value = "<<=";
                    token_type = TokenType::LSHIFT_ASSIGN;
                    Advance(); Advance(); Advance();
                } else {
                    value = "<<";
                    token_type = TokenType::LSHIFT;
                    Advance(); Advance();
                }
            } else if next == '=' {
                value = "<=";
                token_type = TokenType::LESS_EQUAL;
                Advance(); Advance();
            } else {
                value = "<";
                token_type = TokenType::LESS;
                Advance();
            }
        } else if c == '>' {
            if next == '>' {
                if PeekChar(2i64) == '=' {
                    value = ">>=";
                    token_type = TokenType::RSHIFT_ASSIGN;
                    Advance(); Advance(); Advance();
                } else {
                    value = ">>";
                    token_type = TokenType::RSHIFT;
                    Advance(); Advance();
                }
            } else if next == '=' {
                value = ">=";
                token_type = TokenType::GREATER_EQUAL;
                Advance(); Advance();
            } else {
                value = ">";
                token_type = TokenType::GREATER;
                Advance();
            }
        } else if c == '&' {
            if next == '&' {
                value = "&&";
                token_type = TokenType::AND;
                Advance(); Advance();
            } else if next == '=' {
                value = "&=";
                token_type = TokenType::AND_ASSIGN;
                Advance(); Advance();
            } else {
                value = "&";
                token_type = TokenType::BITWISE_AND;
                Advance();
            }
        } else if c == '|' {
            if next == '|' {
                value = "||";
                token_type = TokenType::OR;
                Advance(); Advance();
            } else if next == '=' {
                value = "|=";
                token_type = TokenType::OR_ASSIGN;
                Advance(); Advance();
            } else {
                value = "|";
                token_type = TokenType::BITWISE_OR;
                Advance();
            }
        } else if c == '^' {
            if next == '=' {
                value = "^=";
                token_type = TokenType::XOR_ASSIGN;
                Advance(); Advance();
            } else {
                value = "^";
                token_type = TokenType::BITWISE_XOR;
                Advance();
            }
        } else if c == '=' {
            if next == '=' {
                value = "==";
                token_type = TokenType::EQUAL;
                Advance(); Advance();
            } else {
                value = "=";
                token_type = TokenType::ASSIGN;
                Advance();
            }
        } else if c == '!' {
            if next == '=' {
                value = "!=";
                token_type = TokenType::NOT_EQUAL;
                Advance(); Advance();
            } else {
                value = "!";
                token_type = TokenType::NOT;
                Advance();
            }
        } else if c == '?' {
            value = "?";
            token_type = TokenType::QUESTION_MARK;
            Advance();
        } else if c == '~' {
            value = "~";
            token_type = TokenType::BITWISE_NOT;
            Advance();
        } else if c == '.' {
            value = ".";
            token_type = TokenType::DOT;
            Advance();
        } else if c == ',' {
            value = ",";
            token_type = TokenType::COMMA;
            Advance();
        } else if c == ':' {
            value = ":";
            token_type = TokenType::COLON;
            Advance();
        } else if c == ';' {
            value = ";";
            token_type = TokenType::SEMICOLON;
            Advance();
        } else if c == '(' {
            value = "(";
            token_type = TokenType::LPAREN;
            Advance();
        } else if c == ')' {
            value = ")";
            token_type = TokenType::RPAREN;
            Advance();
        } else if c == '[' {
            value = "[";
            token_type = TokenType::LBRACKET;
            Advance();
        } else if c == ']' {
            value = "]";
            token_type = TokenType::RBRACKET;
            Advance();
        } else if c == '{' {
            value = "{";
            token_type = TokenType::LBRACE;
            Advance();
        } else if c == '}' {
            value = "}";
            token_type = TokenType::RBRACE;
            Advance();
        } else if c == '\\' {
            value = "\\";
            token_type = TokenType::BACKSLASH;
            Advance();
        } else {
            value = c;
            token_type = TokenType::ERROR;
            Advance();
        }

        ret { token_type, value, this->lineno, start_col } as Token;
    }

    pub NextToken() -> Token {
        while CurrentChar() != '\0' {
            SkipWhitespace();

            if CurrentChar() == '\0' {
                break;
            }

            if CurrentChar() == '\n' {
                Advance();
                continue;
            }

            if SkipComment() {
                continue;
            }

            if CurrentChar() == '"' || CurrentChar() == '\'' {
                ret ReadString();
            }

            if IsDigit(CurrentChar()) || (CurrentChar() == '.' && IsDigit(PeekChar(1i64))) {
                ret ReadNumber();
            }

            if IsAlpha(CurrentChar()) {
                ret ReadIdentifier();
            }

            ret ReadOperator();
        }

        ret { TokenType::EOF, "", this->lineno, this->column } as Token;
    }

    pub Lex(text: String) -> Vector<Token> {
        (this->text, length) = (text, text.Size());
        (pos, lineno, column) = (0i64, 1i64, 1i64);

        let tokens: Vector<Token>;
        let token: Token = NextToken();

        while token._type != TokenType::EOF && token._type != TokenType::ERROR {
            tokens.PushBack(token);
            token = NextToken();
        }

        ret tokens;
    }
};

func ReadFile(path: i8*) -> String {
    let file: FILE* = fopen(path, "r");

    if file == null {
        printf("Failed to open file: '%s'.\n", path);
        exit(1i32);
    }

    let buffer[256i64]: i8;
    let content: String;

    while fgets(buffer, sizeof(buffer) as i32, file) != null {
        content += buffer;
    }

    fclose(file);
    ret content;
}

func main(argc: i32, argv[]: i8*) -> i32 {
    if argc < 2i32 {
        printf("Usage: .\\lexer.exe <source_file>\n");
        ret 1i32;
    }

    let lexer: Lexer;
    let source: String = ReadFile(argv[1i64]);
    let tokens: Vector<Token> = lexer.Lex(source);
    let index: i64 = 0i64;

    while tokens.Size() > index {
        let token: Token = tokens.Data()[index];
        printf("Token: Type=%s, Value='%s', Line=%d, Column=%d\n", TokenTypeToString(token._type).Data(), token.value.Data(), token.lineno, token.column);
        index += 1i64;
    }

    ret 0i32;
}