include "divio", "divstr", "divvec" : *;

enum InstructionType {
    Alloca, Store, Load, Ret
};

class Instruction {
    pub _type: InstructionType,
    pub arguments: Vector<String*>
} impl {
    pub Dump(this: Instruction&) -> String {
        let mut value: String = "";

        if this._type == InstructionType::Alloca {
            value += "%\"";
            value += this.arguments.Data()[0]->Data();
            value += "\" = alloca ";
            value += this.arguments.Data()[1]->Data();
        } else if this._type == InstructionType::Store {
            value += "store ";
            value += this.arguments.Data()[0]->Data();
            value += ", ";
            value += this.arguments.Data()[1]->Data();
        } else if this._type == InstructionType::Load {
            value += "%\"";
            value += this.arguments.Data()[0]->Data();
            value += "\" = load ";
            value += this.arguments.Data()[1]->Data();
        } else if this._type == InstructionType::Ret {
            value += "ret ";
            value += this.arguments.Data()[0]->Data();
        } else {

        }

        ret value;
    }
};

class Block {
    pub name: String,
    pub instructions: Vector<Instruction>
} impl {
    pub Dump(this: Block&) -> String {
        let mut value: String = "";
        value += this.name.Data();
        value += ":\n";

        let mut i: i64 = 0i64;

        while i < this.instructions.Size() {
            value += "  ";
            value += this.instructions.Data()[i].Dump().Data();
            value += "\n";
            i += 1i64;
        }

        ret value;
    }
};

class Argument {
    pub name: String,
    pub _type: String,
    pub variadic: bool = false
} impl {
    pub Dump(this: Argument&) -> String {
        let mut value: String = "";
        value += this._type.Data();
        value += " %\"";
        value += this.name.Data();
        value += "\"";
        ret value;
    }
};

class FunctionType {
    pub return: String,
    pub args: Vector<Argument>
};

class Function {
    pub name: String,
    pub blocks: Vector<Block>,
    pub _type: FunctionType
} impl {
    pub Dump(this: Function&) -> String {
        let mut value: String = "";
        value += "define ";
        value += this._type.return.Data();
        value += " @\"";
        value += this.name.Data();
        value += "\"(";

        let mut i: i64 = 0i64;

        while i < this._type.args.Size() {
            value += this._type.args.Data()[i].Dump().Data();
            i += 1i64;
        }

        value += ")";

        if this.blocks.Size() != 0i64 {
            value += " {\n";
            let mut i: i64 = 0i64;

            while i < this.blocks.Size() {
                value += this.blocks.Data()[i].Dump().Data();
                i += 1i64;
            }

            value += "}\n";
        }

        ret value;
    }
};

class Module {
    pub name: String = "main",
    pub functions: Vector<Function>,
    pub triple: String = "x86_64-pc-windows-msvc"
} impl {
    pub Dump(this: Module&) -> String {
        let mut value: String = "";
        value += "; ModuleID = \"";
        value += this.name.Data();
        value += "\"\n";
        value += "target triple = \"";
        value += this.triple.Data();
        value += "\"\n";
        value += "target dataLayout = \"\"\n\n";

        let mut i: i64 = 0i64;

        while i < this.functions.Size() {
            value += this.functions.Data()[i].Dump().Data();
            i += 1i64;
        }

        ret value;
    }
};

func MergeString(strings: Vector<String>) -> String {
    let mut string: String = "";
    let mut i: i64 = 0i64;

    while i < strings.Size() {
        string += strings.Data()[i].Data();
        i += 1i64;

        if i < strings.Size() {
            string += " ";
        }
    }

    ret string;
}

func main(argc: i32, argv[]: i8*) -> i32 {
    let mut instruction: Instruction;
    instruction._type = InstructionType::Alloca;
    instruction.arguments.PushBack(&({ ".2" } as String));
    instruction.arguments.PushBack(&({ "i32" } as String));

    let mut block: Block;
    block.name = "entry";
    block.instructions.PushBack(instruction);

    let argument: Argument = {
        { ".1" } as String,
        { "i32" } as String
    };

    let mut function: Function;
    function.name = "main";
    function._type.return = "i32";
    function._type.args.PushBack(argument);
    function.blocks.PushBack(block);

    let mut module: Module;
    module.functions.PushBack(function);
    printf("%s", module.Dump().Data());

    let debug: bool = true;
    let mut command: Vector<String>;
    command.PushBack({ "clang-cl" } as String);

    if debug {
        command.PushBack({ "/Zi" } as String);
        command.PushBack({ "/Od" } as String);
    }

    let fileName: String = "main";

    let mut input: String = fileName.Data();
    input += ".obj";

    let mut output: String = "/Fe:";
    output += fileName.Data();
    output += ".exe";

    command.PushBack(input);
    command.PushBack(output);

    printf("%s\n", MergeString(command).Data());
    ret 0;
}