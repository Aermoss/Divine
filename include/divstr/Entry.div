include "divmem" : *;

extern "C" {
    func strlen(str: i8*) -> i64;
    func strcmp(str1: i8*, str2: i8*) -> i32;
}

class String {
    priv data: i8* = null,
    priv size: i64 = 0i64
} impl {
    String(mut this: String&) {
        this.Allocate(1i64);
        this.data[0i64] = '\0';
    }

    String(mut this: String&, other: String&) {
        this.String(other.data);
    }

    String(mut this: String&, string: i8*) {
        if string == null { ret; }
        this.Allocate(strlen(string) + 1i64);
        memcpy(this.data, string, this.size);
    }

    ~String(mut this: String&) {
        this.Release();
    }

    pub Data(this: String&) -> i8* { ret this.data; }
    pub Size(this: String&) -> i64 { ret this.size; }

    priv Allocate(mut this: String&, newSize: i64) {
        (this.data, this.size) = (malloc(newSize), newSize);
    }

    priv Release(mut this: String&) {
        if this.data != null { free(this.data); }
        (this.data, this.size) = (null, 0i64);
    }

    pub op=(mut this: String&, other: String&) -> String& {
        ret this.op=(other.data);
    }

    pub op=(mut this: String&, string: i8*) -> String& {
        if string == null { ret *this; }
        if this.data != null { free(this.data); }
        this.Allocate(strlen(string) + 1i64);
        memcpy(this.data, string, this.size);
        ret *this;
    }

    pub op=(mut this: String&, character: i8) -> String& {
        if this.data != null { free(this.data); }
        this.Allocate(2i64);
        this.data[0i64] = character;
        this.data[1i64] = '\0';
        ret *this;
    }

    pub op+=(mut this: String&, other: String&) -> String& {
        ret this.op+=(other.data);
    }

    pub op+=(mut this: String&, string: i8*) -> String& {
        if string == null { ret *this; }
        let (oldData: i8*, oldSize: i64) = (this.data, strlen(this.data));
        this.Allocate(oldSize + strlen(string) + 1i64);

        if oldData != null {
            memcpy(this.data, oldData, oldSize);
            free(oldData);
        }

        memcpy(this.data + oldSize, string, strlen(string) + 1i64);
        ret *this;
    }

    pub op+=(mut this: String&, character: i8) -> String& {
        let (oldData: i8*, oldSize: i64) = (this.data, strlen(this.data));
        this.Allocate(oldSize + 2i64);

        if oldData != null {
            memcpy(this.data, oldData, oldSize);
            free(oldData);
        }

        this.data[oldSize] = character;
        this.data[oldSize + 1i64] = '\0';
        ret *this;
    }

    pub op+(this: String&, other: String&) -> String {
        ret this.op+(other.data);
    }

    pub op+(this: String&, string: i8*) -> String {
        let mut result: String = this.data;
        result += string;
        ret result;
    }

    pub op+(this: String&, character: i8) -> String {
        let mut result: String = this.data;
        result += character;
        ret result;
    }

    pub op*=(mut this: String&, count: i64) -> String& {
        if count <= 0i64 {
            this.Release();
            this.Allocate(1i64);
            this.data[0i64] = '\0';
            ret *this;
        } else {
            let temp: String = this.data;
            let mut i: i64 = 0i64;

            while i < count - 1i64 {
                this.op+=(temp.data);
                i += 1i64;
            } ret *this;
        }
    }

    pub op*(this: String&, count: i64) -> String {
        let mut result: String = this.data;
        result *= count;
        ret result;
    }

    pub op==(this: String&, other: String&) -> bool {
        ret this.op==(other.data);
    }

    pub op==(this: String&, string: i8*) -> bool {
        if this.size - 1i64 != strlen(string) { ret false; }
        if this.data == null || string == null { ret false; }
        ret strcmp(this.data, string) == 0i32;
    }

    pub op==(this: String&, character: i8) -> bool {
        if this.size - 1i64 != 1i64 { ret false; }
        if this.data == null { ret false; }
        ret this.data[0i64] == character;
    }

    pub op!=(this: String&, other: String&) -> bool {
        ret !this.op==(other.data);
    }

    pub op!=(this: String&, string: i8*) -> bool {
        ret !this.op==(string);
    }

    pub op!=(this: String&, character: i8) -> bool {
        ret !this.op==(character);
    }

    pub op[](this: String&, index: i64) -> i8& {
        ret this.data[index];
    }
};