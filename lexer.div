/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divio", "divstr", "divvec", "divmem", "divstd" : *;

enum TokenType {
    THREE_DOT, FLOAT, INTEGER, STRING, CHAR, NAME,

    IF, ELSE, FOR, WHILE, LOOP, FUNC, CLASS, RETURN, BREAK, CONTINUE, CONST, OPERATOR, PUBLIC, PRIVATE,
    INCLUDE, USE, MOD, TYPE, LET, MUT, TRUE, FALSE, NULL, IMPL, NEW, DELETE, EXTERN, ENUM, AS,

    PLUS_ASSIGN, MINUS_ASSIGN, MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, LSHIFT_ASSIGN, RSHIFT_ASSIGN, AND_ASSIGN, OR_ASSIGN, XOR_ASSIGN,

    QUESTION_MARK, LSHIFT, RSHIFT, AND, BITWISE_AND, OR, BITWISE_OR, BITWISE_XOR, EQUAL, NOT_EQUAL, ARROW, GREATER_EQUAL, LESS_EQUAL, GREATER, LESS, ASSIGN,
    LBRACKET, RBRACKET, LBRACE, RBRACE, LPAREN, RPAREN, PLUS, MINUS, COMMA, MUL, DIV, BACKSLASH, MOD, COLON, DOUBLE_COLON, SEMICOLON, NOT, TILDE, DOT,

    EOF
};

func TokenTypeToString(_type: TokenType) -> String {
    if _type == TokenType::THREE_DOT { ret { "THREE_DOT" } as String; }
    else if _type == TokenType::FLOAT { ret { "FLOAT" } as String; }
    else if _type == TokenType::INTEGER { ret { "INTEGER" } as String; }
    else if _type == TokenType::STRING { ret { "STRING" } as String; }
    else if _type == TokenType::CHAR { ret { "CHAR" } as String; }
    else if _type == TokenType::NAME { ret { "NAME" } as String; }
    else if _type == TokenType::IF { ret { "IF" } as String; }
    else if _type == TokenType::ELSE { ret { "ELSE" } as String; }
    else if _type == TokenType::FOR { ret { "FOR" } as String; }
    else if _type == TokenType::WHILE { ret { "WHILE" } as String; }
    else if _type == TokenType::LOOP { ret { "LOOP" } as String; }
    else if _type == TokenType::FUNC { ret { "FUNC" } as String; }
    else if _type == TokenType::CLASS { ret { "CLASS" } as String; }
    else if _type == TokenType::RETURN { ret { "RETURN" } as String; }
    else if _type == TokenType::BREAK { ret { "BREAK" } as String; }
    else if _type == TokenType::CONTINUE { ret { "CONTINUE" } as String; }
    else if _type == TokenType::CONST { ret { "CONST" } as String; }
    else if _type == TokenType::OPERATOR { ret { "OPERATOR" } as String; }
    else if _type == TokenType::PUBLIC { ret { "PUBLIC" } as String; }
    else if _type == TokenType::PRIVATE { ret { "PRIVATE" } as String; }
    else if _type == TokenType::INCLUDE { ret { "INCLUDE" } as String; }
    else if _type == TokenType::USE { ret { "USE" } as String; }
    else if _type == TokenType::MOD { ret { "MOD" } as String; }
    else if _type == TokenType::TYPE { ret { "TYPE" } as String; }
    else if _type == TokenType::LET { ret { "LET" } as String; }
    else if _type == TokenType::MUT { ret { "MUT" } as String; }
    else if _type == TokenType::TRUE { ret { "TRUE" } as String; }
    else if _type == TokenType::FALSE { ret { "FALSE" } as String; }
    else if _type == TokenType::NULL { ret { "NULL" } as String; }
    else if _type == TokenType::IMPL { ret { "IMPL" } as String; }
    else if _type == TokenType::NEW { ret { "NEW" } as String; }
    else if _type == TokenType::DELETE { ret { "DELETE" } as String; }
    else if _type == TokenType::EXTERN { ret { "EXTERN" } as String; }
    else if _type == TokenType::ENUM { ret { "ENUM" } as String; }
    else if _type == TokenType::AS { ret { "AS" } as String; }
    else if _type == TokenType::PLUS_ASSIGN { ret { "PLUS_ASSIGN" } as String; }
    else if _type == TokenType::MINUS_ASSIGN { ret { "MINUS_ASSIGN" } as String; }
    else if _type == TokenType::MUL_ASSIGN { ret { "MUL_ASSIGN" } as String; }
    else if _type == TokenType::DIV_ASSIGN { ret { "DIV_ASSIGN" } as String; }
    else if _type == TokenType::MOD_ASSIGN { ret { "MOD_ASSIGN" } as String; }
    else if _type == TokenType::LSHIFT_ASSIGN { ret { "LSHIFT_ASSIGN" } as String; }
    else if _type == TokenType::RSHIFT_ASSIGN { ret { "RSHIFT_ASSIGN" } as String; }
    else if _type == TokenType::AND_ASSIGN { ret { "AND_ASSIGN" } as String; }
    else if _type == TokenType::OR_ASSIGN { ret { "OR_ASSIGN" } as String; }
    else if _type == TokenType::XOR_ASSIGN { ret { "XOR_ASSIGN" } as String; }
    else if _type == TokenType::QUESTION_MARK { ret { "QUESTION_MARK" } as String; }
    else if _type == TokenType::LSHIFT { ret { "LSHIFT" } as String; }
    else if _type == TokenType::RSHIFT { ret { "RSHIFT" } as String; }
    else if _type == TokenType::AND { ret { "AND" } as String; }
    else if _type == TokenType::BITWISE_AND { ret { "BITWISE_AND" } as String; }
    else if _type == TokenType::OR { ret { "OR" } as String; }
    else if _type == TokenType::BITWISE_OR { ret { "BITWISE_OR" } as String; }
    else if _type == TokenType::BITWISE_XOR { ret { "BITWISE_XOR" } as String; }
    else if _type == TokenType::EQUAL { ret { "EQUAL" } as String; }
    else if _type == TokenType::NOT_EQUAL { ret { "NOT_EQUAL" } as String; }
    else if _type == TokenType::ARROW { ret { "ARROW" } as String; }
    else if _type == TokenType::GREATER_EQUAL { ret { "GREATER_EQUAL" } as String; }
    else if _type == TokenType::LESS_EQUAL { ret { "LESS_EQUAL" } as String; }
    else if _type == TokenType::GREATER { ret { "GREATER" } as String; }
    else if _type == TokenType::LESS { ret { "LESS" } as String; }
    else if _type == TokenType::ASSIGN { ret { "ASSIGN" } as String; }
    else if _type == TokenType::LBRACKET { ret { "LBRACKET" } as String; }
    else if _type == TokenType::RBRACKET { ret { "RBRACKET" } as String; }
    else if _type == TokenType::LBRACE { ret { "LBRACE" } as String; }
    else if _type == TokenType::RBRACE { ret { "RBRACE" } as String; }
    else if _type == TokenType::LPAREN { ret { "LPAREN" } as String; }
    else if _type == TokenType::RPAREN { ret { "RPAREN" } as String; }
    else if _type == TokenType::PLUS { ret { "PLUS" } as String; }
    else if _type == TokenType::MINUS { ret { "MINUS" } as String; }
    else if _type == TokenType::COMMA { ret { "COMMA" } as String; }
    else if _type == TokenType::MUL { ret { "MUL" } as String; }
    else if _type == TokenType::DIV { ret { "DIV" } as String; }
    else if _type == TokenType::BACKSLASH { ret { "BACKSLASH" } as String; }
    else if _type == TokenType::MOD { ret { "MOD" } as String; }
    else if _type == TokenType::COLON { ret { "COLON" } as String; }
    else if _type == TokenType::DOUBLE_COLON { ret { "DOUBLE_COLON" } as String; }
    else if _type == TokenType::SEMICOLON { ret { "SEMICOLON" } as String; }
    else if _type == TokenType::NOT { ret { "NOT" } as String; }
    else if _type == TokenType::TILDE { ret { "TILDE" } as String; }
    else if _type == TokenType::DOT { ret { "DOT" } as String; }
    else if _type == TokenType::EOF { ret { "EOF" } as String; }
    else { ret { "UNKNOWN" } as String; }
}

func AssignmentOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::PLUS_ASSIGN { ret { "+=" } as String; }
    else if operator == TokenType::MINUS_ASSIGN { ret { "-=" } as String; }
    else if operator == TokenType::MUL_ASSIGN { ret { "*=" } as String; }
    else if operator == TokenType::DIV_ASSIGN { ret { "/=" } as String; }
    else if operator == TokenType::MOD_ASSIGN { ret { "%=" } as String; }
    else if operator == TokenType::LSHIFT_ASSIGN { ret { "<<=" } as String; }
    else if operator == TokenType::RSHIFT_ASSIGN { ret { ">>=" } as String; }
    else if operator == TokenType::AND_ASSIGN { ret { "&=" } as String; }
    else if operator == TokenType::OR_ASSIGN { ret { "|=" } as String; }
    else if operator == TokenType::XOR_ASSIGN { ret { "^=" } as String; }
    else if operator == TokenType::ASSIGN { ret { "=" } as String; }
    else { ret { "unknown" } as String; }
}

func BinaryOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::PLUS { ret { "+" } as String; }
    else if operator == TokenType::MINUS { ret { "-" } as String; }
    else if operator == TokenType::MUL { ret { "*" } as String; }
    else if operator == TokenType::DIV { ret { "/" } as String; }
    else if operator == TokenType::MOD { ret { "%" } as String; }
    else if operator == TokenType::LSHIFT { ret { "<<" } as String; }
    else if operator == TokenType::RSHIFT { ret { ">>" } as String; }
    else if operator == TokenType::AND { ret { "&&" } as String; }
    else if operator == TokenType::BITWISE_AND { ret { "&" } as String; }
    else if operator == TokenType::OR { ret { "||" } as String; }
    else if operator == TokenType::BITWISE_OR { ret { "|" } as String; }
    else if operator == TokenType::BITWISE_XOR { ret { "^" } as String; }
    else if operator == TokenType::EQUAL { ret { "==" } as String; }
    else if operator == TokenType::NOT_EQUAL { ret { "!=" } as String; }
    else if operator == TokenType::GREATER_EQUAL { ret { ">=" } as String; }
    else if operator == TokenType::LESS_EQUAL { ret { "<=" } as String; }
    else if operator == TokenType::GREATER { ret { ">" } as String; }
    else if operator == TokenType::LESS { ret { "<" } as String; }
    else { ret { "unknown" } as String; }
}

func UnaryOperatorToString(operator: TokenType) -> String {
    if operator == TokenType::NOT { ret { "!" } as String; }
    else if operator == TokenType::MINUS { ret { "-" } as String; }
    else if operator == TokenType::BITWISE_AND { ret { "&" } as String; }
    else if operator == TokenType::MUL { ret { "*" } as String; }
    else { ret { "unknown" } as String; }
}

class Token {
    pub _type: TokenType, pub value: mut String,
    pub row: u64, pub column: u64
};

class Lexer {
    priv row: u64, priv column: u64,
    priv text: mut String, priv file: mut String,
    priv length: u64, priv index: u64
} impl {
    priv IsDigit(this: Lexer&, character: i8) -> bool {
        ret character >= '0' && character <= '9';
    }

    priv IsHexDigit(this: Lexer&, character: i8) -> bool {
        ret (character >= '0' && character <= '9') || (character >= 'a' && character <= 'f') || (character >= 'A' && character <= 'F');
    }

    priv IsBinDigit(this: Lexer&, character: i8) -> bool {
        ret character == '0' || character == '1';
    }

    priv IsOctDigit(this: Lexer&, character: i8) -> bool {
        ret character >= '0' && character <= '7';
    }

    priv IsAlpha(this: Lexer&, character: i8) -> bool {
        ret (character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') || character == '_';
    }

    priv IsAlphaNum(this: Lexer&, character: i8) -> bool {
        ret this.IsAlpha(character) || this.IsDigit(character);
    }

    priv CurrentChar(this: Lexer&) -> i8 {
        if this.index >= this.length { ret '\0'; }
        ret this.text.Data()[this.index];
    }

    priv PeekChar(this: Lexer&, offset: u64) -> i8 {
        let peek_index: u64 = this.index + offset;
        if peek_index >= this.length { ret '\0'; }
        ret this.text.Data()[peek_index];
    }

    priv Advance(this: mut Lexer&, count: u64) {
        let mut i: u64 = 0u64;

        while i < count {
            if this.index < this.length {
                if this.CurrentChar() == '\n' {
                    this.row += 1u64;
                    this.column = 1u64;
                } else {
                    this.column += 1u64;
                } this.index += 1u64;
            } i += 1u64;
        }
    }

    priv SkipWhitespace(this: mut Lexer&) {
        while this.CurrentChar() == ' ' || this.CurrentChar() == '\t' || this.CurrentChar() == '\r' {
            this.Advance(1u64);
        }
    }

    priv SkipComment(this: mut Lexer&) -> bool {
        if this.CurrentChar() == '/' {
            if this.PeekChar(1u64) == '/' {
                while this.CurrentChar() != '\n' && this.CurrentChar() != '\0' {
                    this.Advance(1u64);
                } ret true;
            } else if this.PeekChar(1u64) == '*' {
                this.Advance(2u64);

                while this.CurrentChar() != '\0' {
                    if this.CurrentChar() == '*' && this.PeekChar(1u64) == '/' {
                        this.Advance(2u64);
                        break;
                    } this.Advance(1u64);
                } ret true;
            }
        } ret false;
    }

    priv LexString(this: mut Lexer&) -> Token {
        let token: mut Token;
        (token.row, token.column) = (this.row, this.column);
        let quote_char: i8 = this.CurrentChar();
        token._type = quote_char != '"' ? TokenType::CHAR : TokenType::STRING;
        this.Advance(1u64);

        while this.CurrentChar() != quote_char && this.CurrentChar() != '\0' {
            if this.CurrentChar() == '\\' {
                this.Advance(1u64);

                if this.CurrentChar() != '\0' {
                    let escaped: i8 = this.CurrentChar();

                    if escaped == 'n' {
                        token.value += "\n";
                    } else if escaped == 't' {
                        token.value += "\t";
                    } else if escaped == 'r' {
                        token.value += "\r";
                    } else if escaped == 'a' {
                        token.value += "\a";
                    } else if escaped == 'b' {
                        token.value += "\b";
                    } else if escaped == 'f' {
                        token.value += "\f";
                    } else if escaped == 'v' {
                        token.value += "\v";
                    } else if escaped == '0' {
                        token.value += "\0";
                    } else if escaped == '\\' {
                        token.value += "\\";
                    } else if escaped == '\'' {
                        token.value += "'";
                    } else if escaped == '"' {
                        token.value += "\"";
                    } else {
                        token.value += escaped;
                    } this.Advance(1u64);
                }
            } else {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        }

        if this.CurrentChar() == quote_char {
            this.Advance(1u64);
        } ret token;
    }

    priv LexNumber(this: mut Lexer&) -> Token {
        let token: mut Token;
        (token.row, token.column) = (this.row, this.column);
        token._type = TokenType::INTEGER;

        if this.CurrentChar() == '0' {
            token.value += this.CurrentChar();
            this.Advance(1u64);

            if this.CurrentChar() == 'x' || this.CurrentChar() == 'X' {
                token.value += this.CurrentChar();
                this.Advance(1u64);

                while this.IsHexDigit(this.CurrentChar()) {
                    token.value += this.CurrentChar();
                    this.Advance(1u64);
                }
            } else if this.CurrentChar() == 'b' || this.CurrentChar() == 'B' {
                token.value += this.CurrentChar();
                this.Advance(1u64);

                while this.IsBinDigit(this.CurrentChar()) {
                    token.value += this.CurrentChar();
                    this.Advance(1u64);
                }
            } else if this.CurrentChar() == 'o' || this.CurrentChar() == 'O' {
                token.value += this.CurrentChar();
                this.Advance(1u64);

                while this.IsOctDigit(this.CurrentChar()) {
                    token.value += this.CurrentChar();
                    this.Advance(1u64);
                }
            } else {
                while this.IsDigit(this.CurrentChar()) {
                    token.value += this.CurrentChar();
                    this.Advance(1u64);
                }
            }
        } else {
            while this.IsDigit(this.CurrentChar()) {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        }

        if this.CurrentChar() == '.' && this.IsDigit(this.PeekChar(1u64)) {
            token._type = TokenType::FLOAT;
            token.value += this.CurrentChar();
            this.Advance(1u64);

            while this.IsDigit(this.CurrentChar()) {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        }

        if this.CurrentChar() == 'e' || this.CurrentChar() == 'E' {
            token._type = TokenType::FLOAT;
            token.value += this.CurrentChar();
            this.Advance(1u64);

            if this.CurrentChar() == '+' || this.CurrentChar() == '-' {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }

            while this.IsDigit(this.CurrentChar()) {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        }

        if this.CurrentChar() == 'i' || this.CurrentChar() == 'u' {
            token.value += this.CurrentChar();
            this.Advance(1u64);

            while this.IsDigit(this.CurrentChar()) {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        } else if this.CurrentChar() == 'f' {
            token._type = TokenType::FLOAT;
            token.value += this.CurrentChar();
            this.Advance(1u64);

            while this.IsDigit(this.CurrentChar()) {
                token.value += this.CurrentChar();
                this.Advance(1u64);
            }
        } ret token;
    }

    priv LexIdentifier(this: mut Lexer&) -> Token {
        let token: mut Token;
        (token.row, token.column) = (this.row, this.column);

        while this.IsAlphaNum(this.CurrentChar()) {
            token.value += this.CurrentChar();
            this.Advance(1u64);
        }

        if token.value == "if" { token._type = TokenType::IF; }
        else if token.value == "else" { token._type = TokenType::ELSE; }
        else if token.value == "for" { token._type = TokenType::FOR; }
        else if token.value == "while" { token._type = TokenType::WHILE; }
        else if token.value == "loop" { token._type = TokenType::LOOP; }
        else if token.value == "func" { token._type = TokenType::FUNC; }
        else if token.value == "class" { token._type = TokenType::CLASS; }
        else if token.value == "ret" { token._type = TokenType::RETURN; }
        else if token.value == "break" { token._type = TokenType::BREAK; }
        else if token.value == "continue" { token._type = TokenType::CONTINUE; }
        else if token.value == "const" { token._type = TokenType::CONST; }
        else if token.value == "op" { token._type = TokenType::OPERATOR; }
        else if token.value == "pub" { token._type = TokenType::PUBLIC; }
        else if token.value == "priv" { token._type = TokenType::PRIVATE; }
        else if token.value == "include" { token._type = TokenType::INCLUDE; }
        else if token.value == "use" { token._type = TokenType::USE; }
        else if token.value == "mod" { token._type = TokenType::MOD; }
        else if token.value == "type" { token._type = TokenType::TYPE; }
        else if token.value == "let" { token._type = TokenType::LET; }
        else if token.value == "mut" { token._type = TokenType::MUT; }
        else if token.value == "true" { token._type = TokenType::TRUE; }
        else if token.value == "false" { token._type = TokenType::FALSE; }
        else if token.value == "null" { token._type = TokenType::NULL; }
        else if token.value == "impl" { token._type = TokenType::IMPL; }
        else if token.value == "new" { token._type = TokenType::NEW; }
        else if token.value == "del" { token._type = TokenType::DELETE; }
        else if token.value == "extern" { token._type = TokenType::EXTERN; }
        else if token.value == "enum" { token._type = TokenType::ENUM; }
        else if token.value == "as" { token._type = TokenType::AS; }
        else { token._type = TokenType::NAME; }
        ret token;
    }

    priv LexOperator(this: mut Lexer&) -> Token {
        let token: mut Token;
        (token.row, token.column) = (this.row, this.column);
        let current: i8 = this.CurrentChar();
        let next: i8 = this.PeekChar(1u64);
        token.value += current;

        if current == '.' && next == '.' && this.PeekChar(2u64) == '.' {
            token.value += next;
            token.value += this.PeekChar(2u64);
            token._type = TokenType::THREE_DOT;
            this.Advance(3u64);
        } else if current == '+' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::PLUS_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::PLUS;
                this.Advance(1u64);
            }
        } else if current == '-' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::MINUS_ASSIGN;
                this.Advance(2u64);
            } else if next == '>' {
                token.value += next;
                token._type = TokenType::ARROW;
                this.Advance(2u64);
            } else {
                token._type = TokenType::MINUS;
                this.Advance(1u64);
            }
        } else if current == '*' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::MUL_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::MUL;
                this.Advance(1u64);
            }
        } else if current == '/' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::DIV_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::DIV;
                this.Advance(1u64);
            }
        } else if current == '%' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::MOD_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::MOD;
                this.Advance(1u64);
            }
        } else if current == '<' {
            if next == '<' && this.PeekChar(2u64) == '=' {
                token.value += next;
                token.value += this.PeekChar(2u64);
                token._type = TokenType::LSHIFT_ASSIGN;
                this.Advance(3u64);
            } else if next == '=' {
                token.value += next;
                token._type = TokenType::LESS_EQUAL;
                this.Advance(2u64);
            } else {
                token._type = TokenType::LESS;
                this.Advance(1u64);
            }
        } else if current == '>' {
            if next == '>' && this.PeekChar(2u64) == '=' {
                token.value += next;
                token.value += this.PeekChar(2u64);
                token._type = TokenType::RSHIFT_ASSIGN;
                this.Advance(3u64);
            } else if next == '=' {
                token.value += next;
                token._type = TokenType::GREATER_EQUAL;
                this.Advance(2u64);
            } else {
                token._type = TokenType::GREATER;
                this.Advance(1u64);
            }
        } else if current == '&' {
            if next == '&' {
                token.value += next;
                token._type = TokenType::AND;
                this.Advance(2u64);
            } else if next == '=' {
                token.value += next;
                token._type = TokenType::AND_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::BITWISE_AND;
                this.Advance(1u64);
            }
        } else if current == '|' {
            if next == '|' {
                token.value += next;
                token._type = TokenType::OR;
                this.Advance(2u64);
            } else if next == '=' {
                token.value += next;
                token._type = TokenType::OR_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::BITWISE_OR;
                this.Advance(1u64);
            }
        } else if current == '^' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::XOR_ASSIGN;
                this.Advance(2u64);
            } else {
                token._type = TokenType::BITWISE_XOR;
                this.Advance(1u64);
            }
        } else if current == '=' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::EQUAL;
                this.Advance(2u64);
            } else {
                token._type = TokenType::ASSIGN;
                this.Advance(1u64);
            }
        } else if current == '!' {
            if next == '=' {
                token.value += next;
                token._type = TokenType::NOT_EQUAL;
                this.Advance(2u64);
            } else {
                token._type = TokenType::NOT;
                this.Advance(1u64);
            }
        } else if current == '?' {
            token._type = TokenType::QUESTION_MARK;
            this.Advance(1u64);
        } else if current == '~' {
            token._type = TokenType::TILDE;
            this.Advance(1u64);
        } else if current == '.' {
            token._type = TokenType::DOT;
            this.Advance(1u64);
        } else if current == ',' {
            token._type = TokenType::COMMA;
            this.Advance(1u64);
        } else if current == ':' {
            if next == ':' {
                token.value += next;
                token._type = TokenType::DOUBLE_COLON;
                this.Advance(2u64);
            } else {
                token._type = TokenType::COLON;
                this.Advance(1u64);
            }
        } else if current == ';' {
            token._type = TokenType::SEMICOLON;
            this.Advance(1u64);
        } else if current == '(' {
            token._type = TokenType::LPAREN;
            this.Advance(1u64);
        } else if current == ')' {
            token._type = TokenType::RPAREN;
            this.Advance(1u64);
        } else if current == '[' {
            token._type = TokenType::LBRACKET;
            this.Advance(1u64);
        } else if current == ']' {
            token._type = TokenType::RBRACKET;
            this.Advance(1u64);
        } else if current == '{' {
            token._type = TokenType::LBRACE;
            this.Advance(1u64);
        } else if current == '}' {
            token._type = TokenType::RBRACE;
            this.Advance(1u64);
        } else if current == '\\' {
            token._type = TokenType::BACKSLASH;
            this.Advance(1u64);
        } else {
            this.Error((String("Invalid operator '") + current + "'").Data(), this.row, this.column);
            this.Advance(1u64);
        } ret token;
    }

    pub Lex(this: mut Lexer&, text: String, file: String) -> Vector<Token> {
        (this.index, this.row, this.column) = (0u64, 1u64, 1u64);
        (this.file, this.text, this.length) = (file, text, text.Size());
        let tokens: mut Vector<Token>;

        while this.CurrentChar() != '\0' {
            this.SkipWhitespace();

            if this.CurrentChar() == '\0' {
                break;
            }

            if this.CurrentChar() == '\n' {
                this.Advance(1u64);
                continue;
            }

            if this.SkipComment() {
                continue;
            }

            if this.CurrentChar() == '"' || this.CurrentChar() == '\'' {
                tokens.PushBack(this.LexString());
            } else if this.IsDigit(this.CurrentChar()) || (this.CurrentChar() == '.' && this.IsDigit(this.PeekChar(1u64))) {
                tokens.PushBack(this.LexNumber());
            } else if this.IsAlpha(this.CurrentChar()) {
                tokens.PushBack(this.LexIdentifier());
            } else {
                tokens.PushBack(this.LexOperator());
            }
        }

        tokens.PushBack({ TokenType::EOF, "", this.row, this.column } as Token);
        ret tokens;
    }

    priv Error(this: mut Lexer&, message: i8*, row: u64, column: u64) {
        printf("Lexer error: %s at line %d, column %d. (%s)\n", message, row, column, this.file.Data());
        exit(1i32);
    }
};