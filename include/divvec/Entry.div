include "divmem" : *;

class Vector<T> {
    priv data: T* = null,
    priv size: u64 = 0u64
} impl {
    Vector(mut this: Vector<T>&) {}

    Vector(mut this: Vector<T>&, other: Vector<T>&) {
        if other.data == null { ret; }
        this.Allocate(other.size);
        let mut i: u64 = 0u64;

        while i < this.size {
            this[i] = other[i];
            i += 1u64;
        }
    }

    ~Vector(mut this: Vector<T>&) {
        this.Release();
    }

    pub Data(this: Vector<T>&) -> T* { ret this.data; }
    pub Size(this: Vector<T>&) -> u64 { ret this.size; }

    priv Allocate(mut this: Vector<T>&, newSize: u64) {
        (this.data, this.size) = (new T[newSize], newSize);
    }

    priv Release(mut this: Vector<T>&) {
        if this.data != null { del[] this.data; }
        (this.data, this.size) = (null, 0u64);
    }

    pub PushBack(mut this: Vector<T>&, value: T) {
        let temp: T* = this.data;
        this.Allocate(this.size + 1u64);

        if temp != null {
            let mut i: u64 = 0u64;

            while i < this.size - 1u64 {
                this[i] = temp[i];
                i += 1u64;
            }

            del[] temp;
        }

        this[this.size - 1u64] = value;
    }

    pub PopBack(mut this: Vector<T>&) -> T {
        let temp: T* = this.data;
        this.Allocate(this.size - 1u64);
        let value: T = temp[this.size];

        if temp != null {
            let mut i: u64 = 0u64;

            while i < this.size {
                this[i] = temp[i];
                i += 1u64;
            }

            del[] temp;
        }

        ret value;
    }

    pub Pop(mut this: Vector<T>&, index: u64) -> T {
        let temp: T* = this.data;
        this.Allocate(this.size - 1u64);
        let value: T = temp[index];

        if temp != null {
            let mut i: u64 = 0u64;

            while i < index {
                this[i] = temp[i];
                i += 1u64;
            }

            i += 1u64;

            while i < this.size + 1u64 {
                this[i - 1u64] = temp[i];
                i += 1u64;
            }

            del[] temp;
        }

        ret value;
    }

    pub Clear(mut this: Vector<T>&) {
        this.Release();
    }

    pub Remove(mut this: Vector<T>&, value: T&) {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this[i] == value {
                this.Pop(i);
                i -= 1u64;
            } i += 1u64;
        }
    }

    pub Index(mut this: Vector<T>&, value: T&) -> u64 {
        let mut i: u64 = 0u64;

        while i < this.size {
            if this[i] == value { ret i; }
            i += 1u64;
        } ret -1u64;
    }

    pub op=(mut this: Vector<T>&, other: Vector<T>&) -> Vector<T>& {
        this.Release();
        if other.data == null { ret this; }
        this.Allocate(other.size);
        let mut i: u64 = 0u64;

        while i < this.size {
            this[i] = other[i];
            i += 1u64;
        }

        ret this;
    }

    pub op[](this: Vector<T>&, index: u64) -> T& {
        ret this.data[index];
    }
};