include "divio", "divstr", "divvec", "divpair", "divptr", "divllvm", "lexer.div", "parser.div" : *;

func LLVMPositionBuilderAtStart(builder: LLVMBuilderRef, block: LLVMBasicBlockRef) {
    let first_instr: LLVMValueRef = LLVMGetFirstInstruction(block);

    if first_instr != null {
        LLVMPositionBuilderBefore(builder, first_instr);
    } else {
        LLVMPositionBuilderAtEnd(builder, block);
    }
}

func LLVMIsTypeEqual(left: LLVMTypeRef, right: LLVMTypeRef) -> bool {
    if left == right { ret true; }
    let left_kind: LLVMTypeKind = LLVMGetTypeKind(left);
    let right_kind: LLVMTypeKind = LLVMGetTypeKind(right);

    if left_kind != right_kind {
        ret false;
    } else if left_kind == LLVMTypeKind::LLVMVoidTypeKind || left_kind == LLVMTypeKind::LLVMPointerTypeKind || left_kind == LLVMTypeKind::LLVMHalfTypeKind || left_kind == LLVMTypeKind::LLVMFloatTypeKind || left_kind == LLVMTypeKind::LLVMDoubleTypeKind || left_kind == LLVMTypeKind::LLVMX86_FP80TypeKind || left_kind == LLVMTypeKind::LLVMFP128TypeKind || left_kind == LLVMTypeKind::LLVMPPC_FP128TypeKind || left_kind == LLVMTypeKind::LLVMLabelTypeKind {
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMIntegerTypeKind {
        ret LLVMGetIntTypeWidth(left) == LLVMGetIntTypeWidth(right);
    } else if left_kind == LLVMTypeKind::LLVMFunctionTypeKind {
        if !LLVMIsTypeEqual(LLVMGetReturnType(left), LLVMGetReturnType(right)) {
            ret false;
        }

        let left_param_count: u32 = LLVMCountParamTypes(left);
        let right_param_count: u32 = LLVMCountParamTypes(right);

        if (left_param_count != right_param_count) {
            ret false;
        }

        let left_params: LLVMTypeRef* = new LLVMTypeRef[left_param_count as u64];
        let right_params: LLVMTypeRef* = new LLVMTypeRef[right_param_count as u64];

        LLVMGetParamTypes(left, left_params);
        LLVMGetParamTypes(right, right_params);
        let mut i: u32 = 0u32;

        while i < left_param_count {
            if !LLVMIsTypeEqual(left_params[i], right_params[i]) {
                del[] left_params;
                del[] right_params;
                ret false;
            } i += 1u32;
        }

        del[] left_params;
        del[] right_params;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMArrayTypeKind {
        ret LLVMGetArrayLength(left) == LLVMGetArrayLength(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else if left_kind == LLVMTypeKind::LLVMStructTypeKind {
        let left_name: i8* = LLVMGetStructName(left);
        let right_name: i8* = LLVMGetStructName(right);
            
        if left_name != null && right_name != null {
            ret strcmp(left_name, right_name) == 0i32;
        }

        let left_elem_count: u32 = LLVMCountStructElementTypes(left);
        let right_elem_count: u32 = LLVMCountStructElementTypes(right);
        
        if left_elem_count != right_elem_count {
            ret false;
        }

        if LLVMIsPackedStruct(left) != LLVMIsPackedStruct(right) {
            ret false;
        }

        let left_elems: LLVMTypeRef* = new LLVMTypeRef[left_elem_count as u64];
        let right_elems: LLVMTypeRef* = new LLVMTypeRef[right_elem_count as u64];

        LLVMGetStructElementTypes(left, left_elems);
        LLVMGetStructElementTypes(right, right_elems);
        let mut i: u32 = 0u32;

        while i < left_elem_count {
            if !LLVMIsTypeEqual(left_elems[i], right_elems[i]) {
                del[] left_elems;
                del[] right_elems;
                ret false;
            } i += 1u32;
        }
        
        del[] left_elems;
        del[] right_elems;
        ret true;
    } else if left_kind == LLVMTypeKind::LLVMVectorTypeKind {
        ret LLVMGetVectorSize(left) == LLVMGetVectorSize(right) && LLVMIsTypeEqual(LLVMGetElementType(left), LLVMGetElementType(right));
    } else {
        ret false;
    }
}

func LLVMElementTypeOf(value: LLVMValueRef) -> LLVMTypeRef {
    if LLVMGetInstructionOpcode(value) == LLVMOpcode::LLVMAlloca {
        ret LLVMGetAllocatedType(value);
    } else {
        ret LLVMGetElementType(LLVMTypeOf(value));
    }
}

func LLVMTypeToString(_type: LLVMTypeRef) -> String {
    let mut result: String;
    let string: i8* = LLVMPrintTypeToString(_type);
    result += string;
    LLVMDisposeMessage(string);
    ret result;
}

class QualifiedType {
    priv value: LLVMTypeRef,
    priv mutable: bool, priv signed: bool,
    priv pointee: QualifiedType* = null
} impl {
    QualifiedType(mut this: QualifiedType&, value: LLVMTypeRef, mutable: bool, signed: bool, pointee: QualifiedType*) {
        (this.value, this.mutable, this.signed, this.pointee) = (value, mutable, signed, pointee);
    }

    ~QualifiedType(this: QualifiedType&) {}

    pub Value(this: QualifiedType&) -> LLVMTypeRef {
        if this.value == null {
            printf("Null type value!\n");
            exit(1i32);
        }

        ret this.value;
    }

    pub Mutable(this: QualifiedType&) -> bool { ret this.mutable; }
    pub Signed(this: QualifiedType&) -> bool { ret this.signed; }

    pub Pointee(this: QualifiedType&) -> QualifiedType& {
        if this.pointee == null {
            printf("Null pointee!\n");
            exit(1i32);
        }

        ret this.pointee;
    }

    pub op==(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret this.signed == other.signed && LLVMIsTypeEqual(this.value, other.value) && this.pointee == other.pointee;
    }

    pub op!=(this: QualifiedType&, other: QualifiedType&) -> bool {
        ret !this.op==(other);
    }
};

class TypeManager {
    priv types: Vector<QualifiedType*>
} impl {
    TypeManager(this: TypeManager&) {}

    ~TypeManager(mut this: TypeManager&) {
        printf("Disposing %llu types...\n", this.types.Size());
        let mut i: u64 = 0u64;

        while i < this.types.Size() {
            del this.types[i];
            i += 1u64;
        }

        this.types.Clear();
    }

    pub New(mut this: TypeManager&, value: LLVMTypeRef, mutable: bool, signed: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(value, mutable, signed, null);
        this.types.PushBack(_type);
        ret _type;
    }

    pub Pointer(mut this: TypeManager&, pointee: QualifiedType*, mutable: bool) -> QualifiedType* {
        let _type: QualifiedType* = new QualifiedType(LLVMPointerType(pointee->Value(), 0u32), mutable, pointee->Signed(), pointee);
        this.types.PushBack(_type);
        ret _type;
    }
};

class QualifiedValue {
    priv value: LLVMValueRef,
    priv _type: QualifiedType*
} impl {
    QualifiedValue(mut this: QualifiedValue&, value: LLVMValueRef, _type: QualifiedType*) {
        (this.value, this._type) = (value, _type);
    }

    ~QualifiedValue(this: QualifiedValue&) {}

    pub Value(this: QualifiedValue&) -> LLVMValueRef {
        if this._type == null {
            printf("Null value!\n");
            exit(1i32);
        }

        ret this.value;
    }

    pub Type(this: QualifiedValue&) -> QualifiedType& {
        if this._type == null {
            printf("Null type!\n");
            exit(1i32);
        }

        ret this._type;
    }

    pub op==(this: QualifiedValue&, other: QualifiedValue&) -> bool {
        ret this.value == other.value && this._type == other._type;
    }

    pub op!=(this: QualifiedValue&, other: QualifiedValue&) -> bool {
        ret !this.op==(other);
    }
};

enum SymbolKind {
    Variable, Function, Parameter
};

class Symbol {
    pub name: String,
    pub kind: SymbolKind,
    pub value: QualifiedValue
};

class Scope {
    pub parent: Scope*,
    pub children: Vector<Scope*>,
    pub global: bool,
    pub symbols: Vector<Symbol*>,
    pub name: String
} impl {
    Scope(mut this: Scope&, parent: Scope*, name: String, global: bool) {
        (this.parent, this.name, this.global) = (parent, name, global);
    }

    ~Scope(mut this: Scope&) {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            del this.symbols[i];
            i += 1u64;
        }
    }

    pub Has(mut this: Scope&, name: String) -> bool {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret true;
            } i += 1u64;
        } ret false;
    }

    pub Set(mut this: Scope&, name: String, kind: SymbolKind, value: QualifiedValue) {
        if this.Has(name) {
            this.Error("Symbol already exists.");
        } else {
            let symbol: Symbol* = new Symbol(name, kind, value);
            this.symbols.PushBack(symbol);
        }
    }

    pub Get(mut this: Scope&, name: String) -> Symbol* {
        let mut i: u64 = 0u64;

        while i < this.symbols.Size() {
            if this.symbols[i]->name == name {
                ret this.symbols[i];
            } i += 1u64;
        } ret null;
    }

    priv Error(mut this: Scope&, string: i8*) {
        printf("Scope error: %s\n", string);
        exit(1i32);
    }
};

class ScopeManager {
    pub scopes: Vector<Scope*>,
    pub current: Scope* = null
} impl {
    ScopeManager(mut this: ScopeManager&) {
        this.PushScope(String("global"), true);
    }

    ~ScopeManager(mut this: ScopeManager&) {
        this.PopScope();
    }

    pub PushScope(mut this: ScopeManager&, name: String, global: bool) {
        let scope: Scope* = new Scope(this.current, name, global);

        if global {
            this.scopes.PushBack(scope);
        }

        if this.current != null {
            this.current->children.PushBack(scope);
        } this.current = scope;
    }

    pub PopScope(mut this: ScopeManager&) {
        if this.current != null {
            let temp: Scope* = this.current;
            this.current = this.current->parent;

            if this.current == null {
                let mut i: u64 = 0u64;

                while i < this.scopes.Size() {
                    del this.scopes[i];
                    i += 1u64;
                }
            }

            if !temp->global {
                this.current->children.Remove(temp);
                del temp;
            }
        } else {
            this.Error("No scope to pop.");
        }
    }

    pub Has(mut this: ScopeManager&, name: String) -> bool {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret true; }
            scope = scope->parent;
        } ret false;
    }

    pub Set(mut this: ScopeManager&, name: String, kind: SymbolKind, value: QualifiedValue) {
        this.current->Set(name, kind, value);
    }

    pub Get(mut this: ScopeManager&, name: String) -> Symbol* {
        let mut scope: Scope* = this.current;

        while scope != null {
            if scope->Has(name) { ret scope->Get(name); }
            scope = scope->parent;
        } ret null;
    }

    priv Error(mut this: ScopeManager&, string: i8*) {
        printf("Scope manager error: %s\n", string);
        exit(1i32);
    }
};

class Compiler {
    priv type_manager: TypeManager,
    priv scope_manager: ScopeManager,
    priv blocks: Vector<Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>>,
    priv context: LLVMContextRef = null,
    priv module: LLVMModuleRef = null,
    priv builder: LLVMBuilderRef = null,
    priv function: LLVMValueRef = null,
    priv number: u64
} impl {
    Compiler(mut this: Compiler&) {
        this.context = LLVMContextCreate();
    }

    ~Compiler(mut this: Compiler&) {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        if this.context != null {
            LLVMContextDispose(this.context);
            this.context = null;
        }
    }

    pub GetUniqueName(mut this: Compiler&) -> String {
        let buffer[256]: i8;
        sprintf(buffer, "%llu", this.number);
        this.number += 1u64;
        ret String(".") + buffer;
    }

    pub Forget(mut this: Compiler&) {
        this.module = null;
    }

    pub Compile(mut this: Compiler&, ast: RootNode*) -> LLVMModuleRef {
        if this.builder != null {
            LLVMDisposeBuilder(this.builder);
            this.builder = null;
        }

        if this.module != null {
            LLVMDisposeModule(this.module);
            this.module = null;
        }

        this.module = LLVMModuleCreateWithNameInContext("divine", this.context);
        LLVMSetSourceFileName(this.module, "hello.div", 9u64);
        LLVMSetTarget(this.module, LLVMGetDefaultTargetTriple());
        this.builder = LLVMCreateBuilderInContext(this.context);
        let mut i: u64 = 0u64;

        while i < ast->declarations.Size() {
            let decl: ASTNode* = ast->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }

        ret this.module;
    }

    priv CompileDeclaration(mut this: Compiler&, decl: ASTNode*) {
        if decl->node_type == ASTNodeType::FUNCTION_DECL {
            this.CompileFunction(decl as FunctionDeclNode*);
        } else if decl->node_type == ASTNodeType::EXTERN_BLOCK {
            this.CompileExtern(decl as ExternBlockNode*);
        } else {
            this.Error((String("Unknown declaration: ") + ASTNodeTypeToString(decl->node_type) + ".").Data());
        }
    }

    priv CompileExtern(mut this: Compiler&, extern_block: ExternBlockNode*) {
        let mut i: u64 = 0u64;

        while i < extern_block->declarations.Size() {
            let decl: ASTNode* = extern_block->declarations[i];
            this.CompileDeclaration(decl);
            i += 1u64;
        }
    }

    priv CompileFunction(mut this: Compiler&, func_decl: FunctionDeclNode*) {
        this.number = 0u64;
        let func_name: i8* = func_decl->name.Data();
        let mut param_types: Vector<LLVMTypeRef>;
        let mut i: u64 = 0u64;

        while i < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[i];
            param_types.PushBack(this.CompileType(param->param_type).Value());
            i += 1u64;
        }

        let return_type: LLVMTypeRef = this.CompileType(func_decl->return_type).Value();
        let func_type: LLVMTypeRef = LLVMFunctionType(return_type, param_types.Data(), param_types.Size() as u32, func_decl->var_arg ? 1i32 : 0i32);
        this.function = LLVMAddFunction(this.module, func_name, func_type);
        this.scope_manager.Set(func_decl->name, SymbolKind::Function, QualifiedValue(this.function, this.type_manager.New(func_type, false, false)));
        let mut j: u64 = 0u64;

        while j < func_decl->parameters.Size() {
            let param: ParameterNode* = func_decl->parameters[j];
            let name: String = this.GetUniqueName().Data();
            LLVMSetValueName2(LLVMGetParam(this.function, j as u32), name.Data(), name.Size() - 1u64);
            j += 1u64;
        }

        if func_decl->body != null {
            this.scope_manager.PushScope(func_decl->name, false);
            let mut k: u64 = 0u64;

            while k < func_decl->parameters.Size() {
                let param: ParameterNode* = func_decl->parameters[k];
                this.scope_manager.Set(param->name, SymbolKind::Parameter, QualifiedValue(LLVMGetParam(this.function, k as u32), this.type_manager.New(param_types[k], false, false)));
                k += 1u64;
            }

            let entry: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            LLVMPositionBuilderAtEnd(this.builder, entry);
            this.CompileBlock(func_decl->body);
            this.scope_manager.PopScope();
        } this.function = null;
    }

    priv CompileBlock(mut this: Compiler&, block: BlockStmtNode*) {
        let mut i: u64 = 0u64;

        while i < block->statements.Size() {
            let stmt: ASTNode* = block->statements[i];
            this.CompileStatement(stmt);
            i += 1u64;
        }
    }

    priv CompileStatement(mut this: Compiler&, stmt: ASTNode*) {
        if stmt->node_type == ASTNodeType::RETURN_STMT {
            let ret_stmt: ReturnStmtNode* = stmt as ReturnStmtNode*;
            LLVMBuildRet(this.builder, this.CompileExpression(ret_stmt->value).Value());
        } else if stmt->node_type == ASTNodeType::EXPRESSION_STMT {
            let expr_stmt: ExpressionStmtNode* = stmt as ExpressionStmtNode*;
            this.CompileExpression(expr_stmt->expression);
        } else if stmt->node_type == ASTNodeType::IF_STMT {
            this.CompileIf(stmt as IfStmtNode*);
        } else if stmt->node_type == ASTNodeType::WHILE_STMT {
            this.CompileWhile(stmt as WhileStmtNode*);
        } else if stmt->node_type == ASTNodeType::CONTINUE_STMT {
            this.CompileContinue(stmt as ContinueStmtNode*);
        } else if stmt->node_type == ASTNodeType::BREAK_STMT {
            this.CompileBreak(stmt as BreakStmtNode*);
        } else if stmt->node_type == ASTNodeType::VARIABLE_DECL {
            this.CompileVariable(stmt as VariableDeclNode*);
        } else if stmt->node_type == ASTNodeType::ASSIGNMENT {
            this.CompileAssignment(stmt as AssignmentNode*);
        } else {
            this.Error((String("Unknown statement: ") + ASTNodeTypeToString(stmt->node_type) + ".").Data());
        }
    }

    priv CompileIf(mut this: Compiler&, if_stmt: IfStmtNode*) {
        if this.function == null {
            this.Error("If statement outside of function.");
            ret;
        }

        let mut current: IfStmtNode* = if_stmt;
        let mut end_block: LLVMBasicBlockRef = null;

        while current != null {
            let then_stmt: BlockStmtNode* = current->then_stmt as BlockStmtNode*;
            let else_stmt: ASTNode* = current->else_stmt;
            let mut has_else: bool = false;

            if else_stmt != null {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    let block: BlockStmtNode* = else_stmt as BlockStmtNode*;
                    has_else = block->statements.Size() > 0u64;
                } else if else_stmt->node_type == ASTNodeType::IF_STMT {
                    has_else = true;
                } else {
                    this.Error((String("Unknown else statement: ") + ASTNodeTypeToString(else_stmt->node_type) + ".").Data());
                    ret;
                }
            }

            let mut then_block: LLVMBasicBlockRef;
            let mut else_block: LLVMBasicBlockRef;

            if then_stmt->statements.Size() > 0u64 {
                then_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } then_block = end_block;
            }

            if has_else {
                else_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
            } else {
                if end_block == null {
                    end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                } else_block = end_block;
            }

            let condition: QualifiedValue = this.CompileExpression(current->condition);
            LLVMBuildCondBr(this.builder, condition.Value(), then_block, else_block);

            if then_stmt->statements.Size() > 0u64 {
                LLVMPositionBuilderAtEnd(this.builder, then_block);
                this.scope_manager.PushScope(String("then"), false);
                this.CompileBlock(then_stmt);
                this.scope_manager.PopScope();

                if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                    if end_block == null {
                        end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                    } LLVMBuildBr(this.builder, end_block);
                }
            }

            LLVMPositionBuilderAtEnd(this.builder, else_block);

            if has_else {
                if else_stmt->node_type == ASTNodeType::BLOCK_STMT {
                    this.scope_manager.PushScope(String("else"), false);
                    this.CompileBlock(else_stmt as BlockStmtNode*);
                    this.scope_manager.PopScope();

                    if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
                        if end_block == null {
                            end_block = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
                        } LLVMBuildBr(this.builder, end_block);
                    } current = null;
                } else {
                    current = else_stmt as IfStmtNode*;
                }
            } else {
                current = null;
            }
        }

        if end_block != null {
            LLVMPositionBuilderAtEnd(this.builder, end_block);
        }
    }

    priv CompileWhile(mut this: Compiler&, while_stmt: WhileStmtNode*) {
        if this.function == null {
            this.Error("While statement outside of function.");
            ret;
        }

        let compare_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let loop_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        let end_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.context, this.function, this.GetUniqueName().Data());
        this.blocks.PushBack(Pair<LLVMBasicBlockRef, LLVMBasicBlockRef>(compare_block, end_block));

        LLVMBuildBr(this.builder, compare_block);
        LLVMPositionBuilderAtStart(this.builder, compare_block);
        let condition: QualifiedValue = this.CompileExpression(while_stmt->condition);
        LLVMBuildCondBr(this.builder, condition.Value(), loop_block, end_block);

        LLVMPositionBuilderAtStart(this.builder, loop_block);
        this.scope_manager.PushScope(String("while"), false);
        this.CompileBlock(while_stmt->body as BlockStmtNode*);
        this.scope_manager.PopScope();

        if LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(this.builder)) == null {
            LLVMBuildBr(this.builder, compare_block);
        }

        LLVMPositionBuilderAtStart(this.builder, end_block);
        this.blocks.PopBack();
    }

    priv CompileContinue(mut this: Compiler&, continue_stmt: ContinueStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Continue statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].left);
    }

    priv CompileBreak(mut this: Compiler&, break_stmt: BreakStmtNode*) {
        if this.blocks.Size() == 0u64 {
            this.Error("Break statement outside of loop.");
            ret;
        }

        LLVMBuildBr(this.builder, this.blocks[this.blocks.Size() - 1u64].right);
    }

    priv CompileVariable(mut this: Compiler&, variable: VariableDeclNode*) {
        let initializer: QualifiedValue = this.CompileExpression(variable->initializer);
        let _type: QualifiedType& = this.CompileType(variable->var_type);

        if initializer.Type() != _type {
            this.Error((String("Incompatible types: ") + LLVMTypeToString(initializer.Type().Value()) + " and " + LLVMTypeToString(_type.Value()) + ".").Data());
            ret;
        }

        let current: LLVMBasicBlockRef = LLVMGetInsertBlock(this.builder);
        LLVMPositionBuilderAtStart(this.builder, LLVMGetEntryBasicBlock(LLVMGetBasicBlockParent(current)));
        let pointer: LLVMValueRef = LLVMBuildAlloca(this.builder, _type.Value(), this.GetUniqueName().Data());
        this.scope_manager.Set(variable->name, SymbolKind::Variable, QualifiedValue(pointer, this.type_manager.Pointer(initializer.Type(), variable->is_mutable)));
        LLVMBuildStore(this.builder, initializer.Value(), pointer);
        LLVMPositionBuilderAtEnd(this.builder, current);
    }

    priv CompileAssignment(mut this: Compiler&, assignment: AssignmentNode*) {
        let pointer: QualifiedValue = this.CompilePointerExpression(assignment->left);
        let value: QualifiedValue = this.CompileExpression(assignment->right);

        if !pointer.Type().Mutable() {
            this.Error("Cannot assign to immutable variable.");
            ret;
        }

        if value.Type() != pointer.Type().Pointee() {
            this.Error((String("Incompatible types: ") + LLVMTypeToString(value.Type().Value()) + " and " + LLVMTypeToString(pointer.Type().Pointee().Value()) + ".").Data());
            ret;
        }

        LLVMBuildStore(this.builder, value.Value(), pointer.Value());
    }

    priv CompilePointerExpression(mut this: Compiler&, expr: ASTNode*) -> QualifiedValue {
        if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret QualifiedValue(null, null);
            }

            ret this.scope_manager.Get(identifier->name)->value;
        } else {
            this.Error((String("Unknown pointer expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileExpression(mut this: Compiler&, expr: ASTNode*) -> QualifiedValue {
        if expr->node_type == ASTNodeType::LITERAL {
            let literal: LiteralNode* = expr as LiteralNode*;

            if literal->literal_type == TokenType::INTEGER {
                let (mut state: bool, mut i: u64) = (false, 0u64);
                let (mut signed: bool, mut width: u64) = (true, 32u64);
                let (mut value: String, mut size: String);

                while i < literal->value.Size() {
                    if !state {
                        if literal->value[i] == 'u' {
                            (signed, state) = (false, true);
                        } else if literal->value[i] == 'i' {
                            (signed, state) = (true, true);
                        } else {
                            value += literal->value[i];
                        }
                    } else {
                        size += literal->value[i];
                    } i += 1u64;
                }

                let mut _type: LLVMTypeRef;
                width = size.ToInteger() as u64;

                if width == 128u64 {
                    _type = LLVMInt128TypeInContext(this.context);
                } else if width == 64u64 {
                    _type = LLVMInt64TypeInContext(this.context);
                } else if width == 32u64 {
                    _type = LLVMInt32TypeInContext(this.context);
                } else if width == 16u64 {
                    _type = LLVMInt16TypeInContext(this.context);
                } else if width == 8u64 {
                    _type = LLVMInt8TypeInContext(this.context);
                } else {
                    this.Error("Invalid integer size.");
                    ret QualifiedValue(null, null);
                }

                ret QualifiedValue(LLVMConstInt(_type, value.ToInteger() as u64, 1i32), this.type_manager.New(_type, false, signed));
            } else if literal->literal_type == TokenType::FLOAT {
                let (mut state: bool, mut i: u64) = (false, 0u64);
                let (mut value: String, mut size: String);
                let mut width: u64 = 32u64;

                while i < literal->value.Size() {
                    if !state {
                        if literal->value[i] == 'f' {
                            state = true;
                        } else {
                            value += literal->value[i];
                        }
                    } else {
                        size += literal->value[i];
                    } i += 1u64;
                }

                let mut _type: LLVMTypeRef;
                width = size.ToInteger() as u64;

                if width == 64u64 {
                    _type = LLVMDoubleTypeInContext(this.context);
                } else if width == 32u64 {
                    _type = LLVMFloatTypeInContext(this.context);
                } else {
                    this.Error("Invalid float size.");
                    ret QualifiedValue(null, null);
                }

                ret QualifiedValue(LLVMConstReal(_type, value.ToFloat()), this.type_manager.New(_type, false, false));
            } else if literal->literal_type == TokenType::STRING {
                let value: LLVMValueRef = LLVMBuildGlobalStringPtr(this.builder, literal->value.Data(), "fmt");
                ret QualifiedValue(value, this.type_manager.New(LLVMTypeOf(value), false, false));
            } else {
                this.Error((String("Unknown literal type: ") + TokenTypeToString(literal->literal_type) + ".").Data());
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::CALL {
            let call: CallNode* = expr as CallNode*;
            let mut args: Vector<LLVMValueRef>;
            let mut i: u64 = 0u64;

            while i < call->arguments.Size() {
                let arg: ASTNode* = call->arguments[i];
                args.PushBack(this.CompileExpression(arg).Value());
                i += 1u64;
            }

            let _func: QualifiedValue = this.CompileExpression(call->function);
            let value: LLVMValueRef = LLVMBuildCall2(this.builder, _func.Type().Value(), _func.Value(), args.Data(), args.Size() as u32, this.GetUniqueName().Data());
            ret QualifiedValue(value, this.type_manager.New(LLVMGetReturnType(_func.Type().Value()), false, false));
        } else if expr->node_type == ASTNodeType::IDENTIFIER {
            let identifier: IdentifierNode* = expr as IdentifierNode*;

            if !this.scope_manager.Has(identifier->name) {
                this.Error((String("Symbol not found: ") + identifier->name + ".").Data());
                ret QualifiedValue(null, null);
            }

            let symbol: Symbol* = this.scope_manager.Get(identifier->name);

            if symbol->kind == SymbolKind::Variable {
                let _type: LLVMTypeRef = symbol->value.Type().Pointee().Value();
                ret QualifiedValue(LLVMBuildLoad2(this.builder, _type, symbol->value.Value(), this.GetUniqueName().Data()), this.type_manager.New(_type, false, false));
            } else if symbol->kind == SymbolKind::Function || symbol->kind == SymbolKind::Parameter {
                ret symbol->value;
            } else {
                this.Error("Unknown symbol kind.");
                ret QualifiedValue(null, null);
            }
        } else if expr->node_type == ASTNodeType::BINARY_OP {
            let binary_op: BinaryOpNode* = expr as BinaryOpNode*;
            let left: QualifiedValue = this.CompileExpression(binary_op->left);
            let right: QualifiedValue = this.CompileExpression(binary_op->right);
            let kind: LLVMTypeKind = LLVMGetTypeKind(left.Type().Value());

            if left.Type() != right.Type() {
                this.Error((String("Incompatible types: ") + LLVMTypeToString(left.Type().Value()) + " and " + LLVMTypeToString(right.Type().Value()) + ".").Data());
                ret QualifiedValue(null, null);
            }

            if kind == LLVMTypeKind::LLVMIntegerTypeKind {
                if binary_op->operator == TokenType::PLUS {
                    ret QualifiedValue(LLVMBuildAdd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    ret QualifiedValue(LLVMBuildSub(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MUL {
                    ret QualifiedValue(LLVMBuildMul(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::DIV {
                    ret QualifiedValue(LLVMBuildSDiv(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MOD {
                    ret QualifiedValue(LLVMBuildSRem(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::EQUAL {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntEQ, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::NOT_EQUAL {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntNE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::GREATER {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGT, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::GREATER_EQUAL {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSGE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::LESS {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLT, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::LESS_EQUAL {
                    ret QualifiedValue(LLVMBuildICmp(this.builder, LLVMIntPredicate::LLVMIntSLE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::AND || binary_op->operator == TokenType::BITWISE_AND {
                    ret QualifiedValue(LLVMBuildAnd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::OR || binary_op->operator == TokenType::BITWISE_OR {
                    ret QualifiedValue(LLVMBuildOr(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::BITWISE_XOR {
                    ret QualifiedValue(LLVMBuildXor(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::LSHIFT {
                    ret QualifiedValue(LLVMBuildShl(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::RSHIFT {
                    ret QualifiedValue(LLVMBuildAShr(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else {
                    this.Error((String("Invalid operator for integers: ") + TokenTypeToString(binary_op->operator) + ".").Data());
                    ret QualifiedValue(null, null);
                }
            } else if kind == LLVMTypeKind::LLVMFloatTypeKind || kind == LLVMTypeKind::LLVMDoubleTypeKind {
                if binary_op->operator == TokenType::PLUS {
                    ret QualifiedValue(LLVMBuildFAdd(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MINUS {
                    ret QualifiedValue(LLVMBuildFSub(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MUL {
                    ret QualifiedValue(LLVMBuildFMul(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::DIV {
                    ret QualifiedValue(LLVMBuildFDiv(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::MOD {
                    ret QualifiedValue(LLVMBuildFRem(this.builder, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::EQUAL {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOEQ, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::NOT_EQUAL {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealONE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::GREATER {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGT, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::GREATER_EQUAL {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOGE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::LESS {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLT, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else if binary_op->operator == TokenType::LESS_EQUAL {
                    ret QualifiedValue(LLVMBuildFCmp(this.builder, LLVMRealPredicate::LLVMRealOLE, left.Value(), right.Value(), this.GetUniqueName().Data()), left.Type());
                } else {
                    this.Error((String("Invalid operator for floats: ") + TokenTypeToString(binary_op->operator) + ".").Data());
                    ret QualifiedValue(null, null);
                }
            } else {
                this.Error("Invalid type.");
                ret QualifiedValue(null, null);
            }
        } else {
            this.Error((String("Unknown expression: ") + ASTNodeTypeToString(expr->node_type) + ".").Data());
            ret QualifiedValue(null, null);
        }
    }

    priv CompileType(mut this: Compiler&, type_node: ASTNode*) -> QualifiedType& {
        if type_node->node_type == ASTNodeType::PRIMITIVE_TYPE {
            let primitive_type: PrimitiveTypeNode* = type_node as PrimitiveTypeNode*;

            if primitive_type->type_name == "i8" || primitive_type->type_name == "u8" {
                ret this.type_manager.New(LLVMInt8TypeInContext(this.context), false, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i16" || primitive_type->type_name == "u16" {
                ret this.type_manager.New(LLVMInt16TypeInContext(this.context), false, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i32" || primitive_type->type_name == "u32" || primitive_type->type_name == "char" {
                ret this.type_manager.New(LLVMInt32TypeInContext(this.context), false, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i64" || primitive_type->type_name == "u64" {
                ret this.type_manager.New(LLVMInt64TypeInContext(this.context), false, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "i128" || primitive_type->type_name == "u128" {
                ret this.type_manager.New(LLVMInt128TypeInContext(this.context), false, primitive_type->type_name[0u64] != 'u' ? true : false);
            } else if primitive_type->type_name == "f32" {
                ret this.type_manager.New(LLVMFloatTypeInContext(this.context), false, false);
            } else if primitive_type->type_name == "f64" {
                ret this.type_manager.New(LLVMDoubleTypeInContext(this.context), false, false);
            } else if primitive_type->type_name == "void" {
                ret this.type_manager.New(LLVMVoidTypeInContext(this.context), false, false);
            } else {
                this.Error("Unknown primitive type.");
                ret null;
            }
        } else if type_node->node_type == ASTNodeType::POINTER_TYPE {
            let pointer_type: PointerTypeNode* = type_node as PointerTypeNode*;
            ret this.type_manager.Pointer(this.CompileType(pointer_type->base_type), false);
        } else {
            this.Error("Unknown type.");
            ret null;
        }
    }

    priv Error(mut this: Compiler&, string: i8*) {
        printf("Compiler error: %s\n", string);
        exit(1i32);
    }
};