/*
 * Copyright 2025 Yusuf RenÃ§ber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "divio", "divstr", "divvec", "divmap", "divwin", "lexer.div" : *;

enum ASTNodeType {
    LITERAL, IDENTIFIER, SCOPE_RESOLUTION, BINARY_OP, UNARY_OP, TERNARY,
    CALL, MEMBER_ACCESS, INDEX_ACCESS, CAST, INITIALIZER_LIST, NEW, DELETE,

    EXPRESSION_STMT, VARIABLE_DECL, CONSTANT_DECL, ASSIGNMENT, IF_STMT, WHILE_STMT, 
    LOOP_STMT, RETURN_STMT, BREAK_STMT, CONTINUE_STMT, BLOCK_STMT,

    FUNCTION_DECL, CLASS_DECL, ENUM_DECL, EXTERN_BLOCK, TYPE_DECL,
    IMPL_BLOCK, PARAMETER, FIELD,

    PRIMITIVE_TYPE, POINTER_TYPE, REFERENCE_TYPE, ARRAY_TYPE, FUNCTION_TYPE,

    ROOT
};

func ASTNodeTypeToString(_type: ASTNodeType) -> String {
    if _type == ASTNodeType::LITERAL { ret { "LITERAL" } as String; }
    else if _type == ASTNodeType::IDENTIFIER { ret { "IDENTIFIER" } as String; }
    else if _type == ASTNodeType::SCOPE_RESOLUTION { ret { "SCOPE_RESOLUTION" } as String; }
    else if _type == ASTNodeType::BINARY_OP { ret { "BINARY_OP" } as String; }
    else if _type == ASTNodeType::UNARY_OP { ret { "UNARY_OP" } as String; }
    else if _type == ASTNodeType::TERNARY { ret { "TERNARY" } as String; }
    else if _type == ASTNodeType::CALL { ret { "CALL" } as String; }
    else if _type == ASTNodeType::MEMBER_ACCESS { ret { "MEMBER_ACCESS" } as String; }
    else if _type == ASTNodeType::INDEX_ACCESS { ret { "INDEX_ACCESS" } as String; }
    else if _type == ASTNodeType::CAST { ret { "CAST" } as String; }
    else if _type == ASTNodeType::INITIALIZER_LIST { ret { "INITIALIZER_LIST" } as String; }
    else if _type == ASTNodeType::NEW { ret { "NEW" } as String; }
    else if _type == ASTNodeType::DELETE { ret { "DELETE" } as String; }
    else if _type == ASTNodeType::EXPRESSION_STMT { ret { "EXPRESSION_STMT" } as String; }
    else if _type == ASTNodeType::VARIABLE_DECL { ret { "VARIABLE_DECL" } as String; }
    else if _type == ASTNodeType::CONSTANT_DECL { ret { "CONSTANT_DECL" } as String; }
    else if _type == ASTNodeType::ASSIGNMENT { ret { "ASSIGNMENT" } as String; }
    else if _type == ASTNodeType::IF_STMT { ret { "IF_STMT" } as String; }
    else if _type == ASTNodeType::WHILE_STMT { ret { "WHILE_STMT" } as String; }
    else if _type == ASTNodeType::RETURN_STMT { ret { "RETURN_STMT" } as String; }
    else if _type == ASTNodeType::BREAK_STMT { ret { "BREAK_STMT" } as String; }
    else if _type == ASTNodeType::CONTINUE_STMT { ret { "CONTINUE_STMT" } as String; }
    else if _type == ASTNodeType::BLOCK_STMT { ret { "BLOCK_STMT" } as String; }
    else if _type == ASTNodeType::FUNCTION_DECL { ret { "FUNCTION_DECL" } as String; }
    else if _type == ASTNodeType::CLASS_DECL { ret { "CLASS_DECL" } as String; }
    else if _type == ASTNodeType::ENUM_DECL { ret { "ENUM_DECL" } as String; }
    else if _type == ASTNodeType::EXTERN_BLOCK { ret { "EXTERN_BLOCK" } as String; }
    else if _type == ASTNodeType::TYPE_DECL { ret { "TYPE_DECL" } as String; }
    else if _type == ASTNodeType::IMPL_BLOCK { ret { "IMPL_BLOCK" } as String; }
    else if _type == ASTNodeType::PARAMETER { ret { "PARAMETER" } as String; }
    else if _type == ASTNodeType::FIELD { ret { "FIELD" } as String; }
    else if _type == ASTNodeType::PRIMITIVE_TYPE { ret { "PRIMITIVE_TYPE" } as String; }
    else if _type == ASTNodeType::POINTER_TYPE { ret { "POINTER_TYPE" } as String; }
    else if _type == ASTNodeType::REFERENCE_TYPE { ret { "REFERENCE_TYPE" } as String; }
    else if _type == ASTNodeType::ARRAY_TYPE { ret { "ARRAY_TYPE" } as String; }
    else if _type == ASTNodeType::FUNCTION_TYPE { ret { "FUNCTION_TYPE" } as String; }
    else if _type == ASTNodeType::ROOT { ret { "ROOT" } as String; }
    else { ret { "UNKNOWN" } as String; }
}

class ASTNode {
    pub node_type: ASTNodeType,
    pub row: u64, pub column: u64
} impl {
    ASTNode(this: &mut ASTNode, _type: ASTNodeType, row: u64, column: u64) {
        (this.node_type, this.row, this.column) = (_type, row, column);
    }
};

class PrimitiveTypeNode : ASTNode {
    pub name: String,
    pub generic: bool = false,
    pub types: Vector<*const ASTNode>
} impl {
    PrimitiveTypeNode(this: &mut PrimitiveTypeNode, name: String, row: u64, column: u64) : ASTNode(ASTNodeType::PRIMITIVE_TYPE, row, column) {
        this.name = name;
    }
};

class PointerTypeNode : ASTNode {
    pub base_type: *const ASTNode,
    pub mutable: bool = false
} impl {
    PointerTypeNode(this: &mut PointerTypeNode, base_type: *const ASTNode, mutable: bool, row: u64, column: u64) : ASTNode(ASTNodeType::POINTER_TYPE, row, column) {
        (this.base_type, this.mutable) = (base_type, mutable);
    }
};

class ReferenceTypeNode : ASTNode {
    pub base_type: *const ASTNode,
    pub mutable: bool = false
} impl {
    ReferenceTypeNode(this: &mut ReferenceTypeNode, base_type: *const ASTNode, mutable: bool, row: u64, column: u64) : ASTNode(ASTNodeType::REFERENCE_TYPE, row, column) {
        (this.base_type, this.mutable) = (base_type, mutable);
    }
};

class ArrayTypeNode : ASTNode {
    pub element_type: *const ASTNode,
    pub size: *const ASTNode
} impl {
    ArrayTypeNode(this: &mut ArrayTypeNode, element_type: *const ASTNode, size: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::ARRAY_TYPE, row, column) {
        (this.element_type, this.size) = (element_type, size);
    }
};

class LiteralNode : ASTNode {
    pub value: String,
    pub literal_type: TokenType
} impl {
    LiteralNode(this: &mut LiteralNode, value: String, literal_type: TokenType, row: u64, column: u64) : ASTNode(ASTNodeType::LITERAL, row, column) {
        (this.value, this.literal_type) = (value, literal_type);
    }
};

class IdentifierNode : ASTNode {
    pub name: String
} impl {
    IdentifierNode(this: &mut IdentifierNode, name: String, row: u64, column: u64) : ASTNode(ASTNodeType::IDENTIFIER, row, column) {
        this.name = name;
    }
};

class ScopeResolutionNode : ASTNode {
    pub scope: *const ASTNode,
    pub identifier: *const IdentifierNode
} impl {
    ScopeResolutionNode(this: &mut ScopeResolutionNode, scope: *const ASTNode, identifier: *const IdentifierNode, row: u64, column: u64) : ASTNode(ASTNodeType::SCOPE_RESOLUTION, row, column) {
        (this.scope, this.identifier) = (scope, identifier);
    }
};

class BinaryOpNode : ASTNode {
    pub left: *const ASTNode,
    pub right: *const ASTNode,
    pub operator: TokenType
} impl {
    BinaryOpNode(this: &mut BinaryOpNode, left: *const ASTNode, right: *const ASTNode, operator: TokenType, row: u64, column: u64) : ASTNode(ASTNodeType::BINARY_OP, row, column) {
        (this.left, this.right, this.operator) = (left, right, operator);
    }
};

class UnaryOpNode : ASTNode {
    pub operand: *const ASTNode,
    pub operator: TokenType,
    pub mutable: bool = false
} impl {
    UnaryOpNode(this: &mut UnaryOpNode, operand: *const ASTNode, operator: TokenType, mutable: bool, row: u64, column: u64) : ASTNode(ASTNodeType::UNARY_OP, row, column) {
        (this.operand, this.operator, this.mutable) = (operand, operator, mutable);
    }
};

class TernaryNode : ASTNode {
    pub condition: *const ASTNode,
    pub then_expr: *const ASTNode,
    pub else_expr: *const ASTNode
} impl {
    TernaryNode(this: &mut TernaryNode, condition: *const ASTNode, then_expr: *const ASTNode, else_expr: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::TERNARY, row, column) {
        (this.condition, this.then_expr, this.else_expr) = (condition, then_expr, else_expr);
    }
};

class CallNode : ASTNode {
    pub expression: *const ASTNode,
    pub arguments: Vector<*const ASTNode>
} impl {
    CallNode(this: &mut CallNode, expression: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::CALL, row, column) {
        this.expression = expression;
    }
};

class MemberAccessNode : ASTNode {
    pub expression: *const ASTNode,
    pub member: String,
    pub arrow: bool = false
} impl {
    MemberAccessNode(this: &mut MemberAccessNode, expression: *const ASTNode, arrow: bool, row: u64, column: u64) : ASTNode(ASTNodeType::MEMBER_ACCESS, row, column) {
        (this.expression, this.arrow) = (expression, arrow);
    }
};

class IndexAccessNode : ASTNode {
    pub expression: *const ASTNode,
    pub index: *const ASTNode
} impl {
    IndexAccessNode(this: &mut IndexAccessNode, expression: *const ASTNode, index: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::INDEX_ACCESS, row, column) {
        (this.expression, this.index) = (expression, index);
    }
};

class CastNode : ASTNode {
    pub expression: *const ASTNode,
    pub target_type: *const ASTNode
} impl {
    CastNode(this: &mut CastNode, expression: *const ASTNode, target_type: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::CAST, row, column) {
        (this.expression, this.target_type) = (expression, target_type);
    }
};

class InitializerListNode : ASTNode {
    pub expressions: Vector<*const ASTNode>
} impl {
    InitializerListNode(this: &mut InitializerListNode, row: u64, column: u64) : ASTNode(ASTNodeType::INITIALIZER_LIST, row, column) {}
};

class NewNode : ASTNode {
    pub _type: *const ASTNode,
    pub arguments: Vector<*const ASTNode>,
    pub size: *const ASTNode = null
} impl {
    NewNode(this: &mut NewNode, _type: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::NEW, row, column) {
        this._type = _type;
    }
};

class DeleteNode : ASTNode {
    pub expression: *const ASTNode,
    pub array: bool = false
} impl {
    DeleteNode(this: &mut DeleteNode, row: u64, column: u64) : ASTNode(ASTNodeType::DELETE, row, column) {}
};

class ExpressionStmtNode : ASTNode {
    pub expression: *const ASTNode
} impl {
    ExpressionStmtNode(this: &mut ExpressionStmtNode, expression: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::EXPRESSION_STMT, row, column) {
        this.expression = expression;
    }
};

class VariableDeclNode : ASTNode {
    pub name: String,
    pub _type: *const ASTNode,
    pub initializer: *const ASTNode,
    pub mutable: bool = false,
    pub next: *const VariableDeclNode = null
} impl {
    VariableDeclNode(this: &mut VariableDeclNode, name: String, _type: *const ASTNode, initializer: *const ASTNode, mutable: bool, row: u64, column: u64) : ASTNode(ASTNodeType::VARIABLE_DECL, row, column) {
        (this.name, this._type, this.initializer, this.mutable) = (name, _type, initializer, mutable);
    }
};

class ConstantDeclNode : ASTNode {
    pub name: String,
    pub _type: *const ASTNode,
    pub initializer: *const ASTNode
} impl {
    ConstantDeclNode(this: &mut ConstantDeclNode, name: String, _type: *const ASTNode, initializer: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::CONSTANT_DECL, row, column) {
        (this.name, this._type, this.initializer) = (name, _type, initializer);
    }
};

class AssignmentNode : ASTNode {
    pub left: *const ASTNode,
    pub right: *const ASTNode,
    pub operator: TokenType,
    pub next: *const AssignmentNode = null
} impl {
    AssignmentNode(this: &mut AssignmentNode, left: *const ASTNode, right: *const ASTNode, operator: TokenType, row: u64, column: u64) : ASTNode(ASTNodeType::ASSIGNMENT, row, column) {
        (this.left, this.right, this.operator) = (left, right, operator);
    }
};

class IfStmtNode : ASTNode {
    pub condition: *const ASTNode,
    pub then_stmt: *const ASTNode,
    pub else_stmt: *const ASTNode
} impl {
    IfStmtNode(this: &mut IfStmtNode, condition: *const ASTNode, then_stmt: *const ASTNode, else_stmt: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::IF_STMT, row, column) {
        (this.condition, this.then_stmt, this.else_stmt) = (condition, then_stmt, else_stmt);
    }
};

class WhileStmtNode : ASTNode {
    pub condition: *const ASTNode,
    pub loop_stmt: *const ASTNode,
    pub else_stmt: *const ASTNode = null
} impl {
    WhileStmtNode(this: &mut WhileStmtNode, condition: *const ASTNode, loop_stmt: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::WHILE_STMT, row, column) {
        (this.condition, this.loop_stmt) = (condition, loop_stmt);
    }
};

class LoopStmtNode : ASTNode {
    pub loop_stmt: *const ASTNode
} impl {
    LoopStmtNode(this: &mut LoopStmtNode, loop_stmt: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::LOOP_STMT, row, column) {
        this.loop_stmt = loop_stmt;
    }
};

class ReturnStmtNode : ASTNode {
    pub expression: *const ASTNode
} impl {
    ReturnStmtNode(this: &mut ReturnStmtNode, expression: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::RETURN_STMT, row, column) {
        this.expression = expression;
    }
};

class BreakStmtNode : ASTNode {} impl {
    BreakStmtNode(this: &mut BreakStmtNode, row: u64, column: u64) : ASTNode(ASTNodeType::BREAK_STMT, row, column) {}
};

class ContinueStmtNode : ASTNode {} impl {
    ContinueStmtNode(this: &mut ContinueStmtNode, row: u64, column: u64) : ASTNode(ASTNodeType::CONTINUE_STMT, row, column) {}
};

class BlockStmtNode : ASTNode {
    pub statements: Vector<*const ASTNode>
} impl {
    BlockStmtNode(this: &mut BlockStmtNode, row: u64, column: u64) : ASTNode(ASTNodeType::BLOCK_STMT, row, column) {}
};

class ParameterNode : ASTNode {
    pub name: String,
    pub param_type: *const ASTNode,
    pub mutable: bool = false
} impl {
    ParameterNode(this: &mut ParameterNode, name: String, param_type: *const ASTNode, mutable: bool, row: u64, column: u64) : ASTNode(ASTNodeType::PARAMETER, row, column) {
        (this.name, this.param_type, this.mutable) = (name, param_type, mutable);
    }
};

class FunctionTypeNode : ASTNode {
    pub parameters: Vector<*const ParameterNode>,
    pub return_type: *const ASTNode,
    pub var_arg: bool = false
} impl {
    FunctionTypeNode(this: &mut FunctionTypeNode, row: u64, column: u64) : ASTNode(ASTNodeType::FUNCTION_TYPE, row, column) {}
};

class FunctionDeclNode : ASTNode {
    pub name: String,
    pub _type: *const FunctionTypeNode,
    pub body: *const BlockStmtNode,
    pub generic: bool = false,
    pub types: Vector<String>,
    pub constructors: Vector<*const CallNode>
} impl {
    FunctionDeclNode(this: &mut FunctionDeclNode, name: String, _type: *const FunctionTypeNode, body: *const BlockStmtNode, row: u64, column: u64) : ASTNode(ASTNodeType::FUNCTION_DECL, row, column) {
        (this.name, this._type, this.body) = (name, _type, body);
    }
};

class TypeDeclNode : ASTNode {
    pub name: String,
    pub _type: *const ASTNode
} impl {
    TypeDeclNode(this: &mut TypeDeclNode, name: String, _type: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::TYPE_DECL, row, column) {
        (this.name, this._type) = (name, _type);
    }
};

class FieldNode : ASTNode {
    pub name: String,
    pub field_type: *const ASTNode,
    pub initializer: *const ASTNode
} impl {
    FieldNode(this: &mut FieldNode, name: String, field_type: *const ASTNode, initializer: *const ASTNode, row: u64, column: u64) : ASTNode(ASTNodeType::FIELD, row, column) {
        (this.name, this.field_type, this.initializer) = (name, field_type, initializer);
    }
};

class ClassDeclNode : ASTNode {
    pub name: String,
    pub fields: Vector<Pair<TokenType, *const FieldNode>>,
    pub methods: Vector<Pair<TokenType, *const FunctionDeclNode>>,
    pub constructors: Vector<*const FunctionDeclNode>,
    pub destructor: *const FunctionDeclNode = null,
    pub parents: Vector<*const ASTNode>,
    pub generic: bool = false,
    pub types: Vector<String>
} impl {
    ClassDeclNode(this: &mut ClassDeclNode, name: String, row: u64, column: u64) : ASTNode(ASTNodeType::CLASS_DECL, row, column) {
        this.name = name;
    }
};

class EnumDeclNode : ASTNode {
    pub name: String,
    pub values: Map<String, *const ASTNode>,
    pub underlying_type: *const ASTNode
} impl {
    EnumDeclNode(this: &mut EnumDeclNode, name: String, row: u64, column: u64) : ASTNode(ASTNodeType::ENUM_DECL, row, column) {
        this.name = name;
    }
};

class ExternBlockNode : ASTNode {
    pub linkage: String,
    pub declarations: Vector<*const ASTNode>
} impl {
    ExternBlockNode(this: &mut ExternBlockNode, linkage: String, row: u64, column: u64) : ASTNode(ASTNodeType::EXTERN_BLOCK, row, column) {
        this.linkage = linkage;
    }
};

class RootNode : ASTNode {
    pub declarations: Vector<*const ASTNode>
} impl {
    RootNode(this: &mut RootNode) : ASTNode(ASTNodeType::ROOT, 1u64, 1u64) {}
};

class Parser {
    priv root: *mut RootNode = null,
    priv types: Vector<String>,
    pub include_paths: Vector<String>,
    priv included_paths: Vector<String>,
    priv file: String, priv index: u64,
    priv tokens: Vector<Token>
} impl {
    priv CurrentToken(this: &Parser) -> Token {
        if this.index >= this.tokens.Size() {
            ret this.tokens[this.tokens.Size() - 1u64];
        } else {
            ret this.tokens[this.index];
        }
    }

    priv PeekToken(this: &Parser, offset: u64) -> Token {
        let index: u64 = this.index + offset;

        if index >= this.tokens.Size() {
            ret this.tokens[this.tokens.Size() - 1u64];
        } else {
            ret this.tokens[index];
        }
    }

    priv Advance(this: &mut Parser) -> Token {
        let token: Token = this.CurrentToken();

        if this.index < this.tokens.Size() {
            this.index += 1u64;
        } ret token;
    }

    priv Match(this: &mut Parser, _type: TokenType) -> bool {
        if this.CurrentToken()._type == _type {
            this.Advance();
            ret true;
        } else {
            ret false;
        }
    }

    priv Expect(this: &mut Parser, _type: TokenType) -> Token {
        let token: Token = this.CurrentToken();

        if token._type != _type {
            this.Error((String("Expected '") + TokenTypeToString(_type) + "' but got '" + TokenTypeToString(token._type) + "'").Data(), token.row, token.column);
        } else {
            this.Advance();
        } ret token;
    }

    priv GetBinaryOpPrecedence(this: &Parser, _type: TokenType) -> i32 {
        if _type == TokenType::OR { ret 1i32; }
        else if _type == TokenType::AND { ret 2i32; }
        else if _type == TokenType::BITWISE_OR { ret 3i32; }
        else if _type == TokenType::BITWISE_XOR { ret 4i32; }
        else if _type == TokenType::BITWISE_AND { ret 5i32; }
        else if _type == TokenType::EQUAL || _type == TokenType::NOT_EQUAL { ret 6i32; }
        else if _type == TokenType::LESS || _type == TokenType::LESS_EQUAL || _type == TokenType::GREATER || _type == TokenType::GREATER_EQUAL { ret 7i32; }
        else if _type == TokenType::LSHIFT || _type == TokenType::RSHIFT { ret 8i32; }
        else if _type == TokenType::PLUS || _type == TokenType::MINUS { ret 9i32; }
        else if _type == TokenType::MUL || _type == TokenType::DIV || _type == TokenType::MOD { ret 10i32; }
        else if _type == TokenType::AS { ret 11i32; }
        else { ret -1i32; }
    }

    priv IsBinaryOperator(this: &Parser, _type: TokenType) -> bool {
        let precedence: i32 = this.GetBinaryOpPrecedence(_type);
        ret precedence >= 0i32 && precedence != 11i32;
    }

    priv IsUnaryOperator(this: &Parser, _type: TokenType) -> bool {
        ret _type == TokenType::NOT || _type == TokenType::MINUS || _type == TokenType::BITWISE_AND || _type == TokenType::MUL;
    }

    priv IsAssignmentOperator(this: &Parser, _type: TokenType) -> bool {
        ret _type == TokenType::ASSIGN || _type == TokenType::PLUS_ASSIGN || _type == TokenType::MINUS_ASSIGN || _type == TokenType::MUL_ASSIGN || _type == TokenType::DIV_ASSIGN || _type == TokenType::MOD_ASSIGN
           || _type == TokenType::LSHIFT_ASSIGN || _type == TokenType::RSHIFT_ASSIGN || _type == TokenType::AND_ASSIGN || _type == TokenType::OR_ASSIGN || _type == TokenType::XOR_ASSIGN;
    }

    priv ParsePrimary(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::INTEGER || token._type == TokenType::FLOAT || token._type == TokenType::STRING || token._type == TokenType::CHAR || token._type == TokenType::TRUE || token._type == TokenType::FALSE || token._type == TokenType::NULL {
            this.Advance();
            ret new LiteralNode(token.value, token._type, token.row, token.column) as *const ASTNode;
        } else if token._type == TokenType::NAME || token._type == TokenType::OPERATOR || token._type == TokenType::DOUBLE_COLON {
            let mut node: *const ASTNode = null;

            if token._type != TokenType::DOUBLE_COLON {
                if this.types.Index(token.value) != -1i64 && this.PeekToken(1u64)._type != TokenType::DOUBLE_COLON {
                    node = this.ParseType();
                } else {
                    if this.Match(TokenType::OPERATOR) {
                        let mut identifier: String = "op";

                        while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                            identifier += this.CurrentToken().value;
                            this.Advance();
                        }

                        node = new IdentifierNode(identifier, token.row, token.column) as *const ASTNode;
                    } else {
                        node = new IdentifierNode(this.Expect(TokenType::NAME).value, token.row, token.column) as *const ASTNode;
                    }
                }
            }

            while this.Match(TokenType::DOUBLE_COLON) {
                let mut id_node: *const IdentifierNode = null;

                if this.Match(TokenType::OPERATOR) {
                    let mut identifier: String = "op";

                    while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                        identifier += this.CurrentToken().value;
                        this.Advance();
                    }

                    id_node = new IdentifierNode(identifier, token.row, token.column);
                } else {
                    id_node = new IdentifierNode(this.Expect(TokenType::NAME).value, token.row, token.column);
                } node = new ScopeResolutionNode(node, id_node, token.row, token.column) as *const ASTNode;
            } ret node;
        } else if token._type == TokenType::LBRACE {
            this.Advance();
            let initializer_list: *mut InitializerListNode = new InitializerListNode(token.row, token.column);

            if !this.Match(TokenType::RBRACE) {
                initializer_list->expressions.PushBack(this.ParseExpression());

                while this.Match(TokenType::COMMA) {
                    initializer_list->expressions.PushBack(this.ParseExpression());
                } this.Expect(TokenType::RBRACE);
            } ret initializer_list as *const ASTNode;
        } else if token._type == TokenType::LPAREN {
            this.Advance();
            let expr: *const ASTNode = this.ParseExpression();
            this.Expect(TokenType::RPAREN);
            ret expr;
        } else {
            this.Error((String("Unexpected token '") + token.value + "'").Data(), token.row, token.column);
            ret null;
        }
    }

    priv ParsePostfix(this: &mut Parser) -> *const ASTNode {
        let mut expr: *const ASTNode = this.ParsePrimary();

        loop {
            let token: Token = this.CurrentToken();

            if token._type == TokenType::LPAREN {
                this.Advance();
                let call: *mut CallNode = new CallNode(expr, token.row, token.column);

                if !this.Match(TokenType::RPAREN) {
                    call->arguments.PushBack(this.ParseExpression());

                    while this.Match(TokenType::COMMA) {
                        call->arguments.PushBack(this.ParseExpression());
                    } this.Expect(TokenType::RPAREN);
                } expr = call as *const ASTNode;
            } else if token._type == TokenType::DOT || token._type == TokenType::ARROW {
                this.Advance();
                let member_access: *mut MemberAccessNode = new MemberAccessNode(expr, token._type == TokenType::ARROW, token.row, token.column);

                if this.Match(TokenType::OPERATOR) {
                    member_access->member += "op";

                    while this.CurrentToken()._type != TokenType::LPAREN && this.CurrentToken()._type != TokenType::LESS {
                        member_access->member += this.CurrentToken().value;
                        this.Advance();
                    }
                } else {
                    member_access->member += this.Expect(TokenType::NAME).value;
                } expr = member_access as *const ASTNode;
            } else if token._type == TokenType::LBRACKET {
                this.Advance();
                let index_access: *const IndexAccessNode = new IndexAccessNode(expr, this.ParseExpression(), token.row, token.column);
                this.Expect(TokenType::RBRACKET);
                expr = index_access as *const ASTNode;
            } else {
                break;
            }
        } ret expr;
    }

    priv ParseUnary(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.CurrentToken();
        let mut mutable: bool = false;

        if this.IsUnaryOperator(token._type) {
            this.Advance();

            if token._type == TokenType::BITWISE_AND {
                mutable = this.Match(TokenType::MUT);
            }

            ret new UnaryOpNode(this.ParseUnary(), token._type, mutable, token.row, token.column) as *const ASTNode;
        } else if token._type == TokenType::NEW {
            this.Advance();
            let _new: *mut NewNode = new NewNode(this.ParseType(), token.row, token.column);

            if this.Match(TokenType::LBRACKET) {
                _new->size = this.ParseExpression();
                this.Expect(TokenType::RBRACKET);
            } else if this.Match(TokenType::LPAREN) {
                if !this.Match(TokenType::RPAREN) {
                    _new->arguments.PushBack(this.ParseExpression());

                    while this.Match(TokenType::COMMA) {
                        _new->arguments.PushBack(this.ParseExpression());
                    } this.Expect(TokenType::RPAREN);
                }
            } ret _new as *const ASTNode;
        } else if token._type == TokenType::DELETE {
            this.Advance();
            let delete: *mut DeleteNode = new DeleteNode(token.row, token.column);

            if this.Match(TokenType::LBRACKET) {
                delete->array = true;
                this.Expect(TokenType::RBRACKET);
            }

            delete->expression = this.ParseExpression();
            ret delete as *const ASTNode;
        } else {
            ret this.ParsePostfix();
        }
    }

    priv ParseBinaryExpression(this: &mut Parser, min_precedence: i32) -> *const ASTNode {
        let mut left: *const ASTNode = this.ParseUnary();

        loop {
            let mut token: Token = this.CurrentToken();

            if this.PeekToken(1u64)._type == token._type {
                if token._type == TokenType::GREATER {
                    token._type = TokenType::RSHIFT;
                    this.Advance();
                }

                if token._type == TokenType::LESS {
                    token._type = TokenType::LSHIFT;
                    this.Advance();
                }
            }

            let precedence: i32 = this.GetBinaryOpPrecedence(token._type);
            if precedence < min_precedence { break; }
            this.Advance();

            if token._type == TokenType::AS {
                left = new CastNode(left, this.ParseType(), token.row, token.column) as *const ASTNode;
            } else {
                left = new BinaryOpNode(left, this.ParseBinaryExpression(precedence + 1i32), token._type, token.row, token.column) as *const ASTNode;
            }
        } ret left;
    }

    priv ParseExpression(this: &mut Parser) -> *const ASTNode {
        let mut condition: *const ASTNode = this.ParseBinaryExpression(0i32);
        let token: Token = this.CurrentToken();

        if token._type == TokenType::QUESTION_MARK {
            this.Advance();
            let then_expr: *const ASTNode = this.ParseExpression();
            this.Expect(TokenType::COLON);
            let else_expr: *const ASTNode = this.ParseExpression();
            condition = new TernaryNode(condition, then_expr, else_expr, token.row, token.column) as *const ASTNode;
        } ret condition;
    }

    priv ParseType(this: &mut Parser) -> *const ASTNode {
        let mut references: Vector<bool>;
        let mut pointers: Vector<bool>;
        let mut node: *const ASTNode = null;

        if this.Match(TokenType::BITWISE_AND) {
            references.PushBack(this.Match(TokenType::MUT));
        }

        while this.Match(TokenType::MUL) {
            if this.Match(TokenType::MUT) {
                pointers.PushBack(true);
            } else {
                this.Expect(TokenType::CONST);
                pointers.PushBack(false);
            }
        }

        let token: Token = this.CurrentToken();

        if this.Match(TokenType::FUNC) {
            this.Expect(TokenType::LPAREN);
            let func_type: *mut FunctionTypeNode = new FunctionTypeNode(token.row, token.column);

            if this.CurrentToken()._type != TokenType::RPAREN {
                let mut param: *const ParameterNode = this.ParseParameter(func_type);
                if param != null { func_type->parameters.PushBack(param); }

                while this.Match(TokenType::COMMA) {
                    param = this.ParseParameter(func_type);
                    if param != null { func_type->parameters.PushBack(param); }
                }
            }

            this.Expect(TokenType::RPAREN);

            if this.Match(TokenType::ARROW) {
                func_type->return_type = this.ParseType();
            } else {
                func_type->return_type = new PrimitiveTypeNode({ "void" } as String, token.row, token.column) as *const ASTNode;
            } node = func_type as *const ASTNode;
        } else {
            if token._type != TokenType::NAME {
                this.Error("Expected type name", token.row, token.column);
                ret null;
            }

            let primitive: *mut PrimitiveTypeNode = new PrimitiveTypeNode(token.value, token.row, token.column);
            this.Advance();

            if this.Match(TokenType::LESS) {
                primitive->types.PushBack(this.ParseType());

                while this.Match(TokenType::COMMA) {
                    primitive->types.PushBack(this.ParseType());
                }

                this.Expect(TokenType::GREATER);
                primitive->generic = true;
            } node = primitive as *const ASTNode;
        }

        let mut index: u64 = pointers.Size();

        while 0u64 < index {
            node = new PointerTypeNode(node, pointers[index - 1u64], token.row, token.column) as *const ASTNode;
            index -= 1u64;
        }

        if references.Size() != 0u64 {
            node = new ReferenceTypeNode(node, references[0u64], token.row, token.column) as *const ASTNode;
        } ret node;
    }

    priv ParseStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::LET {
            ret this.ParseVariableDeclaration();
        } else if token._type == TokenType::IF {
            ret this.ParseIfStatement();
        } else if token._type == TokenType::WHILE {
            ret this.ParseWhileStatement();
        } else if token._type == TokenType::LOOP {
            ret this.ParseLoopStatement();
        } else if token._type == TokenType::RETURN {
            ret this.ParseReturnStatement();
        } else if token._type == TokenType::BREAK {
            this.Advance();
            this.Expect(TokenType::SEMICOLON);
            ret new BreakStmtNode(token.row, token.column) as *const ASTNode;
        } else if token._type == TokenType::CONTINUE {
            this.Advance();
            this.Expect(TokenType::SEMICOLON);
            ret new ContinueStmtNode(token.row, token.column) as *const ASTNode;
        } else if token._type == TokenType::LBRACE {
            ret this.ParseBlockStatement();
        } else {
            if this.Match(TokenType::LPAREN) {
                let mut current: *mut AssignmentNode = null;
                let mut root: *const AssignmentNode = null;
                let index: u64 = this.index;

                while root == null || this.Match(TokenType::COMMA) {
                    let assignment: *const AssignmentNode = new AssignmentNode(this.ParseExpression(), null, TokenType::ASSIGN, token.row, token.column);

                    if root != null {
                        current->next = assignment;
                    } else {
                        root = assignment;
                    } current = assignment;
                }

                if root->next != null {
                    this.Expect(TokenType::RPAREN);
                    this.Expect(TokenType::ASSIGN);
                    this.Expect(TokenType::LPAREN);
                    current = root;

                    while current != null {
                        current->right = this.ParseExpression();

                        if current->next != null {
                            this.Expect(TokenType::COMMA);
                        } current = current->next;
                    }

                    this.Expect(TokenType::RPAREN);
                    this.Expect(TokenType::SEMICOLON);
                    ret root as *const ASTNode;
                } else {
                    this.index = index;
                }
            }

            let expr: *const ASTNode = this.ParseExpression();

            if this.IsAssignmentOperator(this.CurrentToken()._type) {
                let token: Token = this.Advance();
                let assignment: *const AssignmentNode = new AssignmentNode(expr, this.ParseExpression(), token._type, token.row, token.column);
                this.Expect(TokenType::SEMICOLON);
                ret assignment as *const ASTNode;
            } else {
                this.Expect(TokenType::SEMICOLON);
                ret new ExpressionStmtNode(expr, token.row, token.column) as *const ASTNode;
            }
        }
    }

    priv ParseConstantDeclaration(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::CONST);
        let name_token: Token = this.Expect(TokenType::NAME);
        let mut sizes: Vector<*const ASTNode>;

        while this.Match(TokenType::LBRACKET) {
            if this.Match(TokenType::RBRACKET) {
                sizes.PushBack(null);
            } else {
                sizes.PushBack(this.ParseExpression());
                this.Expect(TokenType::RBRACKET);
            }
        }

        this.Expect(TokenType::COLON);
        let mut _type: *const ASTNode = this.ParseType();
        let mut i: u64 = 0u64;

        while i < sizes.Size() {
            _type = new ArrayTypeNode(_type, sizes[i], token.row, token.column) as *const ASTNode;
            i += 1u64;
        }

        this.Expect(TokenType::ASSIGN);
        let initializer: *const ASTNode = this.ParseExpression();
        this.Expect(TokenType::SEMICOLON);
        ret new ConstantDeclNode(name_token.value, _type, initializer, token.row, token.column) as *const ASTNode;
    }

    priv ParseVariableDeclaration(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::LET);
        let multiple: bool = this.Match(TokenType::LPAREN);
        let mut current: *mut VariableDeclNode = null;
        let mut root: *const VariableDeclNode = null;

        while root == null || (multiple && root != null && this.Match(TokenType::COMMA)) {
            let mutable: bool = this.Match(TokenType::MUT);
            let name_token: Token = this.Expect(TokenType::NAME);
            let mut sizes: Vector<*const ASTNode>;

            while this.Match(TokenType::LBRACKET) {
                if this.Match(TokenType::RBRACKET) {
                    sizes.PushBack(null);
                } else {
                    sizes.PushBack(this.ParseExpression());
                    this.Expect(TokenType::RBRACKET);
                }
            }

            this.Expect(TokenType::COLON);
            let mut _type: *const ASTNode = this.ParseType();
            let mut i: u64 = 0u64;

            while i < sizes.Size() {
                _type = new ArrayTypeNode(_type, sizes[i], token.row, token.column) as *const ASTNode;
                i += 1u64;
            }

            let decl: *const VariableDeclNode = new VariableDeclNode(name_token.value, _type, null, mutable, token.row, token.column);

            if root != null {
                current->next = decl;
            } else {
                root = decl;
            } current = decl;
        }

        if multiple {
            this.Expect(TokenType::RPAREN);
        }

        if this.Match(TokenType::ASSIGN) {
            if multiple {
                this.Expect(TokenType::LPAREN);
            } current = root;

            while current != null {
                current->initializer = this.ParseExpression();

                if current->initializer->node_type == ASTNodeType::INITIALIZER_LIST {
                    let list: *const InitializerListNode = current->initializer as *const InitializerListNode;

                    if current->_type->node_type == ASTNodeType::ARRAY_TYPE {
                        let array_type: *mut ArrayTypeNode = current->_type as *const ArrayTypeNode;

                        if array_type->size == null {
                            let size[32u64]: i8;
                            sprintf(size, "%llu", list->expressions.Size());
                            array_type->size = new LiteralNode(String(size) + "u64", TokenType::INTEGER, token.row, token.column) as *const ASTNode;
                        }
                    }
                }

                if current->next != null {
                    this.Expect(TokenType::COMMA);
                } current = current->next;
            }

            if multiple {
                this.Expect(TokenType::RPAREN);
            }
        }

        this.Expect(TokenType::SEMICOLON);
        ret root as *const ASTNode;
    }

    priv ParseIfStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::IF);
        let condition: *const ASTNode = this.ParseExpression();
        let then_stmt: *const ASTNode = this.ParseBlockStatement();
        let mut else_stmt: *const ASTNode = null;

        if this.Match(TokenType::ELSE) {
            else_stmt = this.ParseStatement();
        }

        ret new IfStmtNode(condition, then_stmt, else_stmt, token.row, token.column) as *const ASTNode;
    }

    priv ParseWhileStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::WHILE);
        let _while: *mut WhileStmtNode = new WhileStmtNode(this.ParseExpression(), this.ParseBlockStatement(), token.row, token.column);

        if this.Match(TokenType::ELSE) {
            _while->else_stmt = this.ParseBlockStatement();
        } ret _while as *const ASTNode;
    }

    priv ParseLoopStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::LOOP);
        ret new LoopStmtNode(this.ParseBlockStatement(), token.row, token.column) as *const ASTNode;
    }

    priv ParseReturnStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::RETURN);
        let mut value: *const ASTNode = null;

        if this.CurrentToken()._type != TokenType::SEMICOLON {
            value = this.ParseExpression();
        }

        this.Expect(TokenType::SEMICOLON);
        ret new ReturnStmtNode(value, token.row, token.column) as *const ASTNode;
    }

    priv ParseBlockStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::LBRACE);
        let block: *mut BlockStmtNode = new BlockStmtNode(token.row, token.column);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            let stmt: *const ASTNode = this.ParseStatement();

            if stmt != null {
                block->statements.PushBack(stmt);
            }
        }

        this.Expect(TokenType::RBRACE);
        ret block as *const ASTNode;
    }

    priv ParseDeclaration(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.CurrentToken();

        if token._type == TokenType::FUNC {
            ret this.ParseFunctionDeclaration();
        } else if token._type == TokenType::CLASS {
            ret this.ParseClassDeclaration();
        } else if token._type == TokenType::ENUM {
            ret this.ParseEnumDeclaration();
        } else if token._type == TokenType::EXTERN {
            ret this.ParseExternBlock();
        } else if token._type == TokenType::INCLUDE {
            ret this.ParseIncludeStatement();
        } else if token._type == TokenType::CONST {
            ret this.ParseConstantDeclaration();
        } else if token._type == TokenType::TYPE {
            ret this.ParseTypeDeclaration();
        } else {
            this.Error("Expected declaration", token.row, token.column);
            ret null;
        }
    }

    priv ParseTypeDeclaration(this: &mut Parser) -> *const ASTNode {
        let type_token: Token = this.Expect(TokenType::TYPE);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), type_token.row, type_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        this.Expect(TokenType::ASSIGN);
        let type_decl: *const TypeDeclNode = new TypeDeclNode(name_token.value, this.ParseType(), type_token.row, type_token.column);
        this.Expect(TokenType::SEMICOLON);
        ret type_decl as *const ASTNode;
    }

    priv ParseFunctionDeclaration(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.CurrentToken();
        let mut name: String;

        if token._type == TokenType::TILDE || token._type == TokenType::FUNC || token._type == TokenType::PUBLIC || token._type == TokenType::PRIVATE {
            this.Advance();

            if token._type == TokenType::TILDE {
                name += token.value;
            }
        }

        if this.Match(TokenType::OPERATOR) {
            name += "op";

            while this.CurrentToken()._type != TokenType::LPAREN {
                name += this.CurrentToken().value;
                this.Advance();
            }
        } else {
            name += this.Expect(TokenType::NAME).value;
        }

        let func_type: *mut FunctionTypeNode = new FunctionTypeNode(token.row, token.column);
        let func_decl: *mut FunctionDeclNode = new FunctionDeclNode(name, func_type, null, token.row, token.column);

        if this.Match(TokenType::LESS) {
            func_decl->types.PushBack(this.Expect(TokenType::NAME).value);

            while this.Match(TokenType::COMMA) {
                func_decl->types.PushBack(this.Expect(TokenType::NAME).value);
            }

            this.Expect(TokenType::GREATER);
            func_decl->generic = true;
        }

        this.Expect(TokenType::LPAREN);

        if this.CurrentToken()._type != TokenType::RPAREN {
            let mut param: *const ParameterNode = this.ParseParameter(func_type);
            if param != null { func_type->parameters.PushBack(param); }

            while this.Match(TokenType::COMMA) {
                param = this.ParseParameter(func_type);
                if param != null { func_type->parameters.PushBack(param); }
            }
        }

        this.Expect(TokenType::RPAREN);

        if this.Match(TokenType::ARROW) {
            func_type->return_type = this.ParseType();
        } else {
            func_type->return_type = new PrimitiveTypeNode({ "void" } as String, token.row, token.column) as *const ASTNode;

            if token._type != TokenType::FUNC && token._type != TokenType::PUBLIC && token._type != TokenType::PRIVATE {
                while (this.Match(TokenType::COLON) && func_decl->constructors.Size() == 0u64) || (this.Match(TokenType::COMMA) && func_decl->constructors.Size() > 0u64) {
                    let expression: *const ASTNode = this.ParseExpression();

                    if expression->node_type == ASTNodeType::CALL {
                        func_decl->constructors.PushBack(expression as *const CallNode);
                    } else {
                        this.Error("Expected a function call", token.row, token.column);
                        break;
                    }
                }
            }
        }

        if this.CurrentToken()._type == TokenType::LBRACE {
            func_decl->body = this.ParseBlockStatement() as *const BlockStmtNode;
        } else {
            this.Expect(TokenType::SEMICOLON);
        } ret func_decl as *const ASTNode;
    }

    priv ParseParameter(this: &mut Parser, func_type: *mut FunctionTypeNode) -> *const ParameterNode {
        func_type->var_arg = this.Match(TokenType::THREE_DOT);
        if func_type->var_arg { ret null; }

        let mutable: bool = this.Match(TokenType::MUT);

        if this.PeekToken(1u64)._type == TokenType::COLON || this.PeekToken(1u64)._type == TokenType::LBRACKET {
            let token: Token = this.Expect(TokenType::NAME);
            let mut sizes: Vector<*const ASTNode>;

            while this.Match(TokenType::LBRACKET) {
                if this.Match(TokenType::RBRACKET) {
                    sizes.PushBack(null);
                } else {
                    sizes.PushBack(this.ParseExpression());
                    this.Expect(TokenType::RBRACKET);
                }
            }

            this.Expect(TokenType::COLON);
            let mut param_type: *const ASTNode = this.ParseType();
            let mut i: u64 = 0u64;

            while i < sizes.Size() {
                param_type = new ArrayTypeNode(param_type, sizes[i], token.row, token.column) as *const ASTNode;
                i += 1u64;
            }

            ret new ParameterNode(token.value, param_type, mutable, token.row, token.column);
        } else {
            let token: Token = this.CurrentToken();
            ret new ParameterNode(String(""), this.ParseType(), mutable, token.row, token.column);
        }
    }

    priv ParseClassDeclaration(this: &mut Parser) -> *const ASTNode {
        let class_token: Token = this.Expect(TokenType::CLASS);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), class_token.row, class_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        let class_decl: *mut ClassDeclNode = new ClassDeclNode(name_token.value, class_token.row, class_token.column);

        if this.Match(TokenType::LESS) {
            class_decl->types.PushBack(this.Expect(TokenType::NAME).value);

            while this.Match(TokenType::COMMA) {
                class_decl->types.PushBack(this.Expect(TokenType::NAME).value);
            }

            this.Expect(TokenType::GREATER);
            class_decl->generic = true;
        }

        if this.Match(TokenType::COLON) {
            class_decl->parents.PushBack(this.ParseType());

            while this.Match(TokenType::COMMA) {
                class_decl->parents.PushBack(this.ParseType());
            }
        }

        this.Expect(TokenType::LBRACE);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            let visibility_token: Token = this.CurrentToken();

            if visibility_token._type == TokenType::PUBLIC || visibility_token._type == TokenType::PRIVATE {
                this.Advance();
            } else {
                this.Error("Expected visibility modifier", visibility_token.row, visibility_token.column);
                break;
            }

            let member_token: Token = this.CurrentToken();

            if member_token._type == TokenType::NAME {
                class_decl->fields.PushBack(Pair<TokenType, *const FieldNode>(visibility_token._type, this.ParseField()));
            } else {
                this.Error("Expected field declaration", member_token.row, member_token.column);
                break;
            }
        }

        this.Expect(TokenType::RBRACE);

        if this.Match(TokenType::IMPL) {
            this.Expect(TokenType::LBRACE);

            while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
                let visibility_token: Token = this.CurrentToken();

                if visibility_token._type == TokenType::PUBLIC || visibility_token._type == TokenType::PRIVATE {
                    class_decl->methods.PushBack(Pair<TokenType, *const FunctionDeclNode>(visibility_token._type, this.ParseFunctionDeclaration() as *const FunctionDeclNode));
                } else {
                    if this.CurrentToken()._type == TokenType::TILDE {
                        if class_decl->destructor != null {
                            this.Error("Multiple destructor declarations are not allowed", visibility_token.row, visibility_token.column);
                            break;
                        }

                        class_decl->destructor = this.ParseFunctionDeclaration() as *const FunctionDeclNode;
                    } else {
                        class_decl->constructors.PushBack(this.ParseFunctionDeclaration() as *const FunctionDeclNode);
                    }
                }
            }

            this.Expect(TokenType::RBRACE);
        }

        this.Expect(TokenType::SEMICOLON);
        ret class_decl as *const ASTNode;
    }

    priv ParseField(this: &mut Parser) -> *const FieldNode {
        let token: Token = this.Expect(TokenType::NAME);
        let mut sizes: Vector<*const ASTNode>;

        while this.Match(TokenType::LBRACKET) {
            if this.Match(TokenType::RBRACKET) {
                sizes.PushBack(null);
            } else {
                sizes.PushBack(this.ParseExpression());
                this.Expect(TokenType::RBRACKET);
            }
        }

        this.Expect(TokenType::COLON);
        let mut field_type: *const ASTNode = this.ParseType();
        let mut initializer: *const ASTNode = null;
        let mut i: u64 = 0u64;

        while i < sizes.Size() {
            field_type = new ArrayTypeNode(field_type, sizes[i], token.row, token.column) as *const ASTNode;
            i += 1u64;
        }

        if this.Match(TokenType::ASSIGN) {
            initializer = this.ParseExpression();
        }

        if this.CurrentToken()._type == TokenType::SEMICOLON {
            this.Advance();
        } else if this.CurrentToken()._type == TokenType::COMMA {
            this.Advance();
        }

        ret new FieldNode(token.value, field_type, initializer, token.row, token.column);
    }

    priv ParseEnumDeclaration(this: &mut Parser) -> *const ASTNode {
        let enum_token: Token = this.Expect(TokenType::ENUM);
        let name_token: Token = this.Expect(TokenType::NAME);

        if this.types.Index(name_token.value) != -1i64 {
            this.Error((String("Type '") + name_token.value + "' is overloaded").Data(), enum_token.row, enum_token.column);
        } else {
            this.types.PushBack(name_token.value);
        }

        let enum_decl: *mut EnumDeclNode = new EnumDeclNode(name_token.value, enum_token.row, enum_token.column);

        if this.Match(TokenType::COLON) {
            let _type: *const ASTNode = this.ParseType();
            enum_decl->underlying_type = _type;
        } else {
            enum_decl->underlying_type = new PrimitiveTypeNode({ "i32" } as String, enum_token.row, enum_token.column) as *const ASTNode;
        }

        this.Expect(TokenType::LBRACE);

        if this.CurrentToken()._type != TokenType::RBRACE {
            let mut name_token: Token = this.Expect(TokenType::NAME);

            if this.Match(TokenType::ASSIGN) {
                enum_decl->values[name_token.value] = this.ParseExpression();
            } else {
                enum_decl->values[name_token.value] = null;
            }

            while this.Match(TokenType::COMMA) {
                name_token = this.Expect(TokenType::NAME);

                if this.Match(TokenType::ASSIGN) {
                    enum_decl->values[name_token.value] = this.ParseExpression();
                } else {
                    enum_decl->values[name_token.value] = null;
                }
            }
        }

        this.Expect(TokenType::RBRACE);
        this.Match(TokenType::SEMICOLON);
        ret enum_decl as *const ASTNode;
    }

    priv ParseExternBlock(this: &mut Parser) -> *const ASTNode {
        let extern_token: Token = this.Expect(TokenType::EXTERN);
        let linkage_token: Token = this.Expect(TokenType::STRING);
        let extern_block: *mut ExternBlockNode = new ExternBlockNode(linkage_token.value, extern_token.row, extern_token.column);
        this.Expect(TokenType::LBRACE);

        while this.CurrentToken()._type != TokenType::RBRACE && this.CurrentToken()._type != TokenType::EOF {
            if this.CurrentToken()._type == TokenType::FUNC {
                extern_block->declarations.PushBack(this.ParseFunctionDeclaration());
            } else {
                this.Error("Only function declarations allowed in extern block", this.CurrentToken().row, this.CurrentToken().column);
            }
        }

        this.Expect(TokenType::RBRACE);
        ret extern_block as *const ASTNode;
    }

    priv ParseIncludeStatement(this: &mut Parser) -> *const ASTNode {
        let token: Token = this.Expect(TokenType::INCLUDE);
        let mut modules: Vector<String>;

        while this.Match(TokenType::COMMA) || modules.Size() == 0u64 {
            modules.PushBack(this.Expect(TokenType::STRING).value);
        }

        this.Expect(TokenType::COLON);
        this.Expect(TokenType::MUL);
        this.Expect(TokenType::SEMICOLON);
        let mut i: u64 = 0u64;

        while i < modules.Size() {
            let (mut found: bool, mut j: u64) = (false, 0u64);
            let module: String = modules[i];

            while j < this.include_paths.Size() {
                let mut path: String = this.include_paths[j] + "\\" + modules[i];
                let attr: DWORD = GetFileAttributesA(path.Data());
                j += 1u64;

                if attr == INVALID_FILE_ATTRIBUTES {
                    continue;
                }

                if (attr & FILE_ATTRIBUTE_DIRECTORY) != 0u32 {
                    path += "\\Entry.div";

                    if GetFileAttributesA(path.Data()) == INVALID_FILE_ATTRIBUTES {
                        this.Error((String("Module '") + module + "' entry point not found").Data(), token.row, token.column);
                        ret null;
                    }
                }

                if this.included_paths.Index(path) != -1i64 {
                    found = true;
                    break;
                }

                let mut lexer: Lexer;
                let source: String = ReadFile(path.Data());
                let (tokens: Vector<Token>, current: u64, file: String) = (this.tokens, this.index, this.file);
                (this.tokens, this.index, this.file) = (lexer.Lex(source, path), 0u64, path);

                while this.CurrentToken()._type != TokenType::EOF {
                    let declaration: *const ASTNode = this.ParseDeclaration();

                    if declaration != null {
                        this.root->declarations.PushBack(declaration);
                    }
                }

                (this.tokens, this.index, this.file, found) = (tokens, current, file, true);
                this.included_paths.PushBack(path);
                break;
            }

            if found {
                i += 1u64;
            } else {
                this.Error((String("Module '") + module + "' not found").Data(), token.row, token.column);
                ret null;
            }
        } ret null;
    }

    pub Parse(this: &mut Parser, tokens: Vector<Token>, file: String) -> *const RootNode {
        (this.tokens, this.index) = (tokens, 0u64);
        (this.file, this.root) = (file, new RootNode());
        this.included_paths.Clear();
        this.types.Clear();

        while this.CurrentToken()._type != TokenType::EOF {
            let declaration: *const ASTNode = this.ParseDeclaration();

            if declaration != null {
                this.root->declarations.PushBack(declaration);
            }
        } ret this.root;
    }

    priv Error(this: &mut Parser, message: *const i8, row: u64, column: u64) {
        printf("Parser error: %s at line %d, column %d. (%s)\n", message, row, column, this.file.Data());
        exit(1i32);
    }
};