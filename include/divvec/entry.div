include "divmem" : *;

class Vector<T> {
    priv data: T* = null,
    priv size: i64 = 0i64
} impl {
    Vector() {}

    Vector(other: Vector<T>&) {
        if other.Data() == null { ret; }
        Allocate(other.Size());
        let i: i64 = 0i64;

        while i < size {
            data[i] = other.Data()[i];
            i += 1i64;
        }
    }

    ~Vector() {
        Release();
    }

    pub Data() -> T* { ret data; }
    pub Size() -> i64 { ret size; }

    pub Allocate(newSize: i64) {
        (data, size) = (new T[newSize], newSize);
    }

    pub Release() {
        if data != null { del[] data; }
        (data, size) = (null, 0i64);
    }

    pub PushBack(value: T) {
        let temp: T* = data;
        this->Allocate(size + 1i64);

        if temp != null {
            let i: i64 = 0i64;

            while i < size - 1i64 {
                data[i] = temp[i];
                i += 1i64;
            }

            del[] temp;
        }

        data[size - 1i64] = value;
    }

    pub PopBack() -> T {
        let temp: T* = data;
        this->Allocate(size - 1i64);
        let value: T = temp[size];

        if temp != null {
            let i: i64 = 0i64;

            while i < size {
                data[i] = temp[i];
                i += 1i64;
            }

            del[] temp;
        }

        ret value;
    }

    pub op=(other: Vector<T>&) -> Vector<T>& {
        this->Release();
        if other.Data() == null { ret *this; }
        this->Allocate(other.Size());
        let i: i64 = 0i64;

        while i < size {
            data[i] = other.Data()[i];
            i += 1i64;
        }

        ret *this;
    }
};